[{"title":"从零开始设计模式第5章-其他模式(1种)","url":"/2020/03/21/从零开始设计模式第5章/","content":"## 1.其他模式(1种)\n* 空对象模式(Null Object Pattern)\n\n\n### 1.1 空对象模式(Null Object Pattern)\n介绍：一个空对象取代 NULL 对象实例的检查。提供默认值，默认不做任何事情。\n使用场景：\n1. 有多个子类共有的方法，且逻辑相同。 \n2. 重要的、复杂的方法，可以考虑作为模板方法。\n\n#### 1.1.1示例\n```C#\n/**\n * 命令\n */\npublic interface Command {\n\n    /**\n     * 执行\n     */\n    void execute();\n\n    /**\n     * 撤销\n     */\n    void undo();\n}\n\npublic class LightOffCommand implements Command {\n\n    @Override\n    public void execute() {\n        System.out.println(\"light off\");\n    }\n\n    @Override\n    public void undo() {\n        System.out.println(\"light on\");\n    }\n}\n\npublic class LightOnCommand implements Command {\n\n    @Override\n    public void execute() {\n        System.out.println(\"light on\");\n    }\n\n    @Override\n    public void undo() {\n        System.out.println(\"light off\");\n    }\n}\n\n/**\n * 没有任何命令，空执行，用于初始化。\n * 可以省略对空的判断\n */\npublic class NullObjectCommand implements Command {\n\n    @Override\n    public void execute() {\n    }\n\n    @Override\n    public void undo() {\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n\n        Command[] commands = new Command[2];\n        for (int i = 0; i < commands.length; i++) {\n            // 默认值，减少了空的判断\n            commands[i] = new NullObjectCommand();\n        }\n\n    }\n}\n\n```\n![nullobject](/images/common/nullobject.png)\n解读：NullObjectCommand没有任何命令，空执行，用于初始化，可以省略对空的判断。\n\n\n","categories":["从零开始设计模式"]},{"title":"从零开始设计模式第4章-行为型模式(十一种)","url":"/2020/03/15/从零开始设计模式第4章/","content":"## 1.行为型模式(11种)\n* 模板模式(Template Pattern)\n* 命令模式(Command Pattern)\n* 访问者模式(Visitor Pattern)\n* 迭代器模式(Iterator Pattern) \n* 观察者模式(Observer Pattern)\n* 中介者模式(Mediator Pattern)\n* 备忘录模式(Memento Pattern)\n* 解释器模式(Interpreter Pattern)\n* 状态模式(State Pattern)\n* 策略模式(Strategy Pattern)\n* 职责链模式(Chain of Responsibility Pattern)\n\n### 1.1 模板模式(Template Method Pattern)\n介绍：也叫模板方法模式。定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。一般模板方法都加上final关键字，防止子类重写模板方法。\n使用场景：\n1. 有多个子类共有的方法，且逻辑相同。 \n2. 重要的、复杂的方法，可以考虑作为模板方法。\n\n**模板模式的钩子方法**\n在抽象类中，可以定义一个方法，它默认不做任何事情，子类可以视情况覆盖它，该方法称为\"钩子\"。\n\n#### 1.1.1示例\n```C#\npublic abstract class AbstractHandler<T> {\n\n    /**\n     * 模板方法\n     */\n    public final String process(T type, String message){\n        if (match(type)){\n            process(message);\n            return \"Y\";\n        }else if (match()){\n            process(message);\n            return \"Y\";\n        }else {\n            System.out.println(\"unknow type\");\n\n        }\n        return \"N\";\n    }\n\n    protected abstract String process(String message);\n\n    protected abstract boolean match(T type);\n\n    /**\n     * 钩子方法\n     * @return\n     */\n    public boolean match(){\n        return false;\n    }\n}\n\npublic enum MessageTypeEnum {\n\n    ORDER(\"order\", \"订单\"),\n\n    WAREHOUSE(\"warehouse\", \"仓库\");\n\n    private String type;\n\n    private String desc;\n\n    MessageTypeEnum(){}\n\n    MessageTypeEnum(String type, String desc) {\n        this.type = type;\n        this.desc = desc;\n    }\n}\n\npublic class OrderHandler extends AbstractHandler<MessageTypeEnum> {\n\n    @Override\n    protected String process(String message) {\n        System.out.println(message);\n        return \"Y\";\n    }\n\n    @Override\n    protected boolean match(MessageTypeEnum type) {\n        return MessageTypeEnum.ORDER == type;\n    }\n}\n\npublic class WareHouseHandler extends AbstractHandler<MessageTypeEnum> {\n\n    @Override\n    protected String process(String message) {\n        System.out.println(message);\n        return \"Y\";\n    }\n\n    @Override\n    protected boolean match(MessageTypeEnum type) {\n        return MessageTypeEnum.WAREHOUSE == type;\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        AbstractHandler<MessageTypeEnum> order = new OrderHandler();\n        order.process(MessageTypeEnum.ORDER, \"order\");\n\n        AbstractHandler<MessageTypeEnum> warehousse = new WareHouseHandler();\n        warehousse.process(MessageTypeEnum.WAREHOUSE, \"warehousse\");\n    }\n}\n```\n![template](/images/common/template.png)\n解读： \n#### 1.1.2 模板模式使用\nSpring IOC容器初始化\n\n### 1.2 命令模式(Command Pattern)\n介绍：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。\n使用场景：\n1. GUI 中每一个按钮都是一条命令。 \n2. 模拟 CMD。\n3. 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。\n#### 1.2.1示例\n```C#\n/**\n * 接收者\n */\npublic class LightReceiver {\n\n    public void on(){\n        System.out.println(\"light on\");\n    }\n\n    public void off(){\n        System.out.println(\"light off\");\n    }\n}\n\n/**\n * 命令\n */\npublic interface Command {\n\n    /**\n     * 执行\n     */\n    void execute();\n\n    /**\n     * 撤销\n     */\n    void undo();\n}\n\npublic class LightOffCommand implements Command{\n\n    private LightReceiver receiver;\n\n    public LightOffCommand(LightReceiver receiver){\n        this.receiver = receiver;\n    }\n\n    @Override\n    public void execute() {\n        receiver.off();\n    }\n\n    @Override\n    public void undo() {\n        receiver.on();\n    }\n}\n\npublic class LightOnCommand implements Command{\n\n    private LightReceiver receiver;\n\n    public LightOnCommand(LightReceiver receiver){\n        this.receiver = receiver;\n    }\n\n    @Override\n    public void execute() {\n        receiver.on();\n    }\n\n    @Override\n    public void undo() {\n        receiver.off();\n    }\n}\n\n/**\n * 没有任何命令，空执行，用于初始化。\n * 可以省略对空的判断\n */\npublic class NoCommand implements Command{\n\n    @Override\n    public void execute() {\n    }\n\n    @Override\n    public void undo() {\n    }\n}\n\n/**\n * 调用者\n */\npublic class Invoker {\n\n    private Command[] onCommands;\n    private Command[] offCommands;\n\n    // 撤销命令\n    private Command undoCommand;\n\n    private static final int SIZE = 5;\n\n    public Invoker() {\n        onCommands = new Command[SIZE];\n        offCommands = new Command[SIZE];\n        for (int i = 0; i < SIZE; i++) {\n            onCommands[i] = new NoCommand();\n            offCommands[i] = new NoCommand();\n        }\n    }\n\n    public void setCommand(int index, Command onCommand, Command offCommand){\n        onCommands[index] = onCommand;\n        offCommands[index] = offCommand;\n    }\n\n    public void on(int index){\n        onCommands[index].execute();\n        // 记录上次命令\n        undoCommand = onCommands[index];\n    }\n\n    public void off(int index){\n        offCommands[index].execute();\n        // 记录上次命令\n        undoCommand = offCommands[index];\n    }\n\n    // revert\n    public void undo(){\n        undoCommand.undo();\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n\n        LightReceiver receiver = new LightReceiver();\n        Command lightOnCommand = new LightOnCommand(receiver);\n        Command lightOffCommand = new LightOffCommand(receiver);\n\n        Invoker invoker = new Invoker();\n        invoker.setCommand(0, lightOnCommand, lightOffCommand);\n        invoker.on(0);\n        invoker.off(0);\n        invoker.undo();\n    }\n}\n```\n![command](/images/common/command.png)\n解读：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令\n#### 1.2.2 命令模式使用\nJdbc Template\n\n### 1.3 访问者模式(Visitor Pattern)\n介绍：将数据结构与数据操作分离。\n使用场景：\n1. 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 \n2. 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，也不希望在增加新操作时修改这些类。\n#### 1.3.1示例\n```C#\n/**\n * 访问者\n */\npublic abstract class Action {\n\n    public abstract void getResultMan(Person person);\n\n    public abstract void getResultWomen(Person person);\n}\n\npublic class Success extends Action{\n    @Override\n    public void getResultMan(Person person) {\n        System.out.println(person.getName() + \"success\");\n    }\n\n    @Override\n    public void getResultWomen(Person person) {\n        System.out.println(person.getName() + \"success\");\n    }\n}\n\npublic class Fail extends Action{\n    @Override\n    public void getResultMan(Person person) {\n        System.out.println(person.getName() + \"fail\");\n    }\n\n    @Override\n    public void getResultWomen(Person person) {\n        System.out.println(person.getName() + \"fail\");\n    }\n}\n\npublic abstract class Person {\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Person(String name) {\n        this.name = name;\n    }\n\n    public abstract void accept(Action action);\n}\n\npublic class Man extends Person {\n\n    public Man(String name) {\n        super(name);\n    }\n\n    /**\n     * 双分派\n     * Man在Action中作为参数传递(第一次分派)\n     * Man在方法中调用Action，同时将自己(this)作为参数传入(第二次分派)\n     */\n    @Override\n    public void accept(Action action) {\n        action.getResultMan(this);\n    }\n}\n\npublic class Women extends Person {\n\n    public Women(String name) {\n        super(name);\n    }\n\n    @Override\n    public void accept(Action action) {\n        action.getResultWomen(this);\n    }\n}\n\npublic class ObjectStructure {\n\n    private List<Person> people = new LinkedList<>();\n\n    public void attach(Person person){\n        people.add(person);\n    }\n\n    public void detach(Person person){\n        people.remove(person);\n    }\n\n    public void disPlay(Action action){\n        people.forEach( person -> {\n            person.accept(action);\n        });\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        ObjectStructure client = new ObjectStructure();\n        client.attach(new Man(\"Ming\"));\n        client.attach(new Women(\"Hong\"));\n\n        Success success = new Success();\n        client.disPlay(success);\n\n        Fail fail = new Fail();\n        client.disPlay(fail);\n    }\n}\n```\n![visitor](/images/common/visitor.png)\n解读：在被访问的类Person里面加一个对外提供接待访问者的接口accept()。\n#### 1.3.2 访问者模式使用\n\n\n### 1.4 迭代器模式(Iterator Pattern)\n介绍：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。\n使用场景：\n 1. 访问一个聚合对象的内容而无须暴露它的内部表示。 \n 2. 需要为聚合对象提供多种遍历方式。\n 3. 为遍历不同的聚合结构提供一个统一的接口。\n #### 1.4.1示例\n```C#\n/**\n * 专业\n */\npublic class Department {\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Department(String name) {\n        this.name = name;\n    }\n}\n\n/**\n * 学院\n */\npublic interface College {\n\n    String getName();\n\n    void addDepartment(String name);\n\n    Iterator iterator();\n}\n\npublic class ComputerCollege implements College {\n\n    Department[] departments = new Department[5];\n    // 当前数组的对象个数\n    int num = 0;\n\n    @Override\n    public String getName() {\n        return \"计算机学院\";\n    }\n\n    // 初始化数据\n    public ComputerCollege() {\n        addDepartment(\"Java\");\n        addDepartment(\"Spring\");\n        addDepartment(\"数据结构\");\n    }\n\n    @Override\n    public void addDepartment(String name) {\n        Department department = new Department(name);\n        departments[num] = department;\n        num += 1;\n    }\n\n    @Override\n    public Iterator iterator() {\n        return new ComputerCollegeIterator(departments);\n    }\n}\n\npublic class InfoCollege implements College {\n\n    List<Department> departments = new ArrayList<>();\n\n    @Override\n    public String getName() {\n        return \"信息工程学院\";\n    }\n\n    public InfoCollege() {\n        addDepartment(\"信息安全\");\n        addDepartment(\"网络安全\");\n        addDepartment(\"服务器安全\");\n    }\n\n    @Override\n    public void addDepartment(String name) {\n        Department department = new Department(name);\n        departments.add(department);\n    }\n\n    @Override\n    public Iterator iterator() {\n        return new InfoCollegeIterator(departments);\n    }\n}\n\npublic class ComputerCollegeIterator implements Iterator{\n\n    // 需要知道存放的形式 Arrays[]\n    Department[] departments;\n    // 遍历的位置\n    int position = 0;\n\n    public ComputerCollegeIterator(Department[] departments) {\n        this.departments = departments;\n    }\n\n    @Override\n    public boolean hasNext() {\n        if (position >= departments.length || departments[position] == null){\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public Object next() {\n        Department department = departments[position];\n        position += 1;\n        return department;\n    }\n\n    @Override\n    public void remove() {\n\n    }\n}\n\npublic class InfoCollegeIterator implements Iterator{\n\n    // 需要知道存放的形式 List\n    List<Department> departments;\n    // 遍历的位置\n    int position = -1;\n\n    public InfoCollegeIterator(List<Department> departments) {\n        this.departments = departments;\n    }\n\n    @Override\n    public boolean hasNext() {\n        if (position >= departments.size() - 1){\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public Object next() {\n        position += 1;\n        return  departments.get(position);\n    }\n\n    @Override\n    public void remove() {\n\n    }\n}\n\npublic class OutPut {\n\n    // 学院\n    List<College> collegeList;\n\n    public OutPut(List<College> collegeList) {\n        this.collegeList = collegeList;\n    }\n\n    public void printCollege(){\n        Iterator<College> iterator = collegeList.iterator();\n        while (iterator.hasNext()){\n            College next = iterator.next();\n            System.out.println(next.getName());\n            printDepartment(next.iterator());\n        }\n    }\n\n    /**\n     * 通过迭代器进行输出\n     * @param iterator\n     */\n    public void printDepartment(Iterator iterator){\n        while (iterator.hasNext()){\n            Department next = (Department)iterator.next();\n            System.out.println(next.getName());\n        }\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        List<College> colleges = new ArrayList<>();\n        ComputerCollege computerCollege = new ComputerCollege();\n        InfoCollege infoCollege = new InfoCollege();\n        colleges.add(computerCollege);\n        colleges.add(infoCollege);\n\n        OutPut outPut = new OutPut(colleges);\n        outPut.printCollege();\n    }\n}\n```\n![iterator](/images/common/iterator.png)\n解读：InfoCollegeIterator和ComputerCollegeIterator通过实现Iterator，来完成用统一的迭代器进行输出打印。\n\nCollege和University通过聚合的方式组合起来，可以很方便的增加和删除，而叶子节点是最小的节点，不需要增加和删除。需要注意的是这里的College和University继承了同一个抽象类，需具有相同的部分。\n#### 1.4.2 迭代器模式使用\nJDK的ArrayList\n\n### 1.5 观察者模式(Observer Pattern)\n介绍：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n使用场景：\n1. 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。\n2. 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。\n3. 一个对象必须通知其他对象，而并不知道这些对象是谁。\n4. 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。\n#### 1.5.1示例\n```C#\n/**\n * 观察者\n */\npublic interface Observer {\n\n    void update(Wether wether);\n}\n\npublic class SinaObserver implements Observer {\n\n    private Wether wether;\n\n    @Override\n    public void update(Wether wether) {\n        this.wether = wether;\n        display();\n    }\n\n    public void display(){\n        System.out.println(wether.toString());\n    }\n}\n\npublic class Wether {\n\n    private float temperature;\n\n    private float pressure;\n\n    private float humidity;\n\n    public Wether(float temperature, float pressure, float humidity) {\n        this.temperature = temperature;\n        this.pressure = pressure;\n        this.humidity = humidity;\n    }\n\n    @Override\n    public String toString() {\n        return \"Wether{\" +\n                \"temperature=\" + temperature +\n                \", pressure=\" + pressure +\n                \", humidity=\" + humidity +\n                '}';\n    }\n}\n\npublic interface Subject {\n\n    /**\n     * 订阅\n     */\n    void registerObservers(Observer observer);\n\n    /**\n     * 取消\n     */\n    void removeObservers(Observer observer);\n\n    /**\n     * 通知\n     */\n    void notifyObservers();\n}\n\npublic class WetherData implements Subject{\n\n    private Wether wether;\n\n    private List<Observer> observers = new ArrayList<>();\n\n    public WetherData(Wether wether) {\n        this.wether = wether;\n    }\n\n    /**\n     * 更新时通知\n     * @param wether\n     */\n    public void update(Wether wether){\n        this.wether = wether;\n        notifyObservers();\n    }\n\n    @Override\n    public void registerObservers(Observer observer) {\n        observers.add(observer);\n    }\n\n    @Override\n    public void removeObservers(Observer observer) {\n        if (observers.contains(observer)){\n            observers.remove(observer);\n        }\n    }\n\n    @Override\n    public void notifyObservers() {\n        observers.forEach(observer -> {\n            observer.update(wether);\n        });\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        WetherData wetherData = new WetherData(new Wether(3.2F, 4.4F, 5.6F));\n\n        // 观察者\n        SinaObserver sinaObserver = new SinaObserver();\n        wetherData.registerObservers(sinaObserver);\n\n        // 推送\n        wetherData.notifyObservers();\n        // 更新\n        wetherData.update(new Wether(3F, 4F, 5F));\n    }\n}\n```\n![observer](/images/common/observer.png)\n解读：Observe作为观察者，WetherData用集合管理观察者，可以进行订阅、取消、通知。\n\n#### 1.5.2 观察者模式使用\nJDK中的Observable\n\n### 1.6 中介者模式(Mediator Pattern)\n介绍：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n使用场景：\n1. 系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。\n2. 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。\n#### 1.6.1示例\n```C#\n/**\n * 中介者\n */\npublic abstract class Mediator {\n\n    // 将中介者对象，加入到集合中\n    public abstract void Register(User user);\n\n\n    public abstract void getMessage(User user, String message);\n\n    public abstract void sendMessage();\n}\n\npublic class ConcreateMediator extends Mediator {\n\n    // 用户集合\n    private HashMap<String, User> userMap = new HashMap<>();\n    // 消息集合\n    private HashMap<String, String> messageMap = new HashMap<>();\n\n    @Override\n    public void Register(User user) {\n        userMap.put(user.getName(), user);\n    }\n\n    @Override\n    public void getMessage(User user, String message) {\n        messageMap.put(user.getName(), message);\n        System.out.println(LocalDate.now().format(DateTimeFormatter.ISO_DATE) + \": \" + message);\n    }\n\n    @Override\n    public void sendMessage() {\n        messageMap.forEach((k, v) -> {System.out.println(v);});\n    }\n}\n\n\npublic abstract class User {\n\n    private Mediator mediator;\n    private String name;\n\n    public User(Mediator mediator, String name) {\n        this.mediator = mediator;\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public Mediator getMediator() {\n        return mediator;\n    }\n\n    public abstract void sendMessage(String message);\n}\n\npublic class XiaoHong extends User {\n\n    public XiaoHong(Mediator mediator, String name) {\n        super(mediator, name);\n        mediator.Register(this);\n    }\n\n    @Override\n    public void sendMessage(String message) {\n        this.getMediator().getMessage(this, message);\n    }\n}\n\npublic class XiaoMing extends User {\n\n    public XiaoMing(Mediator mediator, String name) {\n        super(mediator, name);\n        mediator.Register(this);\n    }\n\n    @Override\n    public void sendMessage(String message) {\n        this.getMediator().getMessage(this, message);\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        Mediator mediator = new ConcreateMediator();\n\n        User xiaoming = new XiaoMing(mediator, \"xiaoming\");\n        User xiaohong = new XiaoHong(mediator, \"xiaohong\");\n\n        xiaoming.sendMessage(\"Hi, I am xiaoming!\");\n        xiaohong.sendMessage(\"Hi, I am xiaohong!\");\n    }\n}\n\n```\n![mediator](/images/common/mediator.png)\n解读：Mediator作为中介者负责消息的接收和转发\n\n#### 1.6.2 中介者模式使用\n\n\n### 1.7 备忘录模式(Memento Pattern)\n介绍：在不破坏封装性的前提下，捕获一个对象的内部状态，**并在该对象之外保存这个状态。**\n使用场景：\n1. 需要保存/恢复数据的相关状态场景。\n2. 提供一个可回滚的操作。\n3. 为了节约内存，可使用原型模式+备忘录模式。\n\n#### 1.7.1示例\n```C#\n/**\n * 需要保存状态的对象\n */\npublic class Originator {\n    // 状态信息\n    private String state;\n\n    // 保存一个状态对象\n    public Memento saveStateMemento(){\n        return new Memento(state);\n    }\n\n    // 通过备忘录对象，恢复状态\n    public void getStateFromMemento(Memento memento){\n        state = memento.getState();\n    }\n\n    public String getState() {\n        return state;\n    }\n\n    public void setState(String state) {\n        this.state = state;\n    }\n}\n\n\n/**\n * 备忘录对象，负责保存状态\n */\npublic class Memento {\n\n    private String state;\n\n    public String getState() {\n        return state;\n    }\n\n    public Memento(String state) {\n        this.state = state;\n    }\n}\n\n/**\n * 守护者对象，负责保存多个备忘录对象\n */\npublic class Caretaker {\n\n    private List<Memento> mementoList = new ArrayList<>();\n\n    public void add (Memento memento){\n        mementoList.add(memento);\n    }\n\n    public Memento get(int index){\n        return mementoList.get(index);\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        Originator originator = new Originator();\n        Caretaker caretaker = new Caretaker();\n\n        originator.setState(\"状态#1 攻击力 100\");\n        caretaker.add(originator.saveStateMemento());\n\n        originator.setState(\"状态#2 攻击力 80\");\n        caretaker.add(originator.saveStateMemento());\n\n        originator.setState(\"状态#3 攻击力 50\");\n        caretaker.add(originator.saveStateMemento());\n\n        System.out.println(\"当前状态：\" + originator.getState());\n        originator.getStateFromMemento(caretaker.get(0));\n        System.out.println(\"恢复状态：\" + originator.getState());\n    }\n}\n\n\n```\n![memento](/images/common/memento.png)\n解读：\n\n#### 1.7.2 备忘录模式使用\n\n### 1.8 解释器模式(Interpreter Pattern)\n介绍：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。\n使用场景：\n1. 以将一个需要解释执行的语言中的句子表示为一个抽象语法树。\n2. 一些重复出现的问题可以用一种简单的语言来进行表达。 \n3. 一个简单语法需要解释的场景。\n4. 可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。\n\n#### 1.8.1示例\n```C#\n/**\n * 抽象表达式\n */\npublic interface Expression {\n\n    int getValue();\n}\n\npublic abstract class OperatorExpression implements Expression{\n\n    // 左值\n    protected Expression left;\n    // 右值\n    protected Expression right;\n\n    public OperatorExpression(Expression left, Expression right) {\n        this.left = left;\n        this.right = right;\n    }\n\n    public abstract int getValue();\n}\n\npublic class SubExpression extends OperatorExpression {\n\n    public SubExpression(Expression left, Expression right) {\n        super(left, right);\n    }\n\n    @Override\n    public int getValue() {\n        return left.getValue() - right.getValue();\n    }\n}\n\npublic class AddExpression extends OperatorExpression {\n\n    public AddExpression(Expression left, Expression right) {\n        super(left, right);\n    }\n\n    @Override\n    public int getValue() {\n        return left.getValue() + right.getValue();\n    }\n}\n\npublic class VarExpression implements Expression {\n\n    private String value;\n\n    public VarExpression(String value) {\n        this.value = value;\n    }\n\n    @Override\n    public int getValue() {\n        return Integer.valueOf(this.value);\n    }\n}\n\n/**\n * 常量\n */\npublic interface OperatorConstant {\n\n    char ADD = '+';\n\n    char SUB = '-';\n}\n\npublic class ExpressionParser {\n\n    private Expression expression;\n\n    public Expression parseExpression(String expStr){\n        Stack<Expression> stack = new Stack<>();\n        // 拆分表达式\n        char[] charArray = expStr.toCharArray();\n\n        Expression left = null;\n        Expression right = null;\n\n        // 1+3-2\n        for (int i = 0; i < charArray.length; i++){\n            switch (charArray[i]){\n                case OperatorConstant.ADD :\n                    // 先取出左边\n                    left = stack.pop();\n                    // 取出右边\n                    right = new VarExpression(String.valueOf(charArray[++i]));\n                    // 运算后push\n                    stack.push(new AddExpression(left, right));\n                    break;\n                case OperatorConstant.SUB :\n                    left = stack.pop();\n                    right = new VarExpression(String.valueOf(charArray[++i]));\n                    stack.push(new SubExpression(left, right));\n                    break;\n                default :\n                    // 如果是变量，就创建VarExpression对象，并push\n                    stack.push(new VarExpression(String.valueOf(charArray[i])));\n                    break;\n            }\n        }\n        // 当遍历完整个charArray后，stack最后得到的Expression\n        this.expression = stack.pop();\n        return expression;\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) throws IOException {\n        String context = getExpStr();\n        ExpressionParser expressionParser = new ExpressionParser();\n        Expression result = expressionParser.parseExpression(context);\n        println(result.getValue());\n\n    }\n\n    public static String getExpStr() throws IOException{\n        System.out.println(\"interpreter version 0.0.1\");\n        System.out.print(\">>\");\n        InputStreamReader inputStreamReader = new InputStreamReader(System.in);\n        return new BufferedReader(inputStreamReader).readLine();\n    }\n\n    public static void println(int result){\n        System.out.print(\">>\");\n        System.out.println(result);\n    }\n}\n```\n![interpreter](/images/common/interpreter.png)\n解读：Expression为抽象的表达式，其子类根据不同字符进行不同解释。ExpressionParser作为表达式解释器的入口工具，最终返回一个表达式。\n\n#### 1.8.2 解释器模式使用\nSpring中的SpelExpressionParser\n\n\n### 1.9 状态模式(State Pattern)\n介绍：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。\n使用场景：\n1. 行为随状态改变而改变的场景。\n2. 条件、分支语句的代替者。\n\n#### 1.9.1示例\n```C#\npublic enum ThreadStatusEnum {\n\n    START(\"新建状态\", 0),\n    RUNNABLE(\"就绪状态\", 1),\n    RUNNING(\"运行状态\", 2),\n    BLOCKED(\"阻塞状态\", 3),\n    DEAD(\"死亡状态\", 4);\n\n    private String name;\n    private int status;\n\n    public String getName() {\n        return name;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    ThreadStatusEnum(String name, int status) {\n        this.name = name;\n        this.status = status;\n    }\n}\n\npublic interface ThreadState {\n\n    void start(ThreadContext context);\n    void getCPU(ThreadContext context);\n    void suspend(ThreadContext context);\n    void resume(ThreadContext context);\n    void stop(ThreadContext context);\n}\n\npublic abstract class AbstractThreadState implements ThreadState{\n\n    protected int threadStatus = 0;\n\n    public int getThreadStatus() {\n        return threadStatus;\n    }\n\n    private static final RuntimeException EXCEPTION = new RuntimeException(\"cannot do it\");\n\n    /**\n     * 抽象类默认实现\n     */\n\n    @Override\n    public void start(ThreadContext context) { throw EXCEPTION; }\n\n    @Override\n    public void getCPU(ThreadContext context) { throw EXCEPTION; }\n\n    @Override\n    public void suspend(ThreadContext context) { throw EXCEPTION; }\n\n    @Override\n    public void resume(ThreadContext context) { throw EXCEPTION; }\n\n    @Override\n    public void stop(ThreadContext context) { throw EXCEPTION; }\n}\n\npublic class NewState extends AbstractThreadState{\n\n    public NewState() {\n        this.threadStatus = ThreadStatusEnum.START.getStatus();\n        System.out.println(\"当前线程处于：\" + ThreadStatusEnum.START.getName());\n    }\n\n    /**\n     * 开始\n     */\n    @Override\n    public void start(ThreadContext context) {\n        if (ThreadStatusEnum.START.getStatus() == context.getThreadStatus()){\n            System.out.println(\"start() ->\" + ThreadStatusEnum.RUNNABLE.getName());\n            context.setState(new RunnableState());\n        }else {\n            System.out.println(\"cannot start\");\n        }\n    }\n}\n\npublic class RunnableState extends AbstractThreadState{\n\n    public RunnableState() {\n        this.threadStatus = ThreadStatusEnum.RUNNABLE.getStatus();\n        System.out.println(\"当前线程处于：\" + ThreadStatusEnum.RUNNABLE.getName());\n    }\n\n    /**\n     * 获取CPU分配\n     */\n    public void getCPU(ThreadContext context) {\n        if (ThreadStatusEnum.RUNNABLE.getStatus() == context.getThreadStatus()){\n            System.out.println(\"getCPU() ->\" + ThreadStatusEnum.RUNNING.getName());\n            context.setState(new RunningState());\n        }else {\n            System.out.println(\"cannot getCPU\");\n        }\n    }\n\n}\n\npublic class RunningState extends AbstractThreadState{\n\n    public RunningState() {\n        this.threadStatus = ThreadStatusEnum.RUNNING.getStatus();\n        System.out.println(\"当前线程处于：\" + ThreadStatusEnum.RUNNING.getName());\n    }\n\n    /**\n     * 暂停\n     */\n    public void suspend(ThreadContext context) {\n        if (ThreadStatusEnum.RUNNING.getStatus() == context.getThreadStatus()){\n            System.out.println(\"suspend() ->\" + ThreadStatusEnum.BLOCKED.getName());\n            context.setState(new BlockedState());\n        }else {\n            System.out.println(\"cannot suspend\");\n        }\n    }\n\n    /**\n     * 停止\n     */\n    public void stop(ThreadContext context) {\n        if (ThreadStatusEnum.RUNNING.getStatus() == context.getThreadStatus()){\n            System.out.println(\"stop() ->\" + ThreadStatusEnum.DEAD.getName());\n            context.setState(new DeadState());\n        }else {\n            System.out.println(\"cannot stop\");\n        }\n    }\n}\n\npublic class BlockedState extends AbstractThreadState{\n\n    public BlockedState() {\n        this.threadStatus = ThreadStatusEnum.BLOCKED.getStatus();\n        System.out.println(\"当前线程处于：\" + ThreadStatusEnum.BLOCKED.getName());\n    }\n\n    /**\n     * 恢复\n     */\n    public void resume(ThreadContext context) {\n        if (ThreadStatusEnum.BLOCKED.getStatus() == context.getThreadStatus()){\n            System.out.println(\"resume() ->\" + ThreadStatusEnum.BLOCKED.getName());\n            context.setState(new RunningState());\n        }else {\n            System.out.println(\"cannot resume\");\n        }\n    }\n}\n\npublic class DeadState extends AbstractThreadState{\n\n    public DeadState() {\n        this.threadStatus = ThreadStatusEnum.DEAD.getStatus();\n        System.out.println(\"当前线程处于：\" + ThreadStatusEnum.DEAD.getName());\n    }\n}\n\n/**\n * 上下文 环境类\n */\npublic class ThreadContext{\n\n    private AbstractThreadState state;\n\n    // 读取状态\n    public int getThreadStatus() { return state.getThreadStatus(); }\n\n    // 设置状态\n    public void setState(AbstractThreadState state) { this.state = state; }\n\n    // 初始化状态\n    public ThreadContext() { this.state = new NewState(); }\n\n    public void start() { state.start(this); }\n\n    public void getCPU() { state.getCPU(this); }\n\n    public void suspend() { state.suspend(this); }\n\n    public void resume() { state.resume(this); }\n\n    public void stop() { state.stop(this); }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        ThreadContext thread = new ThreadContext();\n        thread.start();\n        thread.getCPU();\n        thread.suspend();\n        thread.resume();\n        thread.getCPU();\n        thread.stop();\n    }\n}\n\n```\n![state](/images/common/state.png)\n解读：ThreadContext是一个带有状态的类，当改变其状态时，其调用的方法也在发生改变。\n\n#### 1.9.2 状态模式使用\n\n\n### 2.0 策略模式(Strategy Pattern)\n介绍：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。通过组合或聚合来解决继承问题。\n说明：避免if...else语句。变化的部分则是不同的策略，但需要注意的是策略过多会导致类数目庞大。\n使用场景：\n1. 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。\n2. 一个系统需要动态地在几种算法中选择一种。\n3. 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。\n\n#### 2.0.1示例\n```C#\n/**\n * 策略类\n */\npublic interface Strategy {\n\n    void handle();\n}\n\npublic class ConcreteStrategyA implements Strategy{\n\n    @Override\n    public void handle() {\n        System.out.println(\"strategy A\");\n    }\n}\n\npublic class ConcreteStrategyB implements Strategy{\n\n    @Override\n    public void handle() {\n        System.out.println(\"strategy B\");\n    }\n}\n\npublic class Context {\n\n    private Strategy strategy;\n\n    public void setStrategy(Strategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public Context() {}\n\n    public void handle(){\n        // 也可用空对象模式\n        if (null == strategy){\n            System.out.println(\"default\");\n        }else {\n        strategy.handle();\n        }\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        Strategy strategyA = new ConcreteStrategyA();\n        Strategy strategyB = new ConcreteStrategyB();\n\n        Context context = new Context();\n        context.handle();\n\n\n        context.setStrategy(strategyA);\n        context.handle();\n\n        context.setStrategy(strategyB);\n        context.handle();\n        \n        Integer[] data = {1, 5, 2};\n        Arrays.sort(data, (v1, v2) -> {\n            // 策略\n            if(v1.compareTo(v2) > 0){\n                return -1;\n            }else {\n                return 1;\n            }\n        });\n    }\n}\n```\n![strategy](/images/common/strategy.png)\n解读：Context聚合了抽象策略类，通过传入不同的策略，改变其结果。\n\n\n#### 2.0.2 策略模式使用\nArrays的Comparator\n\n### 2.1 职责链模式(Chain of Responsibility Pattern)\n介绍：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。\n使用场景：\n1. 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。\n2. 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。\n3. 可动态指定一组对象处理请求。\n\n#### 2.1.1示例\n```C#\n/**\n * 自定义请求\n */\npublic class MyRequest {\n\n    private String host;\n\n    private int port;\n\n    private int id;\n\n    public int getPort() {\n        return port;\n    }\n\n    public MyRequest(String host, int port, int id) {\n        this.host = host;\n        this.port = port;\n        this.id = id;\n    }\n}\n\n/**\n * 处理者\n */\npublic abstract class AbstractFilter {\n\n    protected String name;\n\n    // 下一个处理者，形成链式\n    AbstractFilter filter;\n\n    public AbstractFilter(String name) {\n        this.name = name;\n    }\n\n    public void setFilter(AbstractFilter filter) {\n        this.filter = filter;\n    }\n\n    public abstract void handler(MyRequest request);\n}\n\npublic class ConcreteFilterA extends AbstractFilter{\n\n    public ConcreteFilterA(String name) {\n        super(name);\n    }\n\n    @Override\n    public void handler(MyRequest request) {\n        if (request.getPort() == 80){\n            System.out.println(\"FilterA handler\");\n        }else {\n            if (null == filter){\n                filter = new ConcreteFilterB(\"FilterB\");\n            }\n            filter.handler(request);\n        }\n    }\n}\n\npublic class ConcreteFilterB extends AbstractFilter{\n\n    public ConcreteFilterB(String name) {\n        super(name);\n    }\n\n    @Override\n    public void handler(MyRequest request) {\n        if (request.getPort() == 4000){\n            System.out.println(\"FilterB handler\");\n        }else {\n            if (null == filter){\n                filter = new ConcreteFilterB(\"FilterA\");\n            }\n            filter.handler(request);\n        }\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        MyRequest request1 = new MyRequest(\"127.0.0.1\", 80, 0);\n        MyRequest request2 = new MyRequest(\"127.0.0.1\", 4000, 1);\n\n        AbstractFilter filter = new ConcreteFilterA(\"FilterA\");\n\n        filter.handler(request1);\n        filter.handler(request2);\n\n    }\n}\n```\n![responsibilitychain](/images/common/responsibilitychain.png)\n解读：AbstractFilter是一个抽象的处理者，处理者中又聚合了下一个处理者，当自身无法处理的时候，就可以交给下一个处理者处理。\n\n#### 2.1 .2 职责链模式使用\nSpingMVC中的HandlerExecutionChain+","categories":["从零开始设计模式"]},{"title":"从零开始设计模式第3章-结构型模式(七种)","url":"/2020/01/12/从零开始设计模式第3章/","content":"## 1.结构型模式(7种)\n* 适配器模式(Adapter Pattern)\n* 桥接模式(Bridge Pattern)\n* 装饰器模式(Decorator Pattern)\n* 组合模式(Composite Pattern)\n* 外观模式(Facade Pattern)\n* 享元模式(Flyweight Pattern)\n* 代理模式(Proxy Pattern)\n\n### 1.1 适配器模式(Adapter Pattern)\n介绍：也叫变压器模式。将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。(适配器**继承或依赖**已有的对象，**实现**想要的目标接口。)\n使用场景：\n1. 美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 \n2. JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 \n3. 在 LINUX 上运行 WINDOWS 程序。 \n4. JAVA 中的 jdbc。\n\n#### 1.1.1示例\n```C#\n/**\n * src\n */\npublic interface MediaPlayer {\n    void play(String audioType, String fileName);\n}\n\n/**\n * target\n */\npublic interface AdvancedMediaPlayer {\n    void playVlc(String fileName);\n    void playMp4(String fileName);\n}\n\npublic class Mp4Player implements AdvancedMediaPlayer {\n    @Override\n    public void playVlc(String fileName) {\n        // nothing\n    }\n\n    @Override\n    public void playMp4(String fileName) {\n        System.out.println(\"Playing mp4 file. Name: \"+ fileName);\n    }\n}\n\npublic class VlcPlayer implements AdvancedMediaPlayer {\n    @Override\n    public void playVlc(String fileName) {\n        System.out.println(\"Playing vlc file. Name: \"+ fileName);\n    }\n\n    @Override\n    public void playMp4(String fileName) {\n        // nothing\n    }\n}\n\n/**\n * adapter\n */\npublic class MediaAdapter implements MediaPlayer {\n\n    AdvancedMediaPlayer advancedMusicPlayer;\n\n    public MediaAdapter(String audioType){\n        if(audioType.equalsIgnoreCase(\"vlc\") ){\n            advancedMusicPlayer = new VlcPlayer();\n        } else if (audioType.equalsIgnoreCase(\"mp4\")){\n            advancedMusicPlayer = new Mp4Player();\n        }\n    }\n\n    /**\n     * adapte the src to target\n     * @param audioType\n     * @param fileName\n     */\n    @Override\n    public void play(String audioType, String fileName) {\n        if(audioType.equalsIgnoreCase(\"vlc\")){\n            advancedMusicPlayer.playVlc(fileName);\n        }else if(audioType.equalsIgnoreCase(\"mp4\")){\n            advancedMusicPlayer.playMp4(fileName);\n        }\n    }\n}\n\n/**\n * use the adapter\n */\npublic class AudioPlayer implements MediaPlayer {\n    MediaAdapter mediaAdapter;\n\n    @Override\n    public void play(String audioType, String fileName) {\n\n        // 播放 mp3 音乐文件的内置支持\n        if(audioType.equalsIgnoreCase(\"mp3\")){\n            System.out.println(\"Playing mp3 file. Name: \"+ fileName);\n        }\n        // mediaAdapter 提供了播放其他文件格式的支持\n        else if(audioType.equalsIgnoreCase(\"vlc\")\n                || audioType.equalsIgnoreCase(\"mp4\")){\n            mediaAdapter = new MediaAdapter(audioType);\n            mediaAdapter.play(audioType, fileName);\n        }\n        else{\n            System.out.println(\"Invalid media. \"+\n                    audioType + \" format not supported\");\n        }\n    }\n}\n\npublic class Client {\n    public static void main(String[] args) {\n        AudioPlayer audioPlayer = new AudioPlayer();\n\n        audioPlayer.play(\"mp3\", \"beyond the horizon.mp3\");\n        audioPlayer.play(\"mp4\", \"alone.mp4\");\n        audioPlayer.play(\"vlc\", \"far far away.vlc\");\n        audioPlayer.play(\"avi\", \"mind me.avi\");\n    }\n}\n\n```\n![factory](/images/common/adapter.png)\n解读：AudioPlayer通过适配器MediaAdapter将原来的MediaPlayer转换成了AdvancedMediaPlayer。 \n#### 1.1.2 适配器模式使用\nSpringMVC中的HandlerAdapter\n\n### 1.2 桥接模式(Bridge Pattern)\n介绍：将抽象部分与实现部分分离，使它们都可以独立的变化。\n使用场景：\n1. 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 \n2. 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。\n3. 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。\n#### 1.2.1示例\n```C#\npublic interface Brand {\n    void open();\n\n    void close();\n\n    void call();\n}\n\npublic class XiaoMi implements Brand {\n    @Override\n    public void open() {\n        System.out.println(\"Xiaomi open\");\n    }\n\n    @Override\n    public void close() {\n        System.out.println(\"Xiaomi close\");\n    }\n\n    @Override\n    public void call() {\n        System.out.println(\"Xiaomi call\");\n    }\n}\n\npublic class Iphone implements Brand {\n    @Override\n    public void open() {\n        System.out.println(\"Iphone open\");\n    }\n\n    @Override\n    public void close() {\n        System.out.println(\"Iphone close\");\n    }\n\n    @Override\n    public void call() {\n        System.out.println(\"Iphone call\");\n    }\n}\n\n/**\n * 桥接类\n */\npublic abstract class Phone {\n\n    // 组合品牌\n    private Brand brand;\n\n    public Phone(Brand brand){\n        super();\n        this.brand = brand;\n    }\n\n    protected void open() {\n        brand.open();\n    }\n\n    protected void close() {\n        brand.close();\n    }\n\n    protected void call() {\n        brand.call();\n    }\n}\n\npublic class FoledPhone extends Phone{\n\n    public FoledPhone(Brand brand) {\n        super(brand);\n    }\n\n    public void open() {\n        super.open();\n        System.out.println(\"折叠式手机\");\n    }\n\n    public void close() {\n        super.close();\n        System.out.println(\"折叠式手机\");\n    }\n\n    public void call() {\n        super.call();\n        System.out.println(\"折叠式手机\");\n    }\n}\n\npublic class UpRightPhone extends Phone{\n\n    public UpRightPhone(Brand brand) {\n        super(brand);\n    }\n\n    public void open() {\n        super.open();\n        System.out.println(\"直立式手机\");\n    }\n\n    public void close() {\n        super.close();\n        System.out.println(\"直立式手机\");\n    }\n\n    public void call() {\n        super.call();\n        System.out.println(\"直立式手机\");\n    }\n}\n\n\npublic class Client {\n\n    public static void main(String[] args){\n        Phone foledPhone = new FoledPhone(new Iphone());\n        foledPhone.open();\n        foledPhone.close();\n        foledPhone.call();\n\n        Phone upRightPhone = new UpRightPhone(new XiaoMi());\n        upRightPhone.open();\n        upRightPhone.close();\n        upRightPhone.call();\n    }\n}\n```\n![bridge](/images/common/bridge.png)\n解读：Phone作为桥接类，将不同的Brand通过聚合的方式组合起来。\n#### 1.2.2 桥接模式使用\nJDBC中的Driver\n\n### 1.3 装饰器模式(Decorator Pattern)\n介绍：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。\n使用场景：\n1. 扩展一个类的功能。 \n2. 动态增加功能，动态撤销。\n#### 1.3.1示例\n```C#\n/**\n * 整体抽象出来\n */\npublic abstract class Drink {\n\n    public String desc;\n\n    private float price = 0.0f;\n\n    // 重点：计算费用，由子类实现\n    public abstract float cost();\n\n    public String getDesc() {\n        return desc;\n    }\n\n    public void setDesc(String desc) {\n        this.desc = desc;\n    }\n\n    public float getPrice() {\n        return price;\n    }\n\n    public void setPrice(float price) {\n        this.price = price;\n    }\n}\n\n/**\n * 被装饰者\n */\npublic class Coffee extends Drink{\n\n    @Override\n    public float cost() {\n        return super.getPrice();\n    }\n}\n\npublic class Espresso extends Coffee {\n    public Espresso(){\n        setDesc(\"意大利咖啡\");\n        setPrice(6.0f);\n    }\n}\n\npublic class LongBlack extends Coffee{\n\n    public LongBlack(){\n        setDesc(\"美式咖啡\");\n        setPrice(5.0f);\n    }\n}\n\n/**\n * 装饰者\n */\npublic class Decorator extends Drink{\n\n    // 被装饰者\n    private Drink drink;\n\n    public Decorator(Drink drink){\n        this.drink = drink;\n    }\n\n    //组合\n    @Override\n    public float cost() {\n        return super.getPrice() + drink.getPrice();\n    }\n\n    @Override\n    public String getDesc() {\n        return super.getDesc() + \"+\" + drink.getDesc();\n    }\n}\n\npublic class Milk extends Decorator {\n\n    public Milk(Drink drink) {\n        super(drink);\n        setDesc(\"牛奶\");\n        setPrice(2.0f);\n    }\n}\n\npublic class Chocolate extends Decorator{\n\n    public Chocolate(Drink drink) {\n        super(drink);\n        setDesc(\"巧克力\");\n        setPrice(3.0f);\n    }\n}\n\n\npublic class Client {\n\n    public static void main(String[] args){\n        Drink order = new Espresso();\n        System.out.println(order.cost());\n        System.out.println(order.getDesc());\n        order = new Milk(order);\n        System.out.println(order.cost());\n        System.out.println(order.getDesc());\n    }\n}\n```\n![decorator](/images/common/decorator.png)\n解读：Decorator作为装饰者，通过组合的方式装饰Coffee，Decorator装饰者和Coffee被装饰者两者拥有共同的父类。\n#### 1.3.2 装饰器模式使用\nJDK中的IO结构\n\n### 1.4 组合模式(Composite Pattern)\n介绍：将对象组合成**树形结构**以表示\"部分-整体\"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n使用场景：\n 1. 算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 \n 2. 在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。\n\n #### 1.4.1示例\n```C#\n/**\n * 抽象类\n */\npublic abstract class OrganizationComponent {\n\n    private String name;\n    private String desc;\n\n    protected void add(OrganizationComponent organizationComponent){\n        throw new  UnsupportedOperationException();\n    }\n\n    protected void remove(OrganizationComponent organizationComponent){\n        throw new  UnsupportedOperationException();\n    }\n\n    public abstract void print();\n\n    public OrganizationComponent(String name, String desc) {\n        this.name = name;\n        this.desc = desc;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDesc() {\n        return desc;\n    }\n\n    public void setDesc(String desc) {\n        this.desc = desc;\n    }\n}\n\npublic class University extends OrganizationComponent{\n\n    // 聚合\n    List<OrganizationComponent> organizationComponents = new ArrayList<>();\n\n    public University(String name, String desc) {\n        super(name, desc);\n    }\n\n    @Override\n    protected void add(OrganizationComponent organizationComponent) {\n        organizationComponents.add(organizationComponent);\n    }\n\n    @Override\n    protected void remove(OrganizationComponent organizationComponent) {\n        organizationComponent.remove(organizationComponent);\n    }\n\n    @Override\n    public void print() {\n        System.out.println(this.getName());\n        for (OrganizationComponent organization : organizationComponents) {\n            organization.print();\n        }\n    }\n}\n\npublic class College extends OrganizationComponent{\n\n    // 聚合\n    List<OrganizationComponent> organizationComponents = new ArrayList<>();\n\n    public College(String name, String desc) {\n        super(name, desc);\n    }\n\n    @Override\n    protected void add(OrganizationComponent organizationComponent) {\n        organizationComponents.add(organizationComponent);\n    }\n\n    @Override\n    protected void remove(OrganizationComponent organizationComponent) {\n        organizationComponent.remove(organizationComponent);\n    }\n\n    @Override\n    public void print() {\n        System.out.println(this.getName());\n        for (OrganizationComponent organization : organizationComponents) {\n            organization.print();\n        }\n    }\n}\n\n/**\n * leaf叶子节点\n */\npublic class Department extends OrganizationComponent{\n\n\n    public Department(String name, String desc) {\n        super(name, desc);\n    }\n\n    @Override\n    public void print() {\n        System.out.println(this.getName());\n    }\n}\n\npublic class Client {\n\n    public static void main(String args[]){\n        OrganizationComponent university = new University(\"程序员大学\", \"万物皆明辨可惜\");\n        university.add(new College(\"计算机学院\", \"万物皆计算机\"));\n        university.add(new College(\"数学学院\", \"万物皆数学\"));\n        university.print();\n\n        System.out.println(\"----------------------\");\n        OrganizationComponent college = new College(\"物理学院\", \"万物皆物理\");\n        college.add(new Department(\"物理一班\", \"一班一班\"));\n        college.add(new Department(\"物理二班\", \"二班二班\"));\n        university.add(college);\n        university.print();\n\n    }\n}\n\n```\n![composite](/images/common/composite.png)\n解读：College和University通过聚合的方式组合起来，可以很方便的增加和删除，而叶子节点是最小的节点，不需要增加和删除。需要注意的是这里的College和University继承了同一个抽象类，需具有相同的部分。\n#### 1.4.2 组合模式使用\nJDK中的HashMap\n\n### 1.5 外观模式(Facade Pattern)\n介绍：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n使用场景：\n1. 为复杂的模块或子系统提供外界访问的模块。 \n2. 子系统相对独立。 \n3. 预防低水平人员带来的风险。\n#### 1.5.1示例\n```C#\npublic interface Shape {\n    void draw();\n}\n\npublic class Square implements Shape {\n\n    @Override\n    public void draw() {\n        System.out.println(\"Square::draw()\");\n    }\n}\n\npublic class Circle implements Shape {\n\n    @Override\n    public void draw() {\n        System.out.println(\"Circle::draw()\");\n    }\n}\n\npublic class Rectangle implements Shape {\n\n    @Override\n    public void draw() {\n        System.out.println(\"Rectangle::draw()\");\n    }\n}\n\n/**\n * 外观类\n */\npublic class ShapeMaker {\n    private Shape circle;\n    private Shape rectangle;\n    private Shape square;\n\n    public ShapeMaker() {\n        // 实例化属性，可以用单例模式实例化\n        circle = new Circle();\n        rectangle = new Rectangle();\n        square = new Square();\n    }\n\n    public void draw(){\n        circle.draw();\n        rectangle.draw();\n        square.draw();\n    }\n}\n\npublic class Client {\n    public static void main(String[] args) {\n        ShapeMaker shapeMaker = new ShapeMaker();\n        shapeMaker.draw();\n    }\n}\n```\n![facade](/images/common/facade.png)\n解读：ShapeMaker作为外观类，通过组合的形式，把内部的细节都封装了。使用者只需要通过外观类进行调用即可。\n\n#### 1.5.2 外观模式使用\nMybatis中的Configuration\n\n### 1.6 享元模式(Flyweight Pattern)\n介绍：也叫蝇量模式，运用共享技术有效地支持大量细粒度的对象。(注意划分**外部状态和内部状态**，否则可能会引起线程安全问题。这些类必须有一个工厂对象加以控制。)\n使用场景：\n1. JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 \n2. 数据库的数据池。\n#### 1.6.1示例\n```C#\npublic abstract class WebSite {\n    public abstract void used(User user);\n}\n\npublic class ConcreateWebSite extends WebSite {\n\n    private String type = \"\";\n\n    public ConcreateWebSite(String type){\n        this.type = type;\n    }\n\n    @Override\n    public void used(User user) {\n        System.out.println(\"user\" + user.getName() + \", type:\" + type);\n    }\n}\n\npublic class User {\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public User(String name) {\n        this.name = name;\n    }\n}\n\n**\n * 享元池\n */\npublic class WebSiteFactory {\n\n    private HashMap<String, ConcreateWebSite> pool = new HashMap<>();\n\n    /**\n     * 在享元池中取，如果没有则创建\n     * @param type\n     * @return\n     */\n    public WebSite getWebSiteByType(String type){\n        if (!pool.containsKey(type)){\n            pool.put(type, new ConcreateWebSite(type));\n        }\n        return pool.get(type);\n    }\n\n    public int getWebSitePoolSize(){\n        return pool.size();\n    }\n\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        WebSiteFactory webSiteFactory = new WebSiteFactory();\n        webSiteFactory.getWebSiteByType(\"news\");\n        System.out.println(webSiteFactory.getWebSitePoolSize());\n        webSiteFactory.getWebSiteByType(\"blog\");\n        System.out.println(webSiteFactory.getWebSitePoolSize());\n        webSiteFactory.getWebSiteByType(\"shop\");\n        System.out.println(webSiteFactory.getWebSitePoolSize());\n\n        WebSite news = webSiteFactory.getWebSiteByType(\"news\");\n        news.used(new User(\"A\"));\n        System.out.println(webSiteFactory.getWebSitePoolSize());\n    }\n}\n\n```\n![flyweight](/images/common/flyweight.png)\n解读：通过整理内部状态，设计享元池，进行共享，减少了对象的创建。\n\n#### 1.6.2 享元模式使用\nJava中的String常量池、Integer.valueOf()\n\n### 1.7 代理模式(Proxy Pattern)\n介绍：为其他对象提供一种代理以控制对这个对象的访问。代理模式有不同的形式，主要有三种：静态代理、动态代理(JDK代理、接口代理)、Cglib代理(可以在内存动态的创建对象，而不需要实习接口，属于动态代理)。\n使用场景：\n1. 远程代理。 \n2. 虚拟代理。 \n3. Copy-on-Write 代理。 \n4. 保护（Protect or Access）代理。\n5. Cache代理。 \n6. 防火墙（Firewall）代理。 \n7. 同步化（Synchronization）代理。 \n8. 智能引用（Smart Reference）代理。\n#### 1.7.1静态代理\n```C#\npublic interface TeacherDao {\n\n    void teach();\n}\n\npublic class TeacherDaoImpl implements TeacherDao {\n    @Override\n    public void teach() {\n        System.out.println(\"teaching\");\n    }\n}\n\n/**\n * 代理对象\n * 静态代理，需要实现目标接口，聚合目标对象\n */\npublic class TeachDaoProxy implements TeacherDao{\n\n    // 目标对象\n    private TeacherDao target;\n\n    public TeachDaoProxy(TeacherDao target){\n        this.target = target;\n    }\n\n    @Override\n    public void teach() {\n        System.out.println(\"proxy start\");\n        target.teach();\n        System.out.println(\"proxy end\");\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        TeachDaoProxy proxy = new TeachDaoProxy(new TeacherDaoImpl());\n        // 通过代理对象，调用被代理对象的方法\n        proxy.teach();\n    }\n}\n\n```\n![staticproxy](/images/common/staticproxy.png)\n解读：TeachDaoProxy代理通过实现目标接口，聚合目标对象，进行静态代理。最后通过代理对象，调用被代理对象的方法。\n\n#### 1.7.2 动态代理\n```C#\npublic interface TeacherDao {\n\n    void teach();\n}\n\npublic class TeacherDaoImpl implements TeacherDao {\n    @Override\n    public void teach() {\n        System.out.println(\"teaching\");\n    }\n}\n\n/**\n * 代理对象\n * 动态代理，利用JDK的newProxyInstance方法，动态的在内存中构建代理对象\n * java.lang.reflect.Proxy\\\n *\n * 根据传入的目标对象，利用反射机制，返回一个代理对象。然后通过代理对象，调用目标对象方法\n */\npublic class ProxyFactory {\n\n    // 目标对象\n    private Object target;\n\n    public ProxyFactory(Object target){\n        this.target = target;\n    }\n\n    public Object getProxyInstance(){\n        /**\n         * ClassLoader loader 指定当前目标对象使用的类加载器，获取加载器的方法固定\n         * Class<?>[] interfaces 目标对象实现的接口类型，使用方向方式确认类型\n         * InvocationHandler h 事情处理，执行目标对象的方法是，会触发事情处理器方法\n         */\n        ClassLoader loader = target.getClass().getClassLoader();\n        Class<?>[] interfaces = target.getClass().getInterfaces();\n        InvocationHandler h = (Object proxy, Method method, Object[] args) -> {\n                System.out.println(\"反射机制调用目标对象的方法\");\n                Object invoke = method.invoke(target, args);\n                System.out.println(\"JDK代理提交\");\n                return invoke;\n        };\n        return Proxy.newProxyInstance(loader, interfaces, h);\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        TeacherDao target = new TeacherDaoImpl();\n        TeacherDao proxy = (TeacherDao)new ProxyFactory(target).getProxyInstance();\n        // 通过代理对象，调用目标对象的方法\n        proxy.teach();\n    }\n}\n```\n![dynamicproxy](/images/common/dynamicproxy.png)\n解读：ProxyFactory动态代理，利用JDK的newProxyInstance方法，动态的在内存中构建代理对象。最后通过代理对象，调用被代理对象的方法。\n\n#### 1.7.3 Cglib代理\nCglib是一个强大的高性能的代码生成包，被许多框架使用，例如：Spring AOP。Cglib包的底层是通过字节码处理框架ASM来转换字节码并生产新的类。\n **cglib是针对类来实现代理的，原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理**\n\n```C#\npublic class TeacherDao {\n    public void teach() {\n        System.out.println(\"teaching\");\n    }\n}\n\n/**\n * MethodInterceptor 方法拦截器\n * cglib是针对类来实现代理的，原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理\n */\npublic class ProxyFactory implements MethodInterceptor {\n\n    Object target;\n\n    public ProxyFactory(Object target){\n        this.target = target;\n    }\n\n    /**\n     * 返回target目标对象的代理对象\n     * 调用代理对象的时候，会触发调用intercept()\n     * @return\n     */\n    public Object getProxyInstance(){\n        // 1.cglib增强类\n        Enhancer enhancer = new Enhancer();\n        // 2.设置父类\n        enhancer.setSuperclass(target.getClass());\n        // 3.设置回调函数\n        enhancer.setCallback(this);\n        // 4.创建子类对象，即代理对象\n        return enhancer.create();\n    }\n\n    /**\n     * 重写intercept方法，实现对被代理对象(目标对象)方法调用\n     * @param o\n     * @param method\n     * @param objects 方法参数\n     * @param methodProxy\n     * @return\n     * @throws Throwable\n     */\n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        System.out.println(\"cglib start\");\n        Object invoke = method.invoke(target, objects);\n        System.out.println(\"cglib end\");\n        return invoke;\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        TeacherDao target = new TeacherDao();\n        TeacherDao proxy = (TeacherDao)new ProxyFactory(target).getProxyInstance();\n        // 通过代理对象，调用目标对象的方法\n        proxy.teach();\n    }\n}\n\n```\n![cglibproxy](/images/common/cglibproxy.png)\n解读：ProxyFactory利用Cglib代理，当通过代理对象，调用目标对象时候，会触发MethodInterceptor方法拦截器，通过重写intercept方法，实现对被代理对象(目标对象)方法调用。\n\n#### 1.7.4 对比\nJDK代理：目标对象实现接口\nCglib代理：目标对象不需要实现接口\n\n#### 1.7.5 代理模式使用\n\n","categories":["从零开始设计模式"]},{"title":"从零开始设计模式第2章-创建型模式(五种)","url":"/2020/01/06/从零开始设计模式第2章/","content":"## 1.创建型模式(5种)\n* 单例模式(Singleton Pattern)\n* 工厂模式(Factory Pattern)\n* 抽象工厂模式(Abstract Factory Pattern)\n* 原型模式(Prototype Pattern)\n* 建造者模式(Builder Pattern)\n\n### 1.1 单例模式(Singleton Pattern)\n介绍：保证一个类只有一个对象实例。\n使用场景：\n1. 需频繁的创建和销毁类(重量级对象)，但又经常需要用到的。如：工具类、数据源、session工厂等。\n2. 要求生产唯一序列号。\n3. WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。\n4. 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。\n\n#### 1.1.1饿汉式(静态常量)\n```C#\npublic class SingletonDemo1 {\n\n    public static void main(String args[]){\n        Singleton1 instance1 = Singleton1.getInstance();\n        Singleton1 instance2 = Singleton1.getInstance();\n        System.out.println(instance1 == instance2);\n    }\n}\n\n// 饿汉式(静态常量)\nclass Singleton1{\n\n    // 1.私有化构造方法\n    private Singleton1(){}\n\n    // 2.静态变量\n    private static final Singleton1 instance = new Singleton1();\n\n    // 3.获取\n    public static Singleton1 getInstance(){\n        return instance;\n    }\n\n}\n```\n优点：写法简单，线程安全\n缺点：没有懒加载(lazy loading)，可能造成内存浪费\n\n#### 1.1.2饿汉式(静态块)\n```C#\npublic class SingletonDemo2 {\n\n    public static void main(String args[]){\n        Singleton2 instance1 = Singleton2.getInstance();\n        Singleton2 instance2 = Singleton2.getInstance();\n        System.out.println(instance1 == instance2);\n    }\n}\n\n// 饿汉式(静态块)\nclass Singleton2{\n\n    // 1.私有化构造方法\n    private Singleton2(){}\n\n    private static Singleton2 instance;\n\n    // 2.静态块\n    static {\n        instance = new Singleton2();\n    }\n\n    // 3.获取\n    public static Singleton2 getInstance(){\n        return instance;\n    }\n\n}\n```\n优点：写法简单，线程安全\n缺点：没有懒加载(lazy loading)，可能造成内存浪费\n\n#### 1.1.3懒汉式(同步方法)\n```C#\npublic class SingletonDemo3 {\n\n    public static void main(String args[]){\n        Singleton3 instance1 = Singleton3.getInstance();\n        Singleton3 instance3 = Singleton3.getInstance();\n        System.out.println(instance1 == instance3);\n    }\n}\n\n// 懒汉式(同步方法)\nclass Singleton3{\n\n    // 1.私有化构造方法\n    private Singleton3(){}\n\n    private static Singleton3 instance;\n\n    // 2.获取\n    public static synchronized Singleton3 getInstance(){\n        if (instance == null) {\n                instance = new Singleton3();\n        }\n        return instance;\n    }\n\n}\n```\n优点：线程安全，延迟加载\n缺点：效率较低\n\n#### 1.1.4双重检查(同步代码块)\n```C#\npublic class SingletonDemo4 {\n\n    public static void main(String args[]){\n        Singleton4 instance1 = Singleton4.getInstance();\n        Singleton4 instance4 = Singleton4.getInstance();\n        System.out.println(instance1 == instance4);\n    }\n}\n\n// 双重检查(同步代码块)\nclass Singleton4{\n\n    // 1.私有化构造方法\n    private Singleton4(){}\n\n    // volatile保证内存可见性，防止指令重排\n    private static volatile Singleton4 instance;\n\n    // 2.获取\n    public static Singleton4 getInstance(){\n        if (instance == null) {\n            synchronized (Singleton4.class){\n                if (instance == null) {\n                    instance = new Singleton4();\n                }\n            }\n        }\n        return instance;\n    }\n\n}\n```\n优点：线程安全，延迟加载，效率较高(**推荐使用**)\n缺点：\n\n#### 1.1.5静态内部类\n```C#\npublic class SingletonDemo5 {\n\n    public static void main(String args[]){\n        Singleton5 instance1 = Singleton5.getInstance();\n        Singleton5 instance5 = Singleton5.getInstance();\n        System.out.println(instance1 == instance5);\n    }\n}\n\n// 静态内部类\nclass Singleton5{\n\n    // 1.私有化构造方法\n    private Singleton5(){}\n\n    // 2.静态内部类(外部类被加载时候，静态内部类不会被加载)\n    private static class SingletonInstance{\n        private static final Singleton5 instance = new Singleton5();\n    }\n\n    // 3.获取\n    public static Singleton5 getInstance(){\n        return SingletonInstance.instance;\n    }\n\n}\n```\n优点：线程安全，延迟加载，效率较高(**推荐使用**)\n缺点：\n\n#### 1.1.6枚举\n```C#\npublic class SingletonDemo6 {\n\n    public static void main(String args[]){\n        Singleton6 instance1 = Singleton6.INSTANCE;\n        Singleton6 instance6 = Singleton6.INSTANCE;\n        System.out.println(instance1 == instance6);\n    }\n}\n\n// 枚举\nenum Singleton6{\n\n    INSTANCE\n}\n```\n优点：线程安全，防止反序列化重新创建新对象(**推荐使用**)\n缺点：\n\n#### 1.1.7单例模式应用\njava.lang.Runtime\n\n---\n\n单例模式很好理解，接下来的设计模式则比较抽象，需要好好进行思考。\n\n---\n\n### 1.2 工厂模式(Factory Pattern)\n介绍：定义一共用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。\n使用场景： \n1. 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 \n2. 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 \n3. 设计一个连接服务器的框架，需要三个协议，\"POP3\"、\"IMAP\"、\"HTTP\"，可以把这三个作为产品类，共同实现一个接口。\n\n#### 1.2.1 分类\n* 简单工厂模式，也就静态工厂模式\n* 多个工厂模式\n\n#### 1.2.2 示例\n```C#\n/**\n * 产品\n */\npublic abstract class Product {\n\n    public void method1(){}\n\n    // 业务逻辑处理\n    public abstract void method2();\n}\n\npublic class ConcreateProduct1 extends Product {\n\n    @Override\n    public void method2() {\n        // 业务逻辑处理\n    }\n}\n\npublic class ConcreateProduct2 extends Product {\n\n    @Override\n    public void method2() {\n        // 业务逻辑处理\n    }\n}\n\n/**\n * 创建者\n */\npublic abstract class Creator {\n\n    public abstract <T extends Product> T createProduct(Class<T> clazz);\n}\n\npublic class ConcreateCreator extends Creator {\n\n    @Override\n    public <T extends Product> T createProduct(Class<T> clazz) {\n        Product product = null;\n        try {\n            product = (Product)clazz.forName(clazz.getName()).newInstance();\n        }catch (ClassNotFoundException e){\n        }catch (IllegalAccessException e){\n        }catch (InstantiationException e){\n        }\n        return (T)product;\n    }\n}\n\npublic class Client {\n\n    public static void main(String args[]){\n        Creator creator = new ConcreateCreator();\n        Product product1= creator.createProduct(ConcreateProduct1.class);\n        Product product2= creator.createProduct(ConcreateProduct2.class);\n    }\n}\n```\n![factory](/images/common/factory.png)\n解读：Creator通过传入不同的产品类型来创建不同的产品。\n\n---\n\n工厂模式在项目中使用非常频繁，需好好思考如何运用。\n\n---\n\n### 1.3 抽象工厂模式(Abstract Factory Pattern)\n介绍：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类\n使用场景：\n1. QQ 换皮肤，一整套一起换。 \n2. 生成不同操作系统的程序。\n\n#### 1.3.1 示例\n\n```C#\n/**\n * 产品A\n */\npublic abstract class AbstractProductA {\n\n    public void method1(){}\n\n    // 业务逻辑处理\n    public abstract void method2();\n}\n\n/**\n * 产品B\n */\npublic abstract class AbstractProductB {\n\n    public void method1(){}\n\n    // 业务逻辑处理\n    public abstract void method2();\n}\n\npublic class ProductA1 extends AbstractProductA {\n\n    @Override\n    public void method2() {\n        // 业务逻辑处理\n    }\n}\n\npublic class ProductA2 extends AbstractProductA {\n\n    @Override\n    public void method2() {\n        // 业务逻辑处理\n    }\n}\n\npublic class ProductB1 extends AbstractProductB {\n\n    @Override\n    public void method2() {\n        // 业务逻辑处理\n    }\n}\n\npublic class ProductB2 extends AbstractProductB {\n\n    @Override\n    public void method2() {\n        // 业务逻辑处理\n    }\n}\n\n/**\n * 创建者\n */\npublic abstract class AbstractFactryCreator {\n\n    public abstract AbstractProductA createProductA();\n\n    public abstract AbstractProductB createProductB();\n}\n\npublic class FactryCreator1 extends AbstractFactryCreator {\n\n    @Override\n    public AbstractProductA createProductA() {\n        return new ProductA1();\n    }\n\n    @Override\n    public AbstractProductB createProductB() {\n        return new ProductB1();\n    }\n}\n\npublic class FactryCreator2 extends AbstractFactryCreator {\n\n    @Override\n    public AbstractProductA createProductA() {\n        return new ProductA2();\n    }\n\n    @Override\n    public AbstractProductB createProductB() {\n        return new ProductB2();\n    }\n}\n\npublic class Client {\n    public static void main(String args[]){\n        AbstractFactryCreator creator1 = new FactryCreator1();\n        AbstractProductA productA1 = creator1.createProductA();\n        AbstractProductB productB1 = creator1.createProductB();\n\n        AbstractFactryCreator creator2 = new FactryCreator2();\n        AbstractProductA productA2 = creator2.createProductA();\n        AbstractProductB productB2 = creator2.createProductB();\n    }\n}\n\n```\n![factory](/images/common/abstractfactory.png)\n解读：与工厂模式不同的是，抽象工厂模式把工厂抽象起来，通过不同的AbstractFactryCreator工厂创建不同的产品。\n\n---\n\n抽象工厂模式和工厂模式有点像，需要好好理解和区分。下面来看看原型模式\n\n---\n\n### 1.4 原型模式(Prototype Pattern)\n介绍：用于创建重复的对象，同时又能保证性能。\n使用场景：\n1. 资源优化场景。类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 \n2. 性能和安全要求的场景。通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 \n3. 一个对象多个修改者的场景。一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 \n4. 在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。\n\n#### 1.4.1 示例\n```C#\n/**\n * Mail\n * Cloneable用于标记可拷贝，无实现方法\n */\npublic class Mail implements Cloneable{\n    /**\n     * 默认是浅拷贝\n     * @return\n     */\n    @Override\n    protected Object clone(){\n        Mail mail = null;\n        try{\n            mail = (Mail)super.clone();\n        }catch (CloneNotSupportedException e){\n\n        }\n        return mail;\n    }\n}\n\npublic class Client {\n    public static void main(String args[]){\n       Mail template = new Mail();\n       Mail template0 =  (Mail)template.clone();\n       Mail template1 =  (Mail)template.clone();\n       Mail template2 =  (Mail)template.clone();\n       Mail template3 =  (Mail)template.clone();\n       Mail template4 =  (Mail)template.clone();\n       Mail template5 =  (Mail)template.clone();\n    }\n}\n```\n解读：通过实现Cloneable接口，并重写Object基类的clone()方法，实现了类的复制。\n原型模式从堆内存二进制流进行拷贝，避免了构造函数的执行，大大提高了效率。\n\n#### 1.4.2 实现深拷贝的方式\n1. 重写clone()方法\n2. 通过序列化和反序列化方式\n\n---\n\n使用原型模式一定要注意浅拷贝和深拷贝问题\n\n---\n### 1.5 建造者模式(Builder Pattern)\n介绍：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示(顺序)。\n使用场景：\n1. 方法相同，但是**组合顺序不同**\n\n#### 1.5.1 示例\n```C#\n/**\n * 产品\n */\npublic abstract class Computer {\n\n    protected String board;\n    protected String display;\n    protected String mOs;\n\n    protected Computer(){\n    }\n\n\n    public void setBoard(String board){\n        this.board=board;\n    }\n\n    public void setDisplay(String display) {\n        this.display = display;\n    }\n\n    public abstract void setOs() ;\n}\n\npublic class MacBook extends Computer{\n    @Override\n    public void setOs() {\n        System.out.println(\"Mac OS X\");\n    }\n}\n\npublic abstract class Builder {\n\n    abstract void buildBoard(String board);\n\n    abstract void buildDisplay(String display);\n\n    abstract void buildOs();\n    \n    abstract Computer build();\n}\n\npublic class MacBookBuilder extends Builder {\n\n    private Computer macBook = new MacBook();\n\n    @Override\n    void buildBoard(String board) {\n        macBook.setBoard(board);\n    }\n\n    @Override\n    void buildDisplay(String display) {\n        macBook.setDisplay(display);\n    }\n\n    @Override\n    void buildOs() {\n        macBook.setOs();\n    }\n\n    @Override\n    Computer build() {\n        return macBook;\n    }\n}\n\n/**\n * 指挥者\n */\npublic class Director {\n\n    private Builder builder = null;\n\n    public Director(Builder builder) {\n        this.builder = builder;\n    }\n\n    public void construct(String board,String display){\n        builder.buildDisplay(display);\n        builder.buildBoard(board);\n        builder.buildOs();\n    }\n}\n\npublic class Client {\n\n    public static void main(String args[]) {\n        Builder builder = new MacBookBuilder() ;\n\n        Director director = new Director(builder);\n        director.construct(\"英特尔主板\", \"Retina显示器\");\n\n        Computer macBook = builder.build();\n    }\n}\n\n```\n![factory](/images/common/builder.png)\n解读：产品Computer并不是直接通过builder就创建完毕，可以看到builder创建的产品是不完整的。在最后由Director指挥完成最后的一个设置才是真正的产品。\n\n#### 1.5.2 建造者模式使用\nStringBuilder","categories":["从零开始设计模式"]},{"title":"从零开始设计模式第1章-UML图和设计模式七大原则","url":"/2020/01/02/从零开始设计模式第1章/","content":"前面简单介绍了设计模式中七大设计原则和23种设计模式。那么这一节，让我们用示例好好了解一下七大设计原则。你将会看到坏的示例和好的示例。\n\n在此之前，需要简单学习一下UML。\n\n## 1.UML\nUML：Unified Modeling Language(统一建模语言)，是一种用于描述软件系统分析和设计的语言工具。能用图描述的地方就不要用文字去描述。\n\n### 1.1 UML图分类\n* 用例图\n* 静态结构图：类图、对象图、包图、组件图、部署图\n* 动态行为图：交互图(时序图和协作图)、状态图、活动图\n\n### 1.2 类图\n在学习设计模式中，我们核心使用到的是类图，类图是用于描述类与类之间的关系。下面是简单的介绍。\n\n类的基本组成：类名、成员变量、成员方法\n#### 1.2.1类的可访问性\n![类的可访问性](/images/common/类的可访问性.png)\n\n| **Character** | **Icon for field**                                       | **Icon for method**                                       | **Visibility**  |\n| ------------- | -------------------------------------------------------- | --------------------------------------------------------- | --------------- |\n| `-`           | ![img](https://s.plantuml.com/private-field.png)         | ![img](https://s.plantuml.com/private-method.png)         | private         |\n| `#`           | ![img](https://s.plantuml.com/protected-field.png)       | ![img](https://s.plantuml.com/protected-method.png)       | protected       |\n| `~`           | ![img](https://s.plantuml.com/package-private-field.png) | ![img](https://s.plantuml.com/package-private-method.png) | package private |\n| `+`           | ![img](https://s.plantuml.com/public-field.png)          | ![img](https://s.plantuml.com/public-method.png)          | public          |\n\n\n\n#### 1.2.2类之间关系：\n* 依赖(Dependency)\n<font color=\"#e96900\">\n只要类中用到了另一个类，这两个类就是依赖关系(直接朋友+陌生朋友)\n</font>\n\n![Dependency](/images/common/依赖.png)\n\n* 关联(Association)\n<font color=\"#e96900\">\n关联关系指的是类与类之间的联接，即我们平常说的一对一，一对多，多对多。\n关联具有导航性，即双向关系或单向关系。\n</font>\n\n![Association](/images/common/关联1.png)\n![Association](/images/common/关联2.png)\n\n* 继承(Generalization)\n![Generalization](/images/common/继承.png)\n\n* 实现(Realization)\n![Realization](/images/common/实现.png)\n\n* 聚合(Aggregation)\n<font color=\"#e96900\">\n<b>整体和部分可以分开</b>，例如：电脑和键盘，鼠标。电脑没用了鼠标和键盘但是也可以用。这里整体指的是电脑，部分指的是鼠标、键盘。\n</font>\n\n![Aggregation](/images/common/聚合.png)\n\n* 组合/复合(Composite)\n<font color=\"#e96900\">\n<b>整体和部分不可以分开</b>，例如：人和头。人不可以没有头。这里整体指的是人，部分指的是头。\n</font>\n\n![Composite](/images/common/组合.png)\n\n### 1.3工具\n插件工具[PlantUML](https://plantuml.com/zh/)\n\n## 2.七大设计原则\n\n### 2.1单一职责原则(Single Responsibility Principle)\n一个类职责不能太多太大，应降低类的复杂度，一个类只负责一项职责。\n<font color=\"#e96900\">就像我们的电子产品分类太大了，需要继续细分。</font>\n单一职责，并不只是对于类而言。对于类、接口、方法都应该尽量保证单一职责。为什么说尽量？因为职责是很难去划分清楚的，这里面最难的地方就在于如何划分清职责。\n\n单一职责的核心思想是：不要存在多于一个原因导致类的变更。\n> There should never be more than one reason for a class to change.\n\n**bad**\n```C#\npublic class Person {\n\n    void single();\n\n    void jump();\n\n    void rap();\n\n    void playBasketball();\n}\n```\n**good**\n```C#\nclass Student {\n\n    void single();\n\n    void jump();\n}\n\nclass Teacher {\n\n    void playBasketball();\n\n}\n```\n说明：bad示例中，我们把单一职责看作一个人想学太多了(教练：你什么都想学)，什么都想学，只会什么都学不好。\n\n\n### 2.2接口隔离原则(Interface Segregation Principle)\n一个接口功能不能太强太多。\n<font color=\"#e96900\">\n这个跟单一职责有些像，只不过一个是类，一个是接口的方法不能太多。\n对于接口来说，如果功能过强，当实现接口的时候，不必要的接口也必须实现，这其实太强制了。\n</font>\n接口隔离原则的核心思想是：客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口。\n**bad**\n```C#\npublic interface Person {\n\n    void single();\n\n    void jump();\n\n    void rap();\n\n    void playBasketball();\n}\n\n```\n**good**\n```C#\ninterface Student {\n\n    void single();\n\n    void jump();\n}\n\ninterface Teacher {\n\n    void playBasketball();\n\n}\n```\n说明：bad示例中，划分不明细，一个接口太强了，并不是人人都喜欢唱跳rap、篮球🏀。\n\n### 2.3依赖倒置原则(Dependence Inversion Principle)\n面向接口编程，利用多态的特性。\n<font color=\"#e96900\">\n这是告诉我们，在变量类型声明、方法传递参数类型中应尽量使用接口或抽象类，而不是具体的类。\n</font>\n依赖传递的三种方式：构造方法、setter()方法、声明依赖对象(成员变量)\n**bad**\n```C#\nclass Student{\n\n    public void single(){\n    }\n}\n\nclass Teacher{\n\n    public void single(){\n    }\n}\n\nclass Demo{\n    void single1(Student arg){\n        arg.single();\n    }\n    void single2(Teacher arg){\n        arg.single();\n    }\n}\n```\n**good**\n```C#\ninterface Person {\n\n    void single();\n}\n\nclass Student implements Person{\n\n    public void single(){\n    }\n}\n\nclass Teacher implements Person{\n\n    public void single(){\n    }\n}\n\nclass Demo{\n    void single(Person arg){\n        arg.single();\n    }\n}\n```\n说明：bad示例中，在Demo类中每让一个人single()，就要增加新single方法。方法传递的参数是具体的类，很不方便。在good中我们改进了一下，接口的形式作为形参，这样每次Demo类就不用改了。**(在变量类型声明、方法传递参数类型中应尽量使用接口或抽象类)**\n\n### 2.4里氏替换原则(Liskov Substitution Principle)\n如果子类不能完整的实现父类的方法，应断开父子继承的关系，通过聚合、组合、依赖来解决。\n<font color=\"#e96900\">\n继承的缺点：\n1. 侵入性\n2. 降低代码灵活性\n3. 增强耦合性\n</font>\n\n里氏替换原则的核心思想是：所有引用父类对象的地方，就能够使用其子类的对象。\n\n**bad**\n```C#\nclass Father {\n\n    long money(){\n        return 10000000000L;\n    }\n}\n\nclass Son extends Father{\n\n    @Override\n    long money(){\n        return 0L;\n    }\n}\n```\n**good**\n```C#\nclass Father {\n\n    long money(){\n        return 10000000000L;\n    }\n}\n\nclass Son extends Father{\n\n    long sonMoney(){\n        return 1L + money();\n    }\n}\n```\n说明：bad示例中，父亲本来有很多钱，孩子继承后父亲的东西后，没有要父亲的钱。good中我们进行了改进，孩子利用继承父亲的钱，赚到了更多的钱。\n\n### 2.5开闭原则(Open Close Principle)\n> 编程中遵守其它原则，以及使用设计模式的目的就是遵守**开闭原则**。\n\n模块和函数应对扩展开放(**提供者**)，对修改关闭(**使用者**)。\n`用抽象构建框架，用实现扩展细节。抽象约束`\n**bad**\n```C#\nclass Provider{\n\n    void show(String grade) {\n        if (\"1\".equals(grade)) {\n            print(\"A\");\n        }else if (\"2\".equals(grade)) {\n            print(\"B\");\n        } else if (\"3\".equals(grade)) {\n            print(\"C\");\n        } else{\n            print(\"D\");\n        }\n    }\n\n    void print(String s) {\n        System.out.println(s);\n    }\n}\n\nclass User{\n    public static void main(String args[]) {\n        Provider demo = new Provider();\n        demo.show(\"1\");\n        demo.show(\"2\");\n    }\n}\n```\n**good**\n```C#\ninterface Provider{\n    void print();\n}\n\nclass A implements Provider{\n    public void print(){\n        System.out.println(\"A\");\n    }\n}\n\nclass B implements Provider{\n    public void print(){\n        System.out.println(\"B\");\n    }\n}\n\nclass C implements Provider{\n    public void print(){\n        System.out.println(\"C\");\n    }\n}\n\nclass D implements Provider{\n    public void print(){\n        System.out.println(\"D\");\n    }\n}\n\nclass User{\n    public static void main(String args[]){\n        User demo = new User();\n        demo.show(new A());\n        demo.show(new B());\n    }\n\n    void show(Provider grade){\n        grade.print();\n    }\n}\n```\n说明：bad示例中，我们要打印不同内容，是通过if-else去判断，这样每增加内容就要写一次if-else。**如果有一天grade不用1234去判断了，改用abcd去判断了，那么我们就要改很多代码，同时User使用方也需要进行修改。**\n开闭原则，主张的是提供方改动而不需要使用方改动。在good里，我们进行了改进，使用接口作为形参，这样需要调什么内容就传具体的类过来。新增内容，就新增一个实现类，使用方如果想要就用，不想用也不会有影响。\n\n### 2.6迪米特法则(Demeter Principle)(最少知道原则)\n> 一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，<font color=\"#e96900\">都应该将逻辑封装在方法的内部，通过public方法提供给外部</font>。这样当被依赖的类变化时，才能最小的影响该类。\n\n最少知道原则表达的是：只与直接朋友通信。\n直接朋友：有耦合关系的类则称为朋友关系。耦合分为依赖、关联、聚合、组合等。例如一个类中**成员变量、方法参数、或者方法返回值中**用到了另一个类，则称这个两个类为直接朋友关系。\n陌生朋友：不是直接朋友，也就是陌生朋友。例如一个类中的**局部变量、临时变量**用到了另一个类。\n<font color=\"#e96900\">\n迪米特法则希望我们能够尽量不要在类中的局部变量和临时变量用到另一个陌生的类，即只与直接朋友通信。这样可以降低类与类直接的**耦合性**。\n</font>\n\n**bad**\n```C#\nclass A{\n    public void print(){\n        System.out.println(\"A\");\n    }\n}\n\nclass B{\n\n    void print1(){\n        // 局部变量中用到了类A\n        A a = new A();\n        a.print();\n    }\n    \n}\n```\n\n**good**\n```C#\nclass A{\n    public void print(){\n        System.out.println(\"A\");\n    }\n}\n\nclass B{\n\n    // 直接朋友，成员变量用到了类A\n    private A a;\n    // 直接朋友，方法参数用到了类A\n    void print1(A a){\n        a.print();\n    }\n    // 直接朋友，返回值用到了类A\n    A print2(){\n        return new A();\n    }\n}\n```\n说明：bad示例中，在局部变量中用到了A类，这样耦合性太强了。\n\n### 2.7合成复用原则(Composite/Aggregate Reuse Principle)\n`尽量首先使用组合/聚合的方式，而不是使用继承。`\n\n**bad**\n```C#\nclass A{\n    public void print(){\n        System.out.println(\"A\");\n    }\n\n    public void work(){\n        System.out.println(\"work\");\n    }\n}\n\nclass B extends A{\n    \n}\n```\n\n**good**\n```C#\nclass A{\n    public void print(){\n        System.out.println(\"A\");\n    }\n\n    public void work(){\n        System.out.println(\"work\");\n    }\n}\n\nclass B{\n\n    // 成员变量用到了类A\n    private A a;\n    public B(A a){\n        this.a = a;\n    }\n\n    // or\n    private A a1 = new A();\n\n    // 方法参数用到了类A\n    void print1(A a){\n        a.print();\n    }\n    // 返回值用到了类A\n    A print2(){\n        return new A();\n    }\n}\n```\n说明：bad示例中，类B直接继承了类A，但是类B并不需要类A中的work()方法，这样耦合性太强了。good中改成了聚合、组合的方法，更灵活。\n\n### 2.8总结\n* 单一职责原则和接口隔离原则相似，讲究对类或接口进行细化。\n* 里氏替换原则、迪米特法则、合成复用原则相似，讲究应尽量使用组合、聚合的方式，而不是继承的方式。\n* 依赖倒置原则，讲究的面向接口和抽象编程。在变量类型声明、方法传递参数类型中应尽量使用接口或抽象类，而不是具体的类。\n* 开闭原则，是七大原则的核心。讲究对扩展开放(**提供者**)，对修改关闭(**使用者**)。\n","categories":["从零开始设计模式"]},{"title":"从零开始设计模式第0章-认识设计模式","url":"/2020/01/01/从零开始设计模式第0章/","content":"## 1.有趣的故事\n不知道大家有没有这么一个习惯，平时的话可能不会定期去整理东西，但是一旦觉得很乱的时候😩，就会忍不住去整理。这个时候问题来了，东西该从哪里开始整理呢？🤔*this's a question.*\n\n这个时候，你可能会先大概看一下有这些东西🤨，然后进行分类，把对应的东西放到对应的分类里，不知道怎么分的东西就放到一个单独的分类里。最后你花了很长的时间，终于把这些搞定了，你看着这整齐的一切，强迫症一脸满足😀😀😀。\n\n那么问题又来了，我们为什么不一开始就这样做呢。如果一开始我们就按照这样去分类，制定相应的规则，后面就不用又花时间去整理一遍了。\n\n我有一个朋友**小A**。他对自己的东西进行了分类。比如电子产品放这边，书籍放这边，生活用品放这边。OK，很长的一段时间，**小A**的东西都不需要继续整理了，而且每一样东西在哪里，他都可以按照分类轻松的去找到。可是突然有一天，他感觉电子产品这边东西放不下了，因为他买了太多电子产品了。那这个时候又要怎么办呢？\n\n**小A**细想了一下，于是想到了一个好办法😉，他决定把电子产品继续划分，比如电子产品又分为手机相关用品、电脑相关用品。很长一段时间，他都不需要继续整理，他看着这整齐的一切，强迫症一脸满足😀😀😀。\n\n## 2.认识设计模式\n上面是我们生活中的例子，而这个对于我们程序设计又有关系呢。我们在生活中会制定一些规则或规范，去解决(或避免)一些问题。同样，在我们程序设计中，也有自己的一套规范，当然这套规范并不是绝对的，只是经过了时间的整理，最后慢慢形成了这么一个大家较为认可的东西，这套规范就是**设计模式**。这个定义是我自己瞎说的，下面是正规的解释。\n\n> 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。\n\n### 2.1为什么学习设计模式？\n在之前我们知道如果等东西乱了再去整理其实很浪费时间的，所以一开始就做好，可以帮助我们很好的节约时间。学习设计模式，可以帮助我们避免或解决一些问题，让我们的程序更具有**鲁棒性**。\n\n后面我将会从零开始做游戏，自己设计一个好玩的游戏。那当一个游戏内容很多的时候，就会像上面整理东西一样头疼，所以我们先学习好设计模式，再来看看游戏如何设计。\n\n那么接下来，就和我一起来了解设计模式吧。\n\n### 2.2学习准备\n在学习之前，你需具备面向对象编程的思想，因为学习过程中会遇到很多专业名词。另外你还需了解UML。\n\n## 3.学习内容\n* 设计模式七大原则\n* 23种设计模式\n\n光听设计模式这个词，其实我们很难明白这个东西是什么，即使上面介绍了说这个一种规范，是前人的总结。但是这毕竟是概念的东西，很模糊，很朦胧，那么有没有具体的东西呢？这个设计模式又要如何使用才能去解决(或避免)一些问题呢？\n\n学习设计模式，主要分为两点，第一是了解其原则，遵守设计模式制定的一些规范；第二是学习一些`设计思想`，这些设计思想就是用于解决特定的问题。\n专业术语上我们把这两点称之为：设计模式七大原则、23种设计模式。下面的内容可以先简单了解。\n\n\n### 3.1设计模式七大原则\n\n1. 单一职责原则(Single Responsibility Principle)\n2. 接口隔离原则(Interface Segregation Principle)\n3. 依赖倒置原则(Dependence Inversion Principle)\n4. 里氏替换原则(Liskov Substitution Principle)\n5. 开闭原则(Open Close Principle)\n6. 迪米特法则(Demeter Principle)(最少知道原则)\n7. 合成复用原则(Composite/Aggregate Reuse Principle)\n\n### 3.2二十三种设计模式\n目前，学习设计模式大部分都是参考**Design Patterns - Elements of Reusable Object-Oriented Software**这本书中的提到的23种设计模式，该书籍是由GOF在 1994 年合著出版。\n\n**GOF**：Gang Of Four，江湖人称四人帮。指的是Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides四人。\n\n### 3.3设计模式分类\n设计模式一共有23种，分为三种类型\n1. 创建型模式(5种)：\n* 抽象工厂模式(Abstract Factory Pattern)\n* 单例模式(Singleton Pattern)\n* 原型模式(Prototype Pattern)\n* 建造者模式(Builder Pattern)\n* 工厂模式(Factory Pattern)\n\n2.结构型模式(7种)：\n* 适配器模式(Adapter Pattern)\n* 桥接模式(Bridge Pattern)\n* 装饰器模式(Decorator Pattern)\n* 组合模式(Composite Pattern)\n* 外观模式(Facade Pattern)\n* 享元模式(Flyweight Pattern)\n* 代理模式(Proxy Pattern)\n\n3.行为型模式(11种)：\n* 模板模式(Template Pattern)\n* 命令模式(Command Pattern)\n* 访问者模式(Visitor Pattern)\n* 迭代器模式(Iterator Pattern)\n* 观察者模式(Observer Pattern)\n* 中介者模式(Mediator Pattern)\n* 备忘录模式(Memento Pattern)\n* 解释器模式(Interpreter Pattern)\n* 状态模式(State Pattern)\n* 策略模式(Strategy Pattern)\n* 职责链模式(Chain of Responsibility Pattern)\n","categories":["从零开始设计模式"]},{"title":"从零开始制作游戏-第零章","url":"/2019/12/27/从零开始制作游戏-第0章/","content":"<Excerpt in index | 首页摘要>\n\n从零开始制作游戏\n\n<!-- more -->\n<The rest of contents | 余下全文>","categories":["从零开始制作游戏"]},{"title":"Maven基础知识","url":"/2019/09/14/10/","content":"<Excerpt in index | 首页摘要>\n\nMaven的简单使用\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### Maven生命周期\n\n![maven生命周期](https://www.runoob.com/wp-content/uploads/2018/09/7642256-c967b2c1faeba9ce.png)\n\n| 阶段          | 处理     | 描述                                                     |\n| :------------ | :------- | :------------------------------------------------------- |\n| 验证 validate | 验证项目 | 验证项目是否正确且所有必须信息是可用的                   |\n| 编译 compile  | 执行编译 | 源代码编译在此阶段完成                                   |\n| 测试 Test     | 测试     | 使用适当的单元测试框架（例如JUnit）运行测试。            |\n| 包装 package  | 打包     | 创建JAR/WAR包如在 pom.xml 中定义提及的包                 |\n| 检查 verify   | 检查     | 对集成测试的结果进行检查，以保证质量达标                 |\n| 安装 install  | 安装     | 安装打包的项目到本地仓库，以供其他项目使用               |\n| 部署 deploy   | 部署     | 拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程 |\n\n\n### GAV\n\n初次看到这个简称的时候还以为我看错了，确定不是Gay？\n\n其实GAV指的是groupId、artifactId、version\n\ngroupId：公司或者组织的唯一标志\n\nartifactId：项目的唯一ID，项目的模块\n\nversion：版本号\n\n```xml\n<parent>\n    <artifactId>maven-parent</artifactId>\n    <groupId>com.archon.example</groupId>\n    <version>0.1</version>\n</parent>\n<artifactId>maven-plugin</artifactId>\n<packaging>jar</packaging>\n```\n\n> 一般`artifact`（依赖包）的版本信息全部在`maven-parent`中声明\n\n### 排除重复GAV\n查找冲突：\n\n一种是pom文件目录下运行mvn dependency:tree，查看依赖关系树形结构。\n\n另一种是使用maven插件Maven Enforcer Plugin，执行maven命令 “validate”会打出日志告诉我们哪些jar包冲突。\n\n解决冲突：\nexclusions\n```xml\n<exclusions>\n    <exclusion>\n        <artifactId>spring-boot-starter-logging</artifactId>\n        <groupId>org.springframework.boot</groupId>\n    </exclusion>\n</exclusions>\n```\n\n### 构建jar\n\nmvn package\n\n### 跳过单元测试\n\n-DskipTests，不执行测试用例，但编译测试用例类生成相应的class文件至target/test-classes下。\n\n**-Dmaven.test.skip=true，不但跳过单元测试的运行，也跳过测试代码的编译。。**\n\n```\nmvn clean install -Dmaven.test.skip=true\n```\n\n### 使用Nexus搭建maven私有仓库\n\n[搭建私有仓库](https://www.jianshu.com/p/9740778b154f)\n\n","categories":["笔记"]},{"title":"Linux下如何通过日志排查问题","url":"/2019/09/14/9/","content":"<Excerpt in index | 首页摘要>\n\n以前学习Linux的时候都是在瞎玩，没有真正去研究一些命令和命令的参数。现在就以生产日志查询的角度去学习一些基本的命令，需要什么就学什么。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n一般来说我们的命令都是这样的形式：command [options] [arguments]\n\noptions选项，arguments参数\n\n\n\n一般来说，生产的服务器我们都是通过跳板机去连接，而不能直接连接。\n\n### Firtst Step\n\n第一步就是连接跳板机，可以用工具，也可以直接在web上去连接。\n\n### Start\n\n接着我们就是找到对应日志的位置。*如果你不知道日志存储的位置，在Java项目中，都会配置自己的日志存储路径，如果是用log4j2的话，你应该可以到对应的配置文件，找到日志存储的位置。*\n\n如果你不懂命令，或者想了解更多，可以来这里：[Linux命令手册](https://man.linuxde.net/)\n\n\n\n然后就是开始一顿操作了\n\n```\npwd: print working directory 首先我们可以查看自己所在的当前路径，当前目录\nwhereis: 当然你也可以通过这个命令查找文件所在位置\n\ncd: change directory 接着进入到对应的目录下，在这里可以使用绝对路径|相对路径\n\toptions:\n\t\t. 当前目录\n\t\t.. 上级目录\n\t\t~ 用户主目录\n\t\t- 返回此目录之前的所在的目录\n\t\t/ 根目录\n\t\t\nls: list directory content 如果我们不知道当前目录下有什么，我们就可以用这个命令列出\n\toptions:\n\t\t-a 隐藏的文件也会列出来\n\t\t-l 所有输出信息用单列的格式输出，而不是多列，一般我们用这个就看看文件的修改时间、大小\n\t\t-t 最近修改的文件显示在最上面，这个还是很有用的，但文件比较多的时候好用。\n\t\t--color=auto 列出文件并标记颜色分类\n\t\t\n```\n\n### Importance\n\n当我们定位到日志目录时，这才是真正开始查询日志。vi这个是比较特殊的，所以先讲。虽然我们查询日志的时候几乎用不到这个命令，这个命令是用于编辑文件的。在linux中用的是vim，我也是用这个。\n\n要想使用vi，首先就需要了解其工作模式：命令模式、编辑模式、末行模式\n\n![vim](https://www.runoob.com/wp-content/uploads/2014/07/vim-vi-workmodel.png)\n\n\n\n基本上了解上面的一些就ok，另外就是如何编辑和退出。当一开始进入的时候是**命令模式**，接着我们可以按下键盘上的**iao**任意一个，就会进入到编辑模式了。编辑完后，我们可以看**ESC**回到命令模式，最后输入**：**进入到末行模式，也就是上图的底线命令模式，最后输入*!wq!**保存退出即可。\n\n```\n:! 强制\n:w 保存\n:q 退出\n:q!强制退出\n:wq!\n```\n\n\n\n---\n\n上面的简单了解先即可，接下来才是我们查询日志。在linux系统终端模式下，我们是没有图形界面去给你直接点开文件，一个个去浏览的。因此我们第一个问题就是：如果查看文件内容。上诉所讲的vi也是可以的，但是对我们来说使用太不友好了。下面就是我们用到的一些用于查看的命令。在学习之前我们可以先想一下我们有什么需求：首先我们希望可以去搜索关键字，其次最好颜色也像上面一样可以标记颜色，最后可以看看查询内容的上下文。Ok，下面你的问题都将会得到解答。\n\n#### grep\n\n**G**lobal search **R**egular **E**xpression(RE) and **P**rint out the line(全面搜索正则表达式并把行打印出来)\n\n\n\n```\ngrep/zgrep: \ngrep \"match_pattern\" file_name 在文件中搜索一个单词\n\toptions:\n        --color=auto 标记匹配颜色(这个很舒服啊，这样我们就能快速找到我们要查询的内容了)\n        -E 使用正则表达式(这个应该和上面的搜索单词区分)\n        -c 统计单词出现的次数\n        -n 输出匹配字符的行数(终于等到你，这个应该会很有用吧)\n        -i 忽略大小写\n        -A 除了显示符合范本样式的那一行之外，并显示该行之后的内容。\n        -B 除了显示符合范本样式的那一行之外，并显示该行之前的内容\n        -C 除了显示符合范本样式的那一行之外，并显示该行前后后的内容\n\n```\n\n这个ABC可谓是神器，因为有时候我们不仅是想看到符合的内容，**还想看到其上下文，这时候就得借助ABC选项了。**\n`例如：grep \"aes-256-gcm\" shadowsocks.log -A 2`\n\n#### tail\n\n​    tail file (**显示文件file的最后10行**)\n​    tail +20 file (显示文件file的内容，**从第20行至文件末尾**)\n​    tail -c 10 file （显示文件file的最后10个字符）\n\n```\ntail:\n\toptions:\n\t\t-f 显示文件最新追加的内容\n```\n\n**显示文件最新追加的内容**，这个选项在外面启动项目的时候很方便，因为我们启动的项目的时候日志是一点点打印的，这个时候我们就看到日志一点点输出，不用每次tail查看后面的10行。\n\n```\ntail:\n\toptions:\n\t\t-n 输出文件的尾部N（N位数字）行内容\n```\n\n有时候我们并不想从第几行开始到尾部，也不下追加内容显示，我们只想显示后面的多少行内容。那么这个选项就很好的满足了你的需求。\n\n#### head\n\n```\nhead:\n\toptions:\n\t\t-n 输出文件的头部N（N位数字）行内容\n```\n\n其实-n的这个选项，基本上就是用来代码`行`的，在tail和head命令中我们发现他们是一样的效果。\n\n#### cat/zcat\n\n为了控制滚屏，可以按Ctrl+S键，停止滚屏；按Ctrl+Q键可以恢复滚屏。按Ctrl+C（中断）键可以终止该命令的执行，并且返回Shell提示符状态。\n\n管道： | \n\n#### more\n\n>  **more命令**是一个基于[vi](http://man.linuxde.net/vi)编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持vi中的关键字定位操作。more名单中内置了若干快捷键，常用的有H（获得帮助信息），**Enter（向下翻滚一行），空格（向下滚动一屏）**，Q（退出命令）。\n\n\n\n基本上上面所列出的命令已经足够我们查看日志了。\n\n---\n\n当然除了查看文件，我们可能还需要看一些进程\n\n#### top\n\n实时查看系统运行状态\n\n```\n-b：以批处理模式操作\n-c：显示完整的治命令\n-d：屏幕刷新间隔时间\n-I：忽略失效过程\n-s：保密模式\n-S：累积模式\n-i<时间>：设置间隔时间\n-u<用户名>：指定用户名\n-p<进程号>：指定进程(必备)\n-n<次数>：循环显示的次数\n```\n\n在top命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了-s选项， 其中一些命令可能会被屏蔽。\n\n输入top，然后按对应的键即可。**Ctrl+C停止太low了，试试按q直接退出。**\n\n```\nh：显示帮助画面，给出一些简短的命令总结说明\nk：终止一个进程\ni：忽略闲置和僵死进程，这是一个开关式命令\nq：退出程序\nr：重新安排一个进程的优先级别\nS：切换到累计模式\ns：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s\nf或者F：从当前显示中添加或者删除项目\no或者O：改变显示项目的顺序\nl：切换显示平均负载和启动时间信息\nm：切换显示内存信息\nt：切换显示进程和CPU状态信息\nc：切换显示命令名称和完整命令行\nM：根据驻留内存大小进行排序\nP：根据CPU使用百分比大小进行排序\nT：根据时间/累计时间进行排序\nw：将当前设置写入~/.toprc文件中\n```\n\n#### ps\n\n```\nps -aux是以BSD方式列出当前全部运行的进程\n\nps -ef是以system v方式列出当前全部运行的进程\n\n```\n\n上面两个命令虽然显示的都是当前全部运行进程，但是ps -aux列出的条目更多\n\n```\n\n\nps -axj 列出守护进程\n\nps -ef | grep init 查找当前运行进程中的的init进程\n\nps -l 列出ps中的进程操作命令及编号，例如kill等\n```\n\n**ps -ef | grep init 查找当前运行进程中的的init进程**\n\n\n\n#### kill\n\n用来删除执行中的程序或工作，生产上要是删除了，怕是要跑路了？\n\n```\n-a：当处理当前进程时，不限制命令名和进程号的对应关系；\n-l <信息编号>：若不加<信息编号>选项，则-l参数会列出全部的信息名称；\n-p：指定kill 命令只打印相关进程的进程号，而不发送任何信号；\n-s <信息名称或编号>：指定要送出的信息；\n-u：指定用户。\n```\n\n#### 上传下载文件\n\n有时候你也可能需要下载文件，可以用下面两个命令。\n\n```\nrz 上传文件命令\nsz 下载文件到本地\n```\n\n\n\n### 总结\n\n上面的命令只是帮助我们查询，一般来说，我们去查询的时候，先定位一下是哪一个服务器上出了问题，连接上对应服务器，找到对应的日志存储位置。\n\n\n\n**接着通过唯一的id去查找，找到对应的id相关信息之后，通过该id所在的线程id去查找。**\n\n\n\n日志的打印格式(**Pattern**)可以在log4j2.xml配置文件下找\n\n```\n2019-08-31 00:00:00.414 ERROR [SimpleAsyncTaskExecutor-1] 1e1111c8-1bf4-4e2c-af43-db0bda2ba85c 后面的没有列出来\n\n日期——线程名——线程ID\n```\n\n**在这里要看是异步线程，还是同步线程，还是多线程，不然你可能通过该线程id找不到对应的日志错误信息。如果没有线程id，那就只能通过线程名称了**\n\n其次，如果是mq的消息，你可以先找到mq消费的**messageId**，接着通过该messageId找到更多的信息。\n\n\n\nlog4j2.xml日志文件大小达到一定的数量，你就只能到压缩文件查看了，用`zgrep`命令。不然你可能一直很奇怪为什么查不到信息。\n\n\n\n**坑：当遇到一个错误信息的时候，你可以看看代码，然后通过版本控制器看看是不是最近有人改了代码，然后找出来暴打问一顿。（笑）**","categories":["Linux"]},{"title":"我在IntelliJ IDEA下的常用设置","url":"/2019/09/14/8/","content":"<Excerpt in index | 首页摘要>\n\n这一篇里主要是总结一下我在IDEA中的一些基本使用。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n在使用之前，我都会习惯性的设置一下编码为UTF-8，并且设置一下字体。\n\n编码设置：Setttings——Editor——Encodings(注意下面有个properties文件的默认编码设置，这里也需要设置一下)\n\n字体设置：Setttings——Editor——Fonts(我习惯用的是Source Code Pro和Consolas)\n\n背景设置(可选)：Setttings——Appearance —— Background Image(IDEA比Eclipse友好的地方之一，IDEA可以轻松的设置背景图片，这样我们写代码也有动力，并且透明的背景对我来说比较舒服。)\n\n---\n\n\n\n### 其他设置\n\nSetttings——Editor——General下有几个不错的设置\n\n* Setttings——Editor——General——Change font size(Zoom)  with Ctrl+Mouse Wheel (通过Ctrl+鼠标控制字体大小，这样当我们通过IDEA给别人演示的时候，就可以很方便调整字体大小\n* Setttings——Editor——General——Appearance——Show method separator一个让我觉得很舒服的设置，这个设置是给方法进行添加一条分割线，不占用行数。\n* Setttings——Editor——General——Auto Import——然后勾选Add unambiguous imports on the fly以及Optimize imports on the fly(快速导入和删除无用的包)\n\n\n\n### 快捷键\n\n一些简单的复制粘贴就不介绍了，下面是一些我用的比较多，也比较好用的快捷键。快捷键无非就是按键的组合，一般是CTRL、Alt、SHIFT和其他按键的组合。\n\nCtrl + F12    查看类的方法\n\nCtrl + B\t进入光标所在的方法\n\nCtrl + Alt + B\t在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口\n\nCtrl + D\t复制光标所在行 或 复制选择内容\n\nCtrl + E\t显示最近打开的文件记录列表 \n\nCtrl + F\t在当前文件进行文本查找\n\nCtrl + Shift + F\t根据输入内容查找整个项目 或 指定目录内文件\n\nCtrl + G\t在当前文件跳转到指定行处\n\nCtrl + H\t调用层次\n\nCtrl + I\t选择可继承的方法\n\nCtrl + O\t选择可重写的方法\n\nCtrl + R\t在当前文件进行文本替换\n\nCtrl + Shift + R\t根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件\n\nCtrl + Y\t删除光标所在行 或 删除选中的行，这是和Eclipse不太一样的\n\nCtrl + +\t展开代码\n\nCtrl + -\t折叠代码\n\nCtrl + /\t注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 \n\nCtrl + Shift + /\t代码块注释 \n\nAlt + Enter\tIntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同\n\nAlt + Insert\t代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等\n\nShift + 左键单击\t在打开的文件名上按此快捷键，可以关闭当前打开文件 \n\nCtrl + Shift + Alt + C 复制参考信息，IDEA中复制整个类的路径\n\nCtrl + Shift + Alt + V\t无格式黏贴 \n\nCtrl + 左方向键\t光标跳转到当前单词 / 中文句的左侧开头位置\n\nCtrl + 右方向键\t光标跳转到当前单词 / 中文句的右侧开头位置\n\nCtrl + 前方向键\t等效于鼠标滚轮向前效果\n\nCtrl + 后方向键\t等效于鼠标滚轮向后效果 \n\nAlt + 左方向键\t用此快捷键就可以在子视图中切换\n\nAlt + 右方向键\t用此快捷键就可以在子视图中切换\n\nCtrl + Alt + 左方向键\t退回到上一个操作的地方\n\nCtrl + Alt + 右方向键\t前进到上一个操作的地方\n\nCtrl + Shift + 左方向键\t标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句\n\nCtrl + Shift + 右方向键\t光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 \n\nShift + 滚轮前后滚动\t当前文件的横向滚动轴滚动(用鼠标的时候也可以很骚)\n\n#### Debug\n\nF7\t在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中\n\nF8\t在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内\n\nF9\t在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上\n\n(Tip：在debug模式下Debugger栏目下有个像计算器的图标，那就是`Evaluate Expression`，一个可以动态执行代码的工具，我基本上用来查看变量)\n\n另外在debug模式下，还可以动态改值。\n\n断点中可以进行一些条件值设置，满足条件才会进入。\n\n推荐文章[IntelliJ IDEA Windows And Linux Keymap简体中文](https://blog.csdn.net/qwfys200/article/details/81835845 )\n\n### IDEA Plugins\n\nAlibaba Java Coding Guidelines 代码规范\n\nGrep Console 控制台多彩\n\nLombok\n\nMyBatisCodeHelperPro\n\nRestfulToolkit 可以根据URL跳转到对应的方法(全局快捷搜索：*Ctrl  \\\\* )\n\nSonarLint \n\n\n","categories":["笔记"]},{"title":"从编程思想中学Python","url":"/2019/07/21/7/","content":"<Excerpt in index | 首页摘要>\n\n人生苦短，我用Python。 \n编程的思想非常的伟大和奇妙，我把我所认为的编程思想写在了这里。这是我第一次教别人编程，笔记和思想上可能会有一些不足和错误之处，还望指正。老实说，如果真的想了解编程，我并不建议从Python开始学，并没有鄙视之意，而是因为这样你往往会忽略掉很多东西。我们学的不是语言，而是思想。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# Python3\npython是一门**动态**的**强类型解释性**编程语言\n\n\n### 关于编程需要知道的几个东西\n1. 编译器，解释器\n2. 编程语言都有自己的特性和语法，那这样的话编程语言就有分类。\n一种按强类型和弱类型，一种静态语言和动态语言，一种是编译型语言和解释型语言。\n3. 二进制，内存，引用(指针)(地址)\n\n### Python的解释器\n```shell\nPython 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\n```\n\n### Terminal / 终端 / shell\n用于执行命令 \n\n命令的格式：\n```\n命令 [参数可选] 目标(或者要执行的文件或目录)\n```\n**一些常用的命令**\n\n```\ncd: change directory\ncd ..\ncd .\ncd /\npwd: print working directory\ncls\nls [-a]\n\npython xxx.py\n\nmkdir\nrm -rf /* 删除根目录下的所有文件\ncat\nzcat\ngrep\ntouch\nvim\n```\n\nQ：文件和目录，文件夹的区别？\n\nQ：绝对路径和相对路径？\nA：绝对路径就是完整的路径，以根目录开始，而相对路径是相对于一个目录的路径。\n```\n绝对路径: /usr/bin/python3\n相对路径: ./path\n```\n\n---\n\n### 环境搭建\n1. python3下载(开发环境)\n2. 环境变量的配置\n\nQ: 为什么要配置环境变量\n\n\n### Pycharm的基本使用\n\n1. 设置编码和字体， Source Code Pro / Consola\n2. 其他可选设置：background，template，method separation\n3. 快捷键：CTRL+ZXCVAS/D/FR/G\n4. CTRL + SHIFT + ALT + C\n```\nD: duplicate\nF: found\nR: replace\nG: go to line\n```\n\n### Python入门第一个程序\n```python\n#!/usr/bin/python3\n \nprint(\"Hello, Python!\")\n```\n1. **设置编码**\n2. 编写程序\n\n**编写程序需要注意的东西**\n1. 命名规范，不可以使用**关键字**，不能以数字开头。注意：命名的规范不只是说变量的命名合法就可以了，可是有一定的规则，比如驼峰法。\n\n- [ ] setAge()\n- [x] set_age()\n- [ ] SetAge()\n\n2. 严格的缩进\n3. 注释，多行和单行注释\n```python\n'''\n注释的内容\n'''\n# 注释的内容\n```\n\n**代码规范**\n1. 比如变量的命名规则？函数的命名规则？文件的命名？\n看看别人大神是怎么写的，比如可以到github去查找python项目\n2. 模块的分布，比如说你不可能所有代码都写在一个文件，那你就需要按照一种规则是分布\n3. 符号和字母之间，后面要加空格，前面不用。\n```\n1. 类名风格是class ServerHealthCheck():\n2. 函数名风格是 def obtain_ip(self):\n3. 变量名风格是 self, base_url, port, tcp\n4. 文件名风格是 site_health.py\n```\n---\n\n### 变量和数据类型\n变量：用来存储和复用 ，有存储的空间(内容和地址)，还有类型。\n\n**Python常用的数据类型**\n```\nNumber\n    bool: True、False\n    int\n    float\n    complex\nStr\nList\nTuple\nSet\nDict\n```\n* 不可变数据（3 个）：Number、String、Tuple\n* 可变数据（3 个）：List、Dictionary、Set\nQ: 什么是可变，什么是不可变，使用的时候需要注意什么地方？比如函数传递参数的时候，是值传递，还是引用传递(地址传递，指针传递)？\n\nCRUD:增删改查(Create、Retrieve/Read、Update、Delete)\n\n首先要学会的是遍历，然后是查询\n### list []\n1. insert和append的区别\n2. del list[0] 和 list.remove() 和list.pop()区别？\n3. list.clear()\n\n### tuple ()\n和list的区别？不可以改变\n1.只可以访问\n\n### dict \\{key: value\\}\n1. 不允许有多相同的key，如果有则取最后一个\n2. key不能被修改，换句话说：**key只能是Number、String、Tuple**\n3. dict.keys()和dict.values()，使用的时候转换为list。\n```\nlist(dict.keys())\n```\n\n### set\n集合，说到集合其实我有想到了数学里面的集合，我们一般就是用来算并集，差集，交集之类的运算，在这里也是如此。\n1. **集合是无序不重复的， 所以每次输出结果都可能不同**\n2. set.add()和set.update())\n3. set.remove()和set.discard()的区别？注意：**set.remove()如果删除的内容不存在则会报错，而set.discard()不会**\n4. set.pop() 随机移除\n5. set.union() 并集\n6. set.intersection() 交集\n7. set.difference() 差集\n8. set.copy() 浅拷贝？Q: 什么是浅拷贝？什么是深拷贝?\n\n\n**内建函数(built-in)**\nQ: 那什么是内建函数？\nQ: 函数是怎么调用？两种方式？\n```\nprint('Hello World')\n\nstr_food = 'egg'\nstr_food.isdigit()\n```\n\n---\n\n### 运算符\n1. 算术运算符 +-*/% ** //...\n2. 比较运算符 == != >= <>...\nQ: == 和 = 的区别？\n3. 赋值运算符 = += -= %= ...\n4. 位运算符 & | ^ ~ << >>\n注: 位运算符是把数字看作**二进制计算**\n```\n1 & 1 = 1\n1 & 0 = 0\n\n0 | 1 = 0 如果前面是False，则后面不用判断了\n1 | 0 = 0\n```\n5. 逻辑运算符 and or not (&& | !)\n逻辑: bool，值是True和False\n6. 成员运算符 in 、not in\n7. 身份运算符 is 、is not\n\n**注意优先级，一般我们不去记，而是用()去使表达更清晰**\n\n---\n\n### 一些函数\n```\nprint()\ninput() 注: 如果想转为int，要用函数去转换， int(input(''))\ntype()\nlen()\nmax()\nmin()\n\n数学函数\n随机函数\nrange()\n```\n\n### 转义和格式化输出\nQ: 为什么要转义？\nA: 因为有时候我们不喜欢直接输出，而是按照某种格式输出\n```\n\\n\n\\t\n\\r\n...\n```\n**格式化输出**\n形式/语法:\n```\n('%?' % (告诉我?里的内容))\n\n%d\n%f\n%c\n%s\n\n%x\n%p\n%o\n0xffff \n```\n补充：这是旧式的字符串格式化，我们可以用另一个格式化，那就是我们新的`format()`函数\n```\n'{}, {}'.formate(x, y)\n```\nQ: 十六进制的作用?\nA: 简化二进制\n\n跨行编写\n```python\n方法1:\npara_str = \"\"\"这是一个多行字符串的实例\n多行字符串可以使用制表符\nTAB ( \\t )。\n也可以使用换行符 [ \\n ]。\n\"\"\"\n\n方法2:\npara_str = '测试1' + /\n           '测试2' + /\n           '测试3'\n```\n\n---\n\n### 条件控制和循环\nQ: 为什么需要这个？\nA: 有时候我们做一些事情需要判断才去做，所以要条件控制。而有时候可能会重复做一些事情，那么就需要循环。我们变量也是一个道理，有时候我们需要重复去使用，就会需要变量。\n```\ns = 3.14 * r * r\n我们不可能每次都去写3.14 * r * r\n```\n\n#### if\n语法:\n```\nif 条件表达式:\n    内容\n\nif-elif-else\n注意: 条件表达式不能是=，这是赋值，不是条件表达式。还要冒号(:)不能省略\n```\n注意: **if可以没有else，但是有else一定要有if。if里面可以嵌套**\n\nQ: 什么是嵌套？\nQ: if-else和if-elif的区别?\n\n#### 循环\n语法:\n```\n方法1\nwhile 条件表达式:\n    内容\nelse:(可选)\n\n\n方法2\nfor <variable> in <sequence>:\n    内容\nelse:(可选)\n```\n\n**有趣的设计**\n我们可以用一个flag去控制while，当满足条件的时候做什么或者不做什么\n\n**循环里几个有趣的关键字**\nbreak、continue、pass\n\n---\n### 迭代器和生成器\nQ: 什么是迭代器？\nQ: 为什么有迭代器？和for in 的区别是什么\niter():得到一个迭代器\nnext(迭代器):\n\n---\n### 函数\n函数其实跟我们变量或者循环一样，目的是减少重复性。\n\n语法:\n```\ndef 函数名(参数):\n    内容\n    return 可选返回值，默认是None\n```\n**注意return不一定是写在最后一行，随便你写在函数体什么位置。return的意义是结束函数并选择返回值**\n\nQ: 结束整个循环有哪些方式？\n```\n1. 设置flag，或者条件\n2. break\n3. 在函数里可以用return\n4. exit()\n5. ...\n```\n\n**函数参数**\n1. 必须值\n2. 关键字参数，其实就是说我们调用函数的时候指定参数名。\n```python\ndef printinfo( name, age ):\n   print (\"名字: \", name)\n   print (\"年龄: \", age)\n   return\n \nprintinfo(age=50, name='A')\n```\n3. 默认参数，因为有时候我们需要默认一些东西，比如一开始用户注册，有些东西是必填的，但是一开始用户可以选择填写，那我们就需要给一个默认值。\n4. 可变参数\n```python\ndef functionname([formal_args,] *var_args_tuple ):\n注: var_args_tuple是tuple\n\ndef functionname([formal_args,] **var_args_dict ):\n注: var_args_dict是dict\n\n*args, **kwargs\n\n```\n\n**匿名函数**\nlambda表达式\n```\nsum = lambda a, b: a + b\n# 这个sum就是一个函数类型\n# 接下来是函数调用的方式\nsum(a, b)\n```\n\n**变量作用域**\n1. 全局变量 Global\n2. 局部变量 Local\n3. 内置作用域 Built-in(内置函数所在模块的范围)\n4. 闭包函数外的函数中 Enclosing\n\n**一些关键字**\nglobal\nnonlocal(嵌套里面使用)\n这两个都是使变量是全局\n\n---\n### 数据结构\nQ: 什么是数据结构？\nQ: 为什么需要数据结构？\nA: 因为基本的数据类型，或者字符串，列表，元组，字典，集合不能够完全的表示一种数据，我们需要更复杂的数据类型，这就是我们所说的数据结构。我们应该去思考一下，我们在生活中遇到的一些问题或者数据又应该在编程中如何表示呢？存储和取出的时候又是如何可以按照我们所要求的规则呢？可以好好思考一下。\n\n堆栈(Stack)\n特点：FILO\n\n队列(Queue)\n特点：FIFO\n\n用python实现堆栈、队列：\n```\nlist.append() 入栈\nlist.pop() 出栈\n\nlist.appendleft() 入队\nlist.pop() 出队\n```\nQ:树和图，这两种数据结构怎么表示\n\n---\n### 模块和包\n**模块**：其实就可以理解为我们写的python文件，然后可以思考一下每个文件里面有什么内容组成？当我们引入过来的时候，有点像是把里面的内容复制过来。\n**包**：其实是我们的文件夹，因为我们有时候需要相同的命名，那如果同一个模块的名字一样，那就不知道是谁了，**而且同一个目录下也不允许两个文件命名和扩展名一样**。这时候我们就需要包了。就像我们有时候整理电脑一样，可能会命名同样的文件或者文件夹，但是放在不同的目录下。但是要注意的是，每一个包下都需要一个`__init__.py`文件\n\n**Q: 如何取找到文件的呢？**\nA: 绝对路径，当前路径。类似于我们的环境变量\n```\n两种导入的方式：\n1. import 文件名(.py) 全部内容一起导入\n2. from 文件名(.py) import 要导入的模块或者函数  导入指定的\n注：这样的话就可以快一点\n\nimport test\nfrom test import fib\n```\n\n### sys\n```python\n# for i in sys.argv:\n#     print(i)\n#\n# print(sys.api_version)\n# print(sys.copyright)\n# print(sys.path)\n# print(sys.exit())\n```\n\nQ: 模块导入的问题？就是引入其他模块的时候，默认是会执行的，但是这并不是我们所想要的。\n示例：\n```python\nmodule1.py\na = 5\nprint(\"one\")\n\nmodule2.py\nfrom module_one import *\nprint(\"two\")\n\n结果：\none\ntwo\n```\n解决的方法：\n在每一个模块里，其实Python解释器给我们提供了一个叫做`__name__`的变量，类型是：`<class 'str'>`。当其值是`__main__`时，表明在该模块自身运行。而如果是模块名字，那就是在引用程序执行。\n```python\n# main 主要的，也是我们编程界里所说的入口\nif __name__ == '__main__':\n    # 如果运行的入口是在这里，或者说运行这个文件，就会执行这个\n    print('one run? yes')\nelse: # 这种情况其实就是文件名\n    # 如果是被导入，就会执行这个\n    print('one run? no')\n```\n---\n\n### 文件\n权限，只有三种: r、w、x 读写(修改)执行\nexecute\n\n```\nd rwx r-x r-x\n目录 当前用户，所在组，其他组\n\n角色，组\ndirectory, read, write, execute\n```\n\nQ: 什么打开模式是在内容后添加，什么是删除全部内容重新添加？\nA: 即原有内容会被删除: `w、wb、wb+、w+`\n不会被删除的，而是在文件的结尾添加的：`a、ab、ab+、a+`(add)\n\nQ: a和a+的区别？\n![](https://www.runoob.com/wp-content/uploads/2013/11/2112205-861c05b2bdbc9c28.png)\n\n\n\n|    模式    |  r   |  r+  |  w   |  w+  |  a   |  a+  |\n| :--------: | :--: | :--: | :--: | :--: | :--: | :--: |\n|     读     |  +   |  +   |      |  +   |      |  +   |\n|     写     |      |  +   |  +   |  +   |  +   |  +   |\n|    创建    |      |      |  +   |  +   |  +   |  +   |\n|    覆盖    |      |      |  +   |  +   |      |      |\n| 指针在开始 |  +   |  +   |  +   |  +   |      |      |\n| 指针在结尾 |      |      |      |      |  +   |  +   |\n\n**os（operating system）**\n\n**Q**: 最后要关闭文件, file.close()， file是命名的文件对象\n\n\n\n### 异常(Exception)\n\nQ: 为什么会有异常？\n\nA: 其实就是一些不合语法的操作或处理造成的。比如不能除以一个为0的数，这样是得不到结果的，就会抛出异常了。**但是，其实我们并不希望遇到什么异常都直接结束**\n\n所以我们需要对异常进行处理\n\n**关键字：**try、except\n\n```python\ntry :\n    \nexcept:\n    \nfinally:\n    // 无论在任何情况下都会执行\n    // 一般用来关闭文件啊\n    // f.close()\n        \n```\n\n注意的东西：\n\n1. try-except有点像我们的if-else，先去尝试运行try里面的内容，如果有异常就会执行except的内容。**并且try后面的部分内容不会被执行**\n2. 一个 try 语句可能包含多个except子句\n\n**抛出异常**：raise\n\n\n\n预定义清理行为，其实就是Python一些简便的写法，可以帮我们进行关闭。\n\n```python\nwith open(\"myfile.txt\") as f:\n    for line in f:\n        print(line, end=\"\")\n```\n\n---\n\n### 面向对象\n\n\n\n**关键字**：class\n\n```python\n示例：\nclass 类名:\n\t属性(成员变量)\n\t成员方法(成员函数)\n\t构造方法 __init__(self)\n```\n\n* 构造方法是什么：该方法在**实例化**的时候会**自动调用**。\n\n目的：就是用于初始化一些参数或者方法\n\n* 类和对象的区别：\n\n类就像是我们的一个模板，而对象是我们具体的，**实例化也就是我们所说的初始化。**\n\n* 如何创建对象：直接类名(参数)，这里的参数就是我们构造方法的参数。\n\n如果没有，就调用默认的，也就是无参。\n\n  \n\n  **Q: self是什么，有什么作用 ?**\n\n  A: 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的**第一个参数名称**, 按照惯例它的名称是 self。\n\n  **Q: self表示的是什么呢？**\n\n  A: self代表类的实例，而不是类。类的实例其实就是我们的对象，代表当前对象的地址。\n\n\n\n**方法重写(覆盖)- override**\n\n就是父类的方法我们可以进行重写，函数名字和参数一样，只是内容我们可以去改变。\n\n​\t\n\n<font color='red'>私有属性和方法</font>\n\nQ：什么是私有变量，有什么用？\n\nA：声明为私有，**只能在类的内部调用 ，不能在类的外部调用。**目的：增加了使用的权限，为了安全性，和很棒的设计思想。\n\n```\n__name\n__password\n声明为私有只需要在前面加__\n```\n\n**如果我声明了私有之后，就只能在类的内部访问，但是如果我们还想让使用者可以查看或者修改，我们就可以写一个set或者get方法，然后给使用者调用**\n\n注意：在python里面喜欢用`__init__`表示，就是在后面也加__，**但是我们不可以这样去做。**\n\n```\n__name__\n__password__\n这样是错的，这的话还是公有的，只有在前面加__而后面不加才是私有的\n```\n\n\n\n<font color='red'>运算符的重载(overload)</font>\n\n首先，在我们的基本数据类型中，比如Number类型，或者str类型啊，都可以进行`+ - * / `之类的操作，这些`+ - * /`就是我们的运算符。那么我们的类也是一样的，可以进行加减乘除之类的运算符操作，**只不过的是我们需要重写这些运算符操作的方法**\n\n\n\nQ: 面向对象的特点？\n\nA: 一种是面向对象编程，一种是面向过程编程。比如说C语言就是面向过程的一门语言，而Python和Java就是面向对象的编程语言。**面向对象的四大基本特征：封装、抽象、继承、多态**。也正是由于这几个特征，让我使用起来觉得特别舒服。那么下面来具体介绍一下。\n\n封装：<strong>就是将对象封装成一个高度自治和相对封闭的个体。</strong>说的比较抽象，我来举个例子，比如一个学生，那这个学生的一些属性只能由自己提供的set和get的方法来操作。那这样就保证了安全性。\n\n抽象：就是找出事物的一些共同特征，封装成一个类。像人就是抽象的。\n\n继承：把已有的东西或者说类作为自己的内容，就相当于我们继承了父亲的财产。\n\n多态：是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时不确定，<strong>只有在程序运行期间才确定。</strong>也就是父类或接口定义的引用变量指向了子类或具体的实现类的实例对象。<strong>关键点在于程序的调用方法是运行期动态绑定的。这个你可以研究一下重写和重载的区别，他们两个就发生在不同的时期</strong>至于这个编译器和运行期，在重写和重载的问题时我会再详细说一下，这个跟内存的分配，堆，栈结合起来会比较合适。\n\n \n\n#### 继承\n\n```\n示例：\nclass 子类(父类):\n```\n\n注：子类一般也有人叫它派生类，而父类也有人叫它基类。\n\n**注意的东西：**\n\n1. 继承的时候，只需要在子类的后面加上括号，里面写父类的名称即可。可以多继承，只要在后加逗号(，)即可\n\n2. 继承需要覆盖父类的`__init__`方法，那这个时候我们要先调用父类的`__init__`构造方法，示例如下：\n\n   ```python\n       def __init__(self, name, age, sex):\n           # 先调用父类构造方法\n           Person.__init__(self, name, age)\n           self.sex = sex\n   ```\n\n3. 在子类中如何调用父类的东西？答：只要通过父类名然后点(.)去调用即可，但是要注意的是，每一个调用都需要带上一个**self参数**\n\n```python\n    def to_string(self):\n    # 注意，这里的to_string是父类的方法，我们调用要加上self参数\n    return Person.to_string(self) + ', sex:{}'.format(self.sex)\n```\n\n4. 我们需要改写的方法，那我们就重写(覆盖)父类的方法，我们也可以增加属于自己的方法。\n\n5. 定义为私有，子类无法访问\n\n\n练习：[菜鸟教程练习题](https://www.runoob.com/python3/python3-examples.html)\n\n\n\n\n\n","categories":["笔记"]},{"title":"日常吐槽 - 对初学者的一点建议","url":"/2019/07/12/6/","content":"<Excerpt in index | 首页摘要>\n\n在这里只是记录一下一些我曾经一闪而过的想法，有工作上要注意的地方和细节，也有自我鼓励的鸡汤，或是后悔的过去。总之我记录在这里，希望当我感到迷茫或者疲倦的时候，能够看到这里，不忘初心。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 第一章  >>Hello World\n\n我第一次接触编程语言是在大一下的时候，那时候有一门课程叫《C语言程序设计》。那是我第一次有编程语言的概念，初中或者高中的时候老师可能提到过一点知识，不过那时的我一走神这些知识还没理解就过去了。\n\n当我第一次听到编程语言的时候是非常兴奋的，这个故事还得从我接触计算机开始说起。我第一次接触计算机是在小学的时候，那时有人带着我去网吧，但结果我什么也玩然后就睡着了。初中的时候他们又带着我去网吧玩游戏，但是我那时其实对游戏根本没兴趣，也不知道玩什么，结果就在那里东点点西看看。后来去网吧就为了聊天、下载音乐或者视频。在那个时候，其实我对计算机还是没有兴趣。渐渐的，到了高中的时候，那时身边好多人都在玩游戏，我也因此有机会接触了各种游戏，还接触到了一些论坛，贴吧。每天看大佬们在吹水就能学到很多，一下子仿佛打开了我的新世界大门，我感觉我对计算机的了解又多了一点。那时候我感受到了电脑做很多事情，从上面看到了很多不知道的东西，非常的强大。\n\n但是在那个年代，手机流量贵，上网贵，家里没电脑，所以其实去网吧更多的时间是去打游戏。后来由于学业需要，我在高中毕业那一年暑假，终于迎来了我人生中第一台笔记本电脑，我很开心也很兴奋，我终于可以拥有自己的笔记本电脑了，终于可以做自己想做的事了。\n\n可是事情并没有那么简单，我对计算机的了解可以说还是一点也不了解，没有一个结构概念，可是又不知道如何去搜索。所以当我对计算机感兴趣的时候，这是第一次打开我的新世界大门，当有编程语言的概念，这是第二次打开了我的新世界大门。\n\n后来就是一路摸索过来，学了一些编程语言。但是为了就业，最后还是选择了JavaWeb的方向。群里的各位，都是dalao，只有我是个垃圾。所以就不要问我技术栈，我就是个垃圾。\n\n### 第二章 我的心酸历程——一些建议\n\n时间过的很快，一路摸索过来，东西没学到多少大学就结束了。虽然有些后悔但是这也是一种收获，在这里我主要把一些我认为重要的点说一下。人在消极和劳累的时候就容易忘记自己最初的想法，所以我写在这里多回来看看，希望不忘初心。\n\n\n#### 生活鸡汤篇\n\n**// 制定目标和计划**\n\n**void setGoalsAndPlans(Goals goals, Plans plans){**\n\n有时候我们感觉生活，很烦躁，每天不知所措，没有生活和工作的目标，导致了生活不顺心，工作也不快乐。这个时候就应该设定自己的一个目标，因为现状是可以和目标进行对比的，是可以检测我们是否进步了，并且如果你进步了或者实现了自己的目标，你就会得到快乐，而快乐你做事才会更有动力。\n\n一个人的生活应该是快乐，积极向上的。有了目标，我们就应该把目标分细，这就是我们的计划，当我们不知道做什么的时候，就看看自己的计划。一个是大方向，一个是一步一步走。\n\n而计划的具体内容完全是看你个人，像如果作为程序员的话，除了工作外，其他的生活和业余时间，肯定是要经常关注一些技术新闻的，每天了解技术的一些动态或者发生了什么大新闻啊。像如果是一个运动爱好者，你就可以自己设定计划锻炼了，而不是说我这个工作太忙了根本没时间锻炼啊。这种业余的爱好我觉得慢慢来，慢慢去做，就是有些人可能觉得现在制定计划或者设立目标是不是太迟了，其实我觉得如果你真的很想做一件事没有什么迟不迟，想做就去做，去做了你就能得到快乐。\n\n这些计划制定下来，并且去执行了，坚持下去你就会发现其实自己收获了很多。不仅是知识，也为你以后的学习打下了基础，你学习会越来越轻松，越来越快。所以当你不知道做什么的时候，请花点时间想想，给自己制定一个目标和计划，然后去慢慢的坚持和完成它。\n\n**}**\n\n**// 热情和想法**\n\n**void setPassionAndThoughts(Passion passion, Thoughts thoughts){**\n\n熟话说：“兴趣是最好的老师。”当我们做一件事情感受到快乐的时候，我们是不是觉得时间过的很快，并且感受不到累。工作也是一样的，无聊的工作肯定是存在的，有时候我们感觉很累，就会很丧。这个时候我觉得并没有什么外观的因素可以改变你，唯一能够改变的是你自己的想法。\n\n其实确实是这样，我们常常会问别人遇到什么样的问题有什么好的方法啊，或者有什么诀窍啊。其实这个时候人家能够对你说的就只能是稍微安慰一下你，然后让你自己调整自己的心情。我觉得也是这样，有时候环境不是我们能改变了，不好的环境可能会存在你的身边，**这个时候我们的焦虑和烦恼其实是我们内心制造出来了，因为你这样想了所以很烦躁，所以改变自己内心的想法，想着美好或者隔离不喜欢的东西是最好的**。\n\n比如，每天早起上班要走路到地铁，并且还要早起。有的人可能就想：每天这样好累啊。渐渐就对工作失去了热情，然后感觉到累的时候越是这样想就越会消极。但是如果你想，其实每天早起并且走路，你可以当作锻炼身体，平时没什么时间锻炼身体，大部分时间是在工作，那么这段时间作为你的锻炼也是不错的事情。只有做开心的事情才不会觉得累，所以请尽量去相信美好，选择想着美好。\n\n**}**\n\n**// 如何面对困难**\n\n**void hardHandle(Handle handle, Responsibility  responsibility){**\n\n当面对一个困难的时候，我们常常会紧张，害怕，不知所措。这个时候就很容易选择放弃，那么你该选择怎么办。\n\n我觉得首先最重要的一点就是不要逃避，困难来了你就必须去承担和面对，而不是去害怕和逃避。总要有人去承担，事情总会有后果，所以你可以给自己打打鸡血，把自己想象成一个英雄，然后去面对困难。做一个负责任的人，面对困难，不要逃避。我觉得很多时候我们并不是不能解决困难，而是害怕，害怕失败，害怕丢脸，害怕最后一无所有。\n\n可是你应该明白，害怕是无济于事的，我觉得面对困难就应该是尽力做好，只要你尽力了就算再怎么样的结果我觉得你的心里总会有一丝安慰和开心，这个还是说要改变自己的心境。\n\n**所以当你面对困难的时候，要负责，这是你的问题，应该由你解决，然后要尽力**。\n\n**}**\n\n\n\n**// 少犯错误**\n\n**void makeFewerMistakes(Criterion criterion, Note note, Thoughts thoughts){**\n\n在工作中难免会犯错误，有些错误是可以被允许，而有些错误可能就导致你被开除了，所以工作中我们要尽量少犯。\n\n如何做到少犯错？首先我觉得第一点应该是学会总结，把学过的知识或者容易犯错的地方多多复习，增强自己的记忆。\n\n第二点是你应该去学习一些规范，在开发中应该尽量避免个人的一种风格，而应该和标准达成一致。比如代码风格，或者使用一些编码模板。这个必须自己去学，有些人可能在平常生活中就比较随意，然后不注重自己的形象，可能就造成很多人的困扰。有时候你也不想这样，可能就是习惯了，或者觉得无所谓，但也有可能是你不知道别人会在意这个。如果很多人都对这个很讨厌，可能这个就是人们隐形的一种“标准”，而你因为不知道冒犯了别人。理论上来说不知者无畏，但是这种我可能就觉得是常识问题，所以如果你平时没有注意，这个时候就应该去学习，研究一下。\n\n多总结和回顾学过的东西，有助于帮助我们完成自己的知识体系。知识就像是一个巨大的库，知识点之间相互联系，当知识越来越多的时候，会变得越来越复杂，人一旦面对复杂的东西时候就会变得烦恼，心情不好就会自暴自弃，所以要经常总结。当我们复习和思考学过的东西时候，**应该把知识点联系起来，弄清点与点之间的关联，然后当面对类似的东西时候能够拿出来类比和参考。**\n\n​\t瞬间的灵感是非常难得的，所以当你有不错的想法时候，或者总结东西有新的认识的时候，就可以记录下来。我个人建议是用Markdown做笔记，而不是用笔记录。至于里面的便利性有非常多，比如支持图文结合，文字强调和颜色改变，存在服务器方便携带，书写高效并且内容完整等。我觉得在github上存储也是蛮不错的，可以用博客，这个随便你了。\n\n**}**\n\n\n\n#### 技术忽悠篇\n\n**// 未知函数名**\n\n**void Unknown(void){**\n\n**​// 编程语言与编程思想**\n\n每次听到有人问，初学者学什么编程语言合适？或者学什么好找工作。\n\n我的回答肯定是C，然后才是Java，C++，Python之类的推荐。那你又问我为什么，那我就不知道了。因为我一开始学的是C，虽然我的C语言很垃圾，但这是我编程思想的基础。\n\n**就我个人来理解，编程语言虽然很多，但是编程思想是不会变化的**。比如都有函数，变量，类型这些东西，只是在功能上使用有些不同，比如面向对象和面向过程的区别，内存自我管理和回收机制管理的区别等，这些只是别人已经实现和封装好罢了。\n\n**你要明白一个东西，一个是编程语言底层，也就是提供的基础功能，另一个是编程语言库，是别人通过这门语言实现的好用的东西。如果你有足够的兴趣，这门编程语言没有提供的库其他的语言有，你也可以自己去写一个(造轮子)**。\n\n那又如何去知道这些不同呢，**我建议是学懂了C++再去学其他就无敌了**。概念搞懂了，再学什么都会一通百通，我觉得你现在明白你的问题了，你并不是想问学什么编程语言好，而是想知道哪些编程语言是做什么比较方便的，或者主要用来做什么方向的。\n\n**​// 我所推荐的几个技术栈**\n\n随着框架的学习越来越多，我也渐渐迷失了自己。如果不了解框架的底层，是不可能把框架用好的，如果你有足够的兴趣和动力，你还可以自己写一个框架。我是做JavaWeb方向的，所以这里也主要是以Java来说，但是思想是差不多的。\n\n第一个就是去了解一些数据结构、算法，然后去了解编程语言的思想，了解这门语言设计的语法思想，知道了才能用的得心应手，这个可以去看《Thinking  in Java》和《深入理解Java虚拟机:JVM高级特性与最佳实践》。\n\n第二个就是去看《代码简洁之道》《阿里巴巴Java开发手册》等编程规范，这里一个是**命名和代码上的规范**，另一个是**代码结构设计上的规范**，这里其实是第三点。记住命名要规范，至于如何才是规范看手册，(还有一点，如果是需要中文注释的开发，属性和方法建议还是注释上中文。可能是我个人原因，虽然英文看得懂，但是看英文还没达到一目十行的能力，看中文会比较快。)\n\n第三个就是去看设计模式(Design Patterns)、重构、软件工程，小的项目可能并不需要什么结构设计，但是项目大了之后往往是需要多人协作的。这个时候对于项目的结构分层就很重要了，接口和类要怎么设计，如何增强扩展性和可维护性，如何能够使得模块清晰、分工明确。又如何能够优化系统、微服务，这些都是需要去思考和学习的。如果只是一个简单的HelloWorld，就一句话的事情并不能看出和别人的有什么不同，但是一旦工程大的时候就是真正体现了**代码设计的艺术和思想了**。\n\n\n**}**\n\n\n### 第三章 搬砖的日子\n\n押尾桑的卡农回响在耳边，我习惯性的确认一样现在的时间\n\n......\n......\n","categories":["千纱镇辉夜小屋"]},{"title":"日常吐槽 - 最近在做些什么","url":"/2019/07/09/5/","content":"<Excerpt in index | 首页摘要>\n\n离上一次写文章，已经过去了快十天了。时间过的真的很快，每天早起搬砖，回来的时候已经是快晚上九点了。我拖着疲惫的身体，什么也不想做。感觉自己的时间是以一周为计算，时间过了一周了但是给我的感觉却像是只过了一天，我不知道何时才能结束工作，有自己的时间看看文章，学学技术。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n上一周的某一天，宝贝突然跟我说想学Python，叫我教她。以前我总希望她能够学的什么，但每次想教的时候她总会没什么兴趣，我很想告诉她计算机里的巧妙设计，前人的设计思想是如此的伟大。而这一次她竟然主动要求想学，看着她那认真的神情，我决定了要认真的教她。\n\n其实不管学的怎么样，当坚持一段时间下来，就会对编程语言有一定的了解。于是我也开始看起了Python，我教的时候尽量不只是告诉她Python的东西，而是去了解计算机的一些原理。语言只是一门工具，有高级的工具也有底层的工具，每一样都有自己的特点和适合的地方。\n\n因为她没有编程的基础，虽然学过R语言，但是对于计算机的了解还是比较少，所以我决定从头开始讲。我给她讲了变量，告诉她要去存储东西，那么我们就需要用变量去存储，然后存的东西要分类，那么就有了数据类型，然后有简单的数据类型也有复杂的数据类型。存东西要有空间，那么就需要内存，还讲了二进制。我和她讲了编译器和解释器，但是并没有和她说编译器和运行期，因为她这时候就开始晕了。\n\n后来我告诉了她我们要进行判断，那就要用到条件语句。要重复做一样类似的时间，就要用到循环，讲了break，continue，pass。我给她出了斐波那契计算，还有1+2+3+...+n的计算，还有一个猜数字小游戏，她做的不亦乐乎。我也仿佛看到了当年那个刚入门学习编程的我，因为了解了一些思想而开心的不得了，有一种：哇，用计算机去解决问题，这样设计真的很棒的感觉。\n\n后来我还和她讲了布尔的伟大，我已经不记得多少布尔的事迹，但是他的这种思想却是将事物很好的划分了。\n\n接下来不知道会讲些什么，我会结合我所学过的语言，一点点告诉她这个东西是怎么从实现到运用的。很遗憾的是我并没有学过编译原理，只看过一点点的词法分析和解释。\n\n我有时候也在想，如果当年我坚持学的不是JavaWeb而是其他，可能就不需要写那么多业务逻辑，而是可以研究一些底层和性能的东西。可是一切都已经过去，新的生活和方向又在哪里呢？\n\n我喜欢计算机的东西，但并不是一个极客，我只想用业余的时间一点点的去了解，我喜欢看动漫，也喜欢打游戏，看直播，但是现在我很久没去做那些事情了。\n\n也许多年以后，我还是一个学的杂七杂八的垃圾程序员。但其实我并不想给自己贴一个程序员的标签，我并不喜欢天天敲代码或者查看生成日志，我只是想去了解和设计一些东西，我只是一个默默无名对计算机有兴趣的爱好者。\n\n只是为了好玩，仅此而已。","categories":["千纱镇辉夜小屋"]},{"title":"日常吐槽 - 烦恼的一天","url":"/2019/06/30/4/","content":"<Excerpt in index | 首页摘要>\n\n已经许久没有更新博客，来来回回删了好多东西。曾经一度想造轮子，可是每次都造的很烂，最后以失败而告终。\n\n本来还想写一些技术文章，可是后来想想我写来也不是给别人看的，只是我怕自己忘记所以记在这里，有时候可以直接在这里看看罢了。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n网上有很多写的很不错的技术文章，其实有时候你也会发现这些文章大部分内容是一样的，重复的，甚至就是直接搬运、转载的。\n\n在这个信息时代，重复也许并不是一件好事，你可能想找一个问题却发现每一个回答都是一样的，这对人来说是一件恶心的事情。\n\n所以当我可以直接就搜到答案的问题，我是不会再记录在自己的博客里。\n\n一切回归日常。\n\n但我并不是不写，而是不会再发到这里，我打算存在本地，因为这写大部分是我的笔记，也就只有我能看懂吧。(笑)\n\n这里就作为我日常的吐槽吧，讲讲我的或者我听说过的故事。\n\n工作之后，总感觉时间非常不够，很难一直专心去做一件喜欢的事情。每天的时间的过的很快，没有了以前那么多时间去总结和思考，所以导致了很多东西其实就只存在脑海中一会儿。也许天才是个例外，但我并不是，每一点东西我都需要反复的去思考才能记忆深刻。\n\n这也是我重新开始的原因，我想把思考的东西写在这里，生怕自己忘记了一些想法。\n\n我始终热爱着计算机\n\n始终想了解事物的本质\n\n始终想在空闲的时间能够看看番\n\n始终想玩玩游戏","categories":["千纱镇辉夜小屋"]},{"title":"Markdown语法测试","url":"/2019/06/30/1/","content":"<Excerpt in index | 首页摘要>\n\nMarkdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md”\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 欢迎使用 Markdown在线编辑器 MdEditor\n\n**Markdown是一种轻量级的「标记语言」**\n\n![markdown](https://www.mdeditor.com/images/logos/markdown.png \"markdown\")\n\n## MdEditor是一个在线编辑Markdown文档的编辑器\n\n*MdEditor扩展了Markdown的功能（如表格、脚注、内嵌HTML等等），以使让Markdown转换成更多的格式，和更丰富的展示效果，这些功能原初的Markdown尚不具备。*\n\n> Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如~~Pandoc~~，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。\n\nMdEditor源于Pandao的JavaScript开源项目，开源地址[Editor.md](https://github.com/pandao/editor.md \"Editor.md\")，并在MIT开源协议的许可范围内进行了优化，以适应广大用户群体的需求。向优秀的markdown开源编辑器原作者Pandao致敬。\n\n\n![Pandao editor.md](https://pandao.github.io/editor.md/images/logos/editormd-logo-180x180.png \"Pandao editor.md\")\n\n\n\n## MdEditor的功能列表演示\n\n# 标题H1\n\n## 标题H2\n\n### 标题H3\n\n#### 标题H4\n\n##### 标题H5\n\n###### 标题H5\n\n### 字符效果和横线等\n----\n\n~~删除线~~ <s>删除线（开启识别HTML标签时）</s>\n\n*斜体字*      _斜体字_\n\n**粗体**  __粗体__\n\n***粗斜体*** ___粗斜体___\n\n上标：X<sub>2</sub>，下标：O<sup>2</sup>\n\n**缩写(同HTML的abbr标签)**\n> 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启\n\nThe <abbr title=\"Hyper Text Markup Language\">HTML</abbr> specification is maintained by the <abbr title=\"World Wide Web Consortium\">W3C</abbr>.\n### 引用 Blockquotes\n\n> 引用文本 Blockquotes\n\n引用的行内混合 Blockquotes\n\n> 引用：如果想要插入空白换行`即<br />标签`，在插入处先键入两个以上的空格然后回车即可，[普通链接](https://www.mdeditor.com/)。\n\n### 锚点与链接 Links\n[普通链接](https://www.mdeditor.com/)\n[普通链接带标题](https://www.mdeditor.com/ \"普通链接带标题\")\n直接链接：<https://www.mdeditor.com>\n[锚点链接][anchor-id]\n[anchor-id]: https://www.mdeditor.com/\n[mailto:test.test@gmail.com](mailto:test.test@gmail.com)\nGFM a-tail link @pandao\n邮箱地址自动链接 test.test@gmail.com  www@vip.qq.com\n> @pandao\n\n### 多语言代码高亮 Codes\n\n#### 行内代码 Inline code\n\n\n执行命令：`npm install marked`\n\n#### 缩进风格\n\n即缩进四个空格，也做为实现类似 `<pre>` 预格式化文本 ( Preformatted Text ) 的功能。\n\n    <?php\n        echo \"Hello world!\";\n    ?>\n预格式化文本：\n\n    | First Header  | Second Header |\n    | ------------- | ------------- |\n    | Content Cell  | Content Cell  |\n    | Content Cell  | Content Cell  |\n\n#### JS代码\n```javascript\nfunction test() {\n\tconsole.log(\"Hello world!\");\n}\n```\n\n#### HTML 代码 HTML codes\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <mate charest=\"utf-8\" />\n        <meta name=\"keywords\" content=\"Editor.md, Markdown, Editor\" />\n        <title>Hello world!</title>\n        <style type=\"text/css\">\n            body{font-size:14px;color:#444;font-family: \"Microsoft Yahei\", Tahoma, \"Hiragino Sans GB\", Arial;background:#fff;}\n            ul{list-style: none;}\n            img{border:none;vertical-align: middle;}\n        </style>\n    </head>\n    <body>\n        <h1 class=\"text-xxl\">Hello world!</h1>\n        <p class=\"text-green\">Plain text</p>\n    </body>\n</html>\n```\n### 图片 Images\n\n图片加链接 (Image + Link)：\n\n\n[![](https://www.mdeditor.com/images/logos/markdown.png)](https://www.mdeditor.com/images/logos/markdown.png \"markdown\")\n\n> Follow your heart.\n\n----\n### 列表 Lists\n\n#### 无序列表（减号）Unordered Lists (-)\n\n- 列表一\n- 列表二\n- 列表三\n\n#### 无序列表（星号）Unordered Lists (*)\n\n* 列表一\n* 列表二\n* 列表三\n\n#### 无序列表（加号和嵌套）Unordered Lists (+)\n+ 列表一\n+ 列表二\n    + 列表二-1\n    + 列表二-2\n    + 列表二-3\n+ 列表三\n    * 列表一\n    * 列表二\n    * 列表三\n\n#### 有序列表 Ordered Lists (-)\n\n1. 第一行\n2. 第二行\n3. 第三行\n\n#### GFM task list\n\n- [x] GFM task list 1\n- [x] GFM task list 2\n- [ ] GFM task list 3\n    - [ ] GFM task list 3-1\n    - [ ] GFM task list 3-2\n    - [ ] GFM task list 3-3\n- [ ] GFM task list 4\n    - [ ] GFM task list 4-1\n    - [ ] GFM task list 4-2\n\n----\n\n### 绘制表格 Tables\n\n| 项目        | 价格   |  数量  |\n| --------   | -----:  | :----:  |\n| 计算机      | $1600   |   5     |\n| 手机        |   $12   |   12   |\n| 管线        |    $1    |  234  |\n\nFirst Header  | Second Header\n------------- | -------------\nContent Cell  | Content Cell\nContent Cell  | Content Cell\n\n| First Header  | Second Header |\n| ------------- | ------------- |\n| Content Cell  | Content Cell  |\n| Content Cell  | Content Cell  |\n\n| Function name | Description                    |\n| ------------- | ------------------------------ |\n| `help()`      | Display the help window.       |\n| `destroy()`   | **Destroy your computer!**     |\n\n| Left-Aligned  | Center Aligned  | Right Aligned |\n| :------------ |:---------------:| -----:|\n| col 3 is      | some wordy text | $1600 |\n| col 2 is      | centered        |   $12 |\n| zebra stripes | are neat        |    $1 |\n\n| Item      | Value |\n| --------- | -----:|\n| Computer  | $1600 |\n| Phone     |   $12 |\n| Pipe      |    $1 |\n\n----\n\n#### 特殊符号 HTML Entities Codes\n\n&copy; &  &uml; &trade; &iexcl; &pound;\n&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot;\n\nX&sup2; Y&sup3; &frac34; &frac14;  &times;  &divide;   &raquo;\n\n18&ordm;C  &quot;  &apos;\n\n[========]\n\n### Emoji表情 :smiley:\n\n> Blockquotes :star:\n\n#### GFM task lists & Emoji & fontAwesome icon emoji & editormd logo emoji :editormd-logo-5x:\n\n- [x] :smiley: @mentions, :smiley: #refs, [links](), **formatting**, and <del>tags</del> supported :editormd-logo:;\n- [x] list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;\n- [x] [ ] :smiley: this is a complete item :smiley:;\n- [ ] []this is an incomplete item [test link](#) :fa-star: @pandao;\n- [ ] [ ]this is an incomplete item :fa-star: :fa-gear:;\n    - [ ] :smiley: this is an incomplete item [test link](#) :fa-star: :fa-gear:;\n    - [ ] :smiley: this is  :fa-star: :fa-gear: an incomplete item [test link](#);\n\n#### 反斜杠 Escape\n\n\\*literal asterisks\\*\n\n[========]\n### 科学公式 TeX(KaTeX)\n\n$$E=mc^2$$\n\n行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。\n\n$$x > y$$\n\n$$\\(\\sqrt{3x-1}+(1+x)^2\\)$$\n\n$$\\sin(\\alpha)^{\\theta}=\\sum_{i=0}^{n}(x^i + \\cos(f))$$\n\n多行公式：\n\n```math\n\\displaystyle\n\\left( \\sum\\_{k=1}^n a\\_k b\\_k \\right)^2\n\\leq\n\\left( \\sum\\_{k=1}^n a\\_k^2 \\right)\n\\left( \\sum\\_{k=1}^n b\\_k^2 \\right)\n```\n```katex\n\\displaystyle\n    \\frac{1}{\n        \\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\n        \\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {\n        1+\\frac{e^{-6\\pi}}\n        {1+\\frac{e^{-8\\pi}}\n         {1+\\cdots} }\n        }\n    }\n```\n```latex\nf(x) = \\int_{-\\infty}^\\infty\n    \\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\n    \\,d\\xi\n```\n### 分页符 Page break\n\n> Print Test: Ctrl + P\n\n[========]\n\n### 绘制流程图 Flowchart\n\n```flow\nst=>start: 用户登陆\nop=>operation: 登陆操作\ncond=>condition: 登陆成功 Yes or No?\ne=>end: 进入后台\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n[========]\n\n### 绘制序列图 Sequence Diagram\n\n```seq\nAndrew->China: Says Hello\nNote right of China: China thinks\\nabout it\nChina-->Andrew: How are you?\nAndrew->>China: I am good thanks!\n```\n### End\n\n","categories":["笔记"]},{"title":"我和她","url":"/2019/03/05/11/","content":"原本这个网站是用来展示和宝贝一起去玩耍的照片，但是后来发现照片太多，维护起来太浪费时间了，并且访问的速度特别慢。于是决定还是用来写文章吧, 照片就存储在本地, 想看的时候用软件打开。\n\n### 2019-3-23\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=794134&auto=0&height=66\"></iframe>\n\n<h3 align=\"center\"> 那一天 去了深圳湾公园</h3>\n<h3 align=\"center\"> 一个出地铁站就能看到海的地方</h3>\n<h3 align=\"center\"> 海的那边有风</h3>\n<h3 align=\"center\"> 我的身边有你</h3>\n\n### 2019-4-15\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=785793&auto=0&height=66\"></iframe>\n\n<h3 align=\"center\"> 难得的周末 一起去吃吃喝喝</h3>\n<h3 align=\"center\"> 酸菜鱼 海底捞</h3>\n<h3 align=\"center\"> 一个美味休闲的下午</h3>\n\n### 2019-5-15\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=478091&auto=0&height=66\"></iframe>\n\n<h3 align=\"center\"> 五月</h3>\n<h3 align=\"center\"> 五月的风 五月的校园</h3>\n<h3 align=\"center\"> 五月的你 五月的我</h3>\n<h3 align=\"center\"> 五月 与宝贝一起在校园的日子</h3>\n\n### 2019-5-20\n\n<img src=\"/images/520.jpg\" alt=\"\" style=\"width: 200px;\"/>\n<h2 align=\"center\" style=\"font-size:24px; color:#fe9cd1;\">宝贝，❤520快乐哦❤，我爱你，超级超级爱哦</h2>\n<h2 align=\"center\" style=\"font-size:24px; color:#fe9cd1;\">点我的心有惊喜🎁哦</h2>\n\n景哥，你到八十岁还会这样牵着我吗？ （*＾-＾*）\n\n会啊，宝贝。等你想结婚了，我就娶你回家。 (≧∇≦)ﾉ\n\n景哥，景哥 o(*￣▽￣*)o\n\n嗯，宝贝。爱你哟 (＾Ｕ＾)ノ~ＹＯ\n\n景哥，我也爱你💗。\n\n宝贝，我们一起去看流星好不好？我带你去许愿\n\n好啊，可是哪里有流星啊？ (・∀・(・∀・(・∀・*)\n\n有啊，在我心里。哈哈~\n\n讨厌，景哥，你又撩我 (ノω<。)ノ))☆.。\n\n宝贝，抱抱。\n\n景哥，抱抱\n\n宝贝，快看，烟花诶~\n\n\n\n### 2019-5-23\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=33789789&auto=0&height=66\"></iframe>\n<h3 align=\"center\"> 起风了</h3>\n<h3 align=\"center\"> 我以为什么吹进了我的心里</h3>\n<h3 align=\"center\"> 原来是你</h3>\n\n迟来的一篇更新，这两天有点事情，耽误了更新。因为修图需要不少的时间，终于在今天有了点时间修了一下\n\n与宝贝在一起的第一个她的生日\n\n我的表情好傻啊，为什么宝贝的都这么可爱\n\n今天的生日来了好多人，陌生的人一旦多就有点紧张，买了个栗子榕蛋糕，好好吃\n\n和宝贝一起打开了蛋糕，看看宝贝宠溺的样子，很可爱，超级幸福哦\n\n今天的夜空 好美\n\n宝贝，祝你生日快乐！\n\n<br/>\n\n\n\n\n\n\n\n\n\n","categories":["千纱镇辉夜小屋"]},{"title":"入手Sony XPERIA XZ1了","url":"/2018/12/05/12/","content":"\n之前一直用着OPPO R7t，这手机无论在续航还是拍照上都是极差。终于受不了攒钱换了Sony XPERIA XZ1了，我买的是月光蓝，感觉这个颜色比较耐看。到手的时候感觉真的很漂亮，试了一下拍照还可以。<img src=\"/images/xz1_0.png\" style=\"width:30%;\"/>\n用起来也非常的流畅，续航方面个人感觉还是可以，可能是由于之前的手机真的很差吧，造成这种偏差。充电上感觉速度有些慢，不过有之前的备用机觉得可以接受。大法的主题是我喜欢的类型，个人觉得UI真的很好看。\n<img src=\"/images/xz1_1.png\" style=\"width:30%;\"/>\n\n总之，终于可以摆脱之前的烂手机了，也终于可以装上Google全家桶了，打算继续重新开始学习日语和英语吧。","categories":["千纱镇辉夜小屋"]},{"title":"C++编程——C++模板","url":"/2018/10/25/C++编程-第10章/","content":"模板就是泛型的一种编程思想\n格式：\n```c++\ntemplate <typename T> 方法一\ntemplate <class T>方法二\ntemplate和typename是关键字\n```\n\n<strong>作用域：仅对下边挨着的代码段有效</strong>\n例子：\n```c++\n#include <iostream>\nusing namespace std;\n\ntemplate <typename T>\nvoid fun(T a)\n{\n    cout << a << endl;\n}\n\nint main()\n{\n    fun(1);\n    fun(12.3);\n    system(\"pause\");\n    return 0;\n}\n```\n\n<h3>函数模板的具体化</h3>\n```c++\nstruct Node\n{\n    int a;\n};\n\ntemplate <typename T>\nvoid fun(T a)\n{\n    cout << a << endl;\n}\n// 函数模板的具体化，对fun的特殊处理，单独的类型处理\ntemplate<> void fun<Node>(Node no)\n{\n    cout << no.a << endl;\n}\n```\n\n<h3>类模板</h3>\n```c++\ntemplate<typename T>\nclass CPerson\n{\npublic:\n    T a;\n    CPerson(T t)\n    {\n        a = t;\n    }\n};\n\nint main()\n{\n    CPerson<char> c('a');\n    system(\"pause\");\n    return 0;\n}\n\n```","categories":["C++编程"]},{"title":"C++编程——C++类型转换","url":"/2018/10/25/C++编程-第8章/","content":"形式：const_cast<type>(expression)\n在类型转换中，我们通常有隐式转换和显示转换。如果是基本数据类型不会有什么问题，但是当我们类转换的时候进行转换就有可能出现内存截断。这种设计的原因可能是为了防止我们程序员人为的不懂的去进行转换而遇到未知的错误，我在编程的时候几乎没有进行这种类型转换，暂时就保留学习吧，用到的时候再深入研究。\n```\n/*\n *  static_cast\n *  const_cast\n *  dynamic_cast 父子类之间的转换\n *  reinterpret_cast 运用再危险的类型转换\n */\n```\n\n例子：\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A\n{\npublic:\n    int a;\n};\nclass B : public A\n{\npublic:\n    int b;\n};\n\nint main()\n{\n    A *a;\n    B *b;\n    //a = (A*)b;\n    a = static_cast<A*>(b);\n    system(\"pause\");\n    return 0;\n}\n```","categories":["C++编程"]},{"title":"C++编程——C++联编、单例模式、异常处理","url":"/2018/10/25/C++编程-第9章/","content":"<h3>什么是联编</h3>\n\n联编：就是将模块或函数合并在一起生成可执行代码的过程。(函数调用)\n比如我们调用一个函数的时候，函数的实现在其他的地方，那我们这个时候怎么去调用函数呢，这个时候就会到函数的实现去执行，这个过程就叫联编。\n按照联编所进行的阶段不同，又分为：静态联编和动态联编。(编译的时候叫静态联编，运行的时候叫动态联编)\n\n多态的时候就会涉及到动态联编。\n```c++\n    A* a;\n    int index;\n    cin >> index;\n    switch (index)\n    {\n    case 1:\n        a = new B;\n        break;\n    case 2:\n        a = new C;\n        break;\n    default:\n        break;\n    }\n```\n\n<h3>单例模式</h3>\n\n概念：一个类只能创建一个对象。\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A\n{\nprivate:\n    static int flag;\n    // 构造函数为私有\n    A()\n    {}\npublic:\n    static A* getInstance()\n    {\n        if (1 == flag)\n        {\n            flag = 0;\n            return (new A);\n        }\n        else\n        {\n            return NULL;\n        }\n    }\n    // 标记恢复初始值\n    ~A()\n    {\n        flag = 1;\n    }\n};\n\nint A::flag = 1;\n\nint main()\n{\n    A* aa = A::getInstance();\n    delete aa;\n    A* aaa = A::getInstance();\n    delete aaa;\n    system(\"pause\");\n    return 0;\n}\n\n```\n\n<h3>异常</h3>\n```c++\n#include <iostream>\n#include <cstdlib> // C语言中的.h在C++中都去掉，前面加个c。\nusing namespace std;\n\nvoid fun(int a)\n{\n    if (0 == a)\n    {\n        throw 1; // 抛出异常\n        //abort();\n    }\n}\n\nint main()\n{\n\n    try\n    {\n    }\n    catch(int b) // 捕获异常\n    { \n\n    }\n    catch (...) // 其他\n    {\n    }\n    system(\"pause\");\n    return 0;\n}\n```","categories":["C++编程"]},{"title":"C++编程——C++中的多态","url":"/2018/10/24/C++编程-第7章/","content":"多态：父类的指针，调用子类的函数。即：父类的一个函数指针可以有多种状态。可以定义一个父类的类型指针，通过自类的构造函数来为其创建对象。\n关键字： virtual\n1.加了virtual之后就叫做<strong>虚函数了。</strong>通过虚函数，对象类型就会在程序运行时动态绑定。\n2.子类重写的函数，默认是虚函数，可以不加virtual。\n3.重写发生在父子类。\n<strong>4.协变：返回值类型不同(只能是当前所在类) —— 协变</strong>\n5.内联函数和构造函数不能是虚函数。\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Father\n{\npublic:\n    int a;\n    Father()\n    {\n    }\n    virtual void show()\n    {\n        cout << \"I am Father\" << endl;\n    }\n};\nclass Son : public Father\n{\npublic:\n    int a;\n    Son()\n    {\n    }\n    void show()\n    {\n        cout << \"I am Son\" << endl;\n    }\n};\n\nint main()\n{\n    cout << \"多态\" << endl;\n    Father *ming = new Son();\n    ming->show();\n    system(\"pause\");\n    return 0;\n}\n```\n\n<h3>虚表</h3>\n\n就是有一个表，用于装虚函数的地址。因为我们的函数就是通过地址去调用的。如果子类有重写，创建对象的时候，就会覆盖掉这个函数地址。\n调用过程:\n看父类调用的函数是不是虚函数，如果是则到虚表里去找并指向。如果不是则执行自己的。\n\n<h3>取虚表的地址内容</h3>\n```c++\nint main()\n{\n    cout << \"多态\" << endl;\n    Father *ming = new Son();\n    ming->show();\n    typedef void (*fun)();\n    ((fun)(*((int*)*(int*)ming + 0)))();\n    system(\"pause\");\n    return 0;\n}\n```\n\n<h3>抽象类和接口</h3>\n\n在开发中，我们往往会将重复使用的一些东西定义在一起，这就是我们的接口。我们如果开发一个类似的东西的时候，就只要继承这个类就行了。不过Java是单继承和多实现的，而C++则是可以多继承，但是这个思想是一样的。\n\n无论是抽象类还是接口都是不能被实例化的，在Java中用的是关键字abstract表示抽象，如果是抽象方法则不能被实现，只有在子类继承的时候才能被实现。在C++的抽象这个概念则用virtual来表示。\n下面是声明一个纯虚函数\n```\nvirtual void fun（） = 0;\n```\n\nJava中就比较简单了，直接用关键字abstract和interface，不过Java中没有函数声明这个概念，为了区别函数声明我猜所以C++才会用=0这种设计吧。\n\n<h3>虚继承</h3>\n\n<strong>问题：</strong>当我们继承了一个B和C，而B，C又分别继承了A之后，在访问时候就会出现访问不明确的问题。\n解决方法：用虚继承。在继承的时候加上关键字virtual.类似静态成员的思想，所有继承的子类共用一个父类。普通的继承是复制父类的东西过来一份。\n```c++\nclass B : virtual public A\n{}\n```\n\n实例：\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A\n{\npublic:\n    int a;\n};\nclass B : virtual public A\n{\npublic:\n\n};\nclass C : virtual public A\n{\npublic:\n\n};\nclass D : public B , C\n{\npublic:\n\n};\n\n\nint main()\n{\n    D d;\n    d.a;\n    system(\"pause\");\n    return 0;\n}\n```","categories":["C++编程"]},{"title":"C++编程——C++中的继承","url":"/2018/10/22/C++编程-第6章/","content":"在学习C++中的继承时候，说起来有意思的一点就是C++继承的时候可以设定<strong>继承的级别</strong>，即指定public、protected、private。而这个在Java中是不可以的，C++这样设计的话显得更加的灵活。在Java中继承用的是关键字<strong>extends</strong>，而C++中用的是   <strong>:</strong>\n格式：\n```\nclass 父类名 : public / protected / private 子类名\n{}\n```\n\n1.private：父类中的为public和protected，在子类中都是private，访问权限降低。\n2.protected：父类中的public，在子类中为protected。\n3.public：子类的同父类一样。\n4.默认是private的继承。\n\n<h3>带参的父类构造函数</h3>\n\n当父类构造函数需要传参的时候，必须在子类的构造方法中调用父类的构造函数，即可父类的构造函数传参。\n```\nclass Student1 : public Person // 多继承用,\n{\npublic:\n    Student1() : Person(参数) // 给构造函数初始化。\n    {\n        cout << \"son construction.\" << endl;\n    }\n    void show()\n    {\n        work();\n        test_protected();\n    }\n};\n```\n\n<h3>其他</h3>\n\n友元不能被继承。","categories":["C++编程"]},{"title":"C++编程——C++中的运算符重载","url":"/2018/10/18/C++编程-第5章/","content":"<h3>运算符重载</h3>\n\n在C++中如果是普通的数据类型，用运算符进行计算的时候是可以，那我们的类呢？如果我们要进行运算要怎么样呢？这里就需要我们进行运算符重载，运算符其实是一种函数，然后函数重载。\n\n关键字： operator，必须至少有一个<strong>类类型的形参。</strong>\n格式：返回值 operator+运算符(参数列表)\n返回值的作用：连续运算\n注意：必须是支持的运算符，例如几个不能重载的：\n```\n::\n.*\n?:\n```\n\n例子\n```c++\n#include <iostream>\n#include <stdio.h>\nusing namespace std;\n\nclass CStu\n{\npublic:\n    int* a;\n    CStu() \n    {\n        a = new int[2];\n        a[0] = 12;\n        a[1] = 43;\n    } \n    ~CStu()\n    {\n        delete[] a;\n    }\n    CStu(const CStu&amp; stu)\n    {\n        this->a = new int[2];\n        memcpy(this->a, stu.a, 8);\n    }\n};\n\nCStu fun() {\n    CStu stu;\n    return stu;\n}\n\ninline void inlineTest()\n{\n    cout << \"this is Inline Function\" << endl;\n}\n\nint operator+(CStu&amp; st1, int a)\n{\n    st1.a[0] += a;\n}\n\nint operator+(int a, CStu&amp; st1)\n{\n    st1.a[0] += a;\n}\n\nint main()\n{\n    CStu st1;\n    int a = 12;\n    st1 + a; // 运算符重载\n\n    system(\"pause\");\n    return 0;\n}\n```\n\n<h3>类内重载和类外重载</h3>\n\n类内重载，默认左边是类。\n```c++\nclass CStu\n{\npublic:\n    int nAge;\n    CStu()\n    {\n        nAge = 43;\n    }\n    int operator+(int a) // 类 + a,默认左边是类\n    {\n        return (this->nAge + a); \n    }\n};\n\nint main()\n{\n    CStu st;\n    st + 12;\n    return 0;\n}\n```\n\n<h3>ostream和istream运算符重载</h3>\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Per\n{\nprivate:\n    int age;\npublic:\n    Per()\n    {\n        age = 10;\n    }\n    friend ostream&amp; operator << (ostream&amp; os, Per&amp; per);\n    friend istream&amp; operator >> (istream&amp; is, Per&amp; per);\n};\n\nostream&amp; operator << (ostream&amp; os, Per&amp; per)\n{\n    os << per.age;\n    return os;\n}\n\nistream&amp; operator >> (istream&amp; is, Per&amp; per)\n{\n    is >> per.age;\n    if (is.fail())\n    {\n        cout << \"fail\" << endl;\n        per.age = 0;\n    }\n    return is;\n}\n\nint main()\n{\n    Per per;\n    cout << per << endl;\n    cout << \"This is a test for operator\" << endl;\n    cin >> per;\n    cout << per << endl;\n    system(\"pause\");\n    return 0;\n}\n```","categories":["C++编程"]},{"title":"C++编程——C++的拷贝构造和内联函数","url":"/2018/10/15/C++编程-第4章/","content":"1.拷贝构造，其实就是拷贝我们的构造函数。\n2.关键字：const &amp;\n3.本质：本质上是构造函数，参数是<strong>类的常引用</strong>\n4.如果不写那就是默认拷贝构造，默认的拷贝构造函数，会逐个赋值非静态成员(浅复制，浅拷贝)，复制的是值。\n\n<h3>如果调用了拷贝构造，那么就不会调用构造函数了。那什么时候会调用拷贝构造呢？</h3>\n\n1.新建一个对象，给现有的对象进行初始化。\n```c++\n#include <iostream>\nusing namespace std;\n\nclass CStu\n{\npublic:\n    CStu() {}\n    CStu(const CStu&amp; stu) {}\n};\n\nint main()\n{\n    CStu a;\n    CStu b(a); // 方式一\n    CStu c = a;// 方式二\n    CStu d = CStu(a); // 方式三，通过临时对象去创建\n    CStu* e = new CStu(a);// 方式四\n    system(\"pause\");\n    return 0;\n}\n```\n\n如果是赋值是不会的。\n```\n    CStu a;\n    CStu b;\n    b = a; //不会调用拷贝函数。\n```\n\n2.函数参数传递的是对象的值的时候，其次是作为范围值的时候\n```\n方式一：\nvoid fun(CStu stu){}\n方式二：\nCStu fun(){\n    CStu stu； // 创建临时对象，类似方式三。\n    return stu; // 返回对象\n}\n```\n\n<h3>深拷贝和浅拷贝</h3>\n\n1.浅拷贝的话就是只<strong>拷贝值，注意如果是指针的话</strong>，指针变量装的是一个地址，这个值就是地址。所以当我们delete释放的话就会重复释放一段空间。\n2.当指针成员的时候我们就不能使用浅拷贝了，不能直接赋值，要用内存拷贝。也就是深拷贝。\n```c++\n    //如果是浅拷贝，直接复制指针的值，也就是装的地址。\n    CStu(const CStu&amp; stu)\n    {\n        this->a = stu.a;\n\n    }\n    // 深拷贝，内存拷贝\n    CStu(const CStu&amp; stu)\n    {\n        this->a = new int[2];\n        memcpy(this->a, stu.a, 8);\n    }\n```\n\n<h3>解决拷贝构造所引发的二次释放的问题</h3>\n\n1.深拷贝\n2.传地址\n3.传引用\n\n<h3>内联函数</h3>\n\n关键字：inline，函数定义和声明要加inline。\n<strong>作用：用相应的代码替换调用。比常规函数调用稍快，但是要占用更多内存(每次调用都会复制替换)。</strong>\n需要注意的是，这是编译器的特性。有些编译器支持内联函数，有些不支持。如果不支持则写了也没用，也是当作普通的函数去处理。\n\n<h3>类内默认是内联函数，类外不是</h3>\n```c++\nclass Stu\n{\npublic:\n    void fun() //默认是内联函数\n    {}\n}\n\n// 不是内联函数\nvoid Stu:: fun1()\n{}\n```","categories":["C++编程"]},{"title":"C++编程——C++中的常函数和静态变量和静态函数","url":"/2018/10/14/C++编程-第3章/","content":"关键字：const\n1.可以使用数据成员，但是不能修改数据成员。\n```\nint a;\nvoid fun() const{\n    a = 12; // 错误，不能修改数据成员。\n}\nvoid fun1() {\n}\n```\n\n<strong>2.常对象只能调用常函数，不能调用普通函数。</strong>\n```\nconst Stu* stu;\nstu->fun(); \nstu->fun1();//错误，不能调用普通函数\n```\n\n3.用法，加关键字const\n```\nvoid fun() const{;}\n```\n\n4.常对象指针\n```\nconst Stu* stu;\n```\n\n<h3>static</h3>\n\n1.静态成员和静态函数，<strong>是属于类的属性，不是对象。也就是说所有对象共享一个</strong>在类创建处理的时候就已经存在了。而普通的成员是在对象创建的时候才分配的空间。一个是类的，另一个是对象的。\n2.访问形式：类名调用， 对象调用。\n3.静态常量整型数据成员可以直接进行初始化。\n4.静态成员初始化在类外。（<strong>注意是初始化，不是赋值</strong>）\n```c++\n#include <iostream>;\nusing namespace std;\n\nclass Person\n{\npublic:\n    int age = 123;\n    static const int money = 12; // 静态常量整型\n    static int friends;\n\n    Person()//:friends(12) //无法通过构造函数初始化静态类数据，必须要在类外初始化。\n    {\n\n    }\n};\nint Person::friends = 14;// 类外初始化，不用再加static\n\nint main()\n{\n\n    system(\"pause\");\n    return 0;\n}\n```\n\n说明：值得注意的一点是，在C++中可以通过<strong>：冒号</strong>来个数据成员进行初始化，初始化在本质上还是跟赋值有区别的。\n\n<h3>初始化列表</h3>\n\n<strong>类成员初始化总在构造函数执行之前</strong>\n1）从必要性：\na. 成员是类或结构，且构造函数带参数：成员初始化时无法调用缺省（无参）构造函数\nb. 成员是常量或引用：成员无法赋值，只能被初始化\n\n2）从效率上：\na. 如果在类构造函数里赋值：在成员初始化时会调用一次其默认的构造函数，在类构造函数里又会调用一次成员的构造函数再赋值\nb. <strong>如果在类构造函数使用初始化列表：仅在初始化列表里调用一次成员的构造函数并赋值</strong>\n\n1.格式：在构造函数之后加个冒号:\n```\nPerson():friends(12)\n{\n}\n```\n\n2.C++初始化类成员的，它们是按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序。\n```c++\nclass Student\n{\npublic :\n    int x;\n    int y;\n    Student (int i): y(i), x(y)\n    {\n    }\n}\n\n测试：\n    Student* p = new Student(12);\n    cout << p->x << \"\\t\" << p->y << endl; //x=-842150451      y=12\n```\n\n从结果上看，x并没有如我们所愿是12，原因是因为执行的时候是先初始化x(y)，再y(i)。","categories":["C++编程"]},{"title":"C++编程——C++中的类","url":"/2018/10/12/C++编程-第1章/","content":"C++中的类和Java中的类在形式上还有一些细节上是大不相同。当然我也不会对比所有的东西，因为我现在学习的是C++，所以主要说的也是C++。\n\n<h3>C++中类的声明和创建</h3>\n```c++\nclass CPeople\n{\npublic:\n    char cName[12];\n    void setName(char* name)\n    {\n        strcpy(cName, name);\n    }\n    void show()\n    {\n        cout << \"name:\" << cName << endl;\n    }\n};\n\nint main()\n{\n    CPeople p;\n    char c[12] = \"fdsaf\\0\";\n    p.setName(c);\n    p.show();\n    CPeople* p1 = new CPeople; // 通过new的形式\n\n    system(\"pause\");\n    return 0;\n}\n\n```\n\n1.从形式上来看，<strong>C++中声明了一个class的类型，注意结束的时候是有分号；的</strong>\n2.权限上也大有不同，C++只有三种权限，默认是private，而Java有四种，默认就是默认的权限。\n3.权限的使用上，C++使用的以下的形式，个人觉得这样使代码显得更清晰。\n```\npublic:\nprotected:\nprivate:\n```\n\n<h3>C++中的权限</h3>\n\n在C++中只有三种权限，类默认是private，结构体默认是public。\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th>类内可见</th>\n  <th>子类可见</th>\n  <th>类外可见</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>private</td>\n  <td>√</td>\n  <td></td>\n  <td></td>\n</tr>\n<tr>\n  <td>protected</td>\n  <td>√</td>\n  <td>√</td>\n  <td></td>\n</tr>\n<tr>\n  <td>public</td>\n  <td>√</td>\n  <td>√</td>\n  <td>√</td>\n</tr>\n</tbody>\n</table>\n\n下面是Java中的权限，看看就好。\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th>同一个类</th>\n  <th>同一个包</th>\n  <th>不同包的子类</th>\n  <th>不同包的非子类</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>private</td>\n  <td>√</td>\n  <td></td>\n  <td></td>\n  <td></td>\n</tr>\n<tr>\n  <td>Default</td>\n  <td>√</td>\n  <td>√</td>\n  <td></td>\n  <td></td>\n</tr>\n<tr>\n  <td>protected</td>\n  <td>√</td>\n  <td>√</td>\n  <td>√</td>\n  <td></td>\n</tr>\n<tr>\n  <td>public</td>\n  <td>√</td>\n  <td>√</td>\n  <td>√</td>\n  <td>√</td>\n</tr>\n</tbody>\n</table>\n\n<h3>友元</h3>\n\n在类中如果我们设置了属性是private，但是有特殊的情况是，一些类不可以用但是某一个类可以用。这个时候将这个类或者函数声明为友元，那么这个类或者函数就可以访问了。\n<strong>关键字：friend</strong>\n```c++\n#include <iostream>\nusing namespace std;\n\nclass CSTU\n{\npublic:\n    CSTU()\n    {}\n    ~CSTU()\n    {}\n\nprivate:\n    int age;\n    void fun()\n    {\n        age = 12;\n        cout << age << endl;\n    }\n    friend void fun1(); // 友元函数 类内成员对于这个函数是可见的。\n    friend class MyClass; // 友元类\n};\n\n//  友元函数\nvoid fun1()\n{\n    CSTU stu;\n    stu.fun();\n}\n// 友元类\nclass MyClass\n{\npublic:\n    MyClass()\n    {}\n    ~MyClass()\n    {}\nprivate:\n    void fun1()\n    {\n        CSTU stu;\n        stu.fun();\n    }\n};\n\n\nint main()\n{\n    fun1();\n    system(\"PAUSE\");\n    return 0;\n}\n\n```\n\n<h3>构造函数和析构函数</h3>\n\n构造函数通常是用来初始化一些参数，在对象创建的时候调用。\n1.如果是栈区对象，则会创建。\n2.如果是堆区对象，声明指针类型只有用<strong>new的时候才会创建对象</strong>。\n```c++\nCStu stu(12);\nCStu* stu = new CStu(12);\n```\n\n在Java中也有构造函数，不过C++却多了一个析构函数用于释放。C++中的释放值得注意的是，以前用C我们释放一段空间是用<strong>free()</strong>，而C++中用的<strong>delete，并且释放要对应类型。</strong>，比如：\n```c++\ndelete p;\ndelete[] pArr; //申请一段数组空间。\n```\n\n而析构函数则在函数名前加<strong>~</strong>，<strong>只能有一个析构函数，不能重载,这个构造函数区别一下。构造函数是可以有多个重载的</strong>\n```c++\nMyClass::MyClass()\n{\n}\n\nMyClass::~MyClass()\n{\n}\n```\n\n<h4>成员变量初始化问题</h4>\n\n<strong>在C++中，成员变量是没有默认的初始值的，并且不能初始化(只有静态变量数据成员才可以在类中初始化)</strong>，而在Java中是成员变量如果不给是由默认值的，并且可以直接访问。造成这种差别的原因我觉得可能是由于C++是要自己申请空间，而Java则是交给了JVM。\n\n<h3>C++中的访问符</h3>\n\n在Java中访问成员都是用<strong>点操作符</strong>,而在C++中则有多种方式。\n1.如果是引用类型，用点操作符。\n```\nstu.age\n```\n\n2.如果是指针类型，用->\n```\nstu->age\n```\n\n3.C++中还有一个<strong>:: 作用域限定符</strong>，申明变量或函数所属类的符号。之所以会有这个符号，是因为C++中的重载。\n```\nCStu::CStu(int a)\n{\n\n}\n```\n\n<h3>malloc和new， free和delete</h3>\n\n1.new会触发调用构造函数，而malloc不会。\n2.delete会触发调用析构函数，而free不会。\n\n<h3>this指针</h3>\n\n当类中函数的形参和我们的成员变量名相同的时候，为了区别同名，C++和Java中都设计了this表示当前对象指针。\n```\nthis.age // Java\nthis->age // C++\n```","categories":["C++编程"]},{"title":"C++编程——C++中的引用","url":"/2018/10/12/C++编程-第2章/","content":"在生活中你有没有给同学起过花名，不好的花名可是会让人听起来十分厌恶。在C++中引用就是给已定义的变量起别名，别名的作用就是用来简化我们的东西或者叫着好听。在C语言中typedef也是用来个类型起别名。那既让我们知道了C++中的引用，那么接下来看看如何使用。\n```\n基本数据类型的引用：\n    int a = 12;\n    int&amp; b = a;\n常量的引用：\n    const int&amp; a = 12;\n数组类型的引用：\n    int a[12];\n    int (&amp;b)[12] = a;\n指针的引用：\n    int* p = NULL;\n    int* (&amp;p1) = p;\n```\n\n引用的使用需要注意几个点：\n1.在C++中引用只需要在变量前面加<strong>&amp;符号</strong>就可以了。\n2.C++中引用定义的时候就要初始化。\n3.指定了引用的变量之后就不能指向其他了。\n4.引用本身不是一个对象，因此不能定义指向引用的指针，但是指针是对象，所以存在对指针的引用。\n```\n    int a = 12;\n    int b = 1;\n    int&amp; c = a;\n    c = b; // 错误，不能指向其他。\n```\n\n<h3>C++中引用和指针的区别</h3>\n\n1.指针是通过地址上去操作，本质上指针有自己的存储空间地址，存储的是地址。","categories":["C++编程"]},{"title":"C++编程——对第一个C++程序的理解","url":"/2018/10/11/C++编程-第0章/","content":"<h3>初步了解C++</h3>\n\nC++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。\n\nC++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。\n\n上面这两段话是我从菜鸟教程上粘贴过来的，如果你学习到了C++就默认你是了解编程的，起码不用解释什么是编程，什么是编程语言。你可能学习过Java，Python，C，php等。虽然这些语言各有不同，但是底层的原理是一样的。我之前学过Java和C++，C++的东西很多都忘记了当时也没弄懂多少，现在又重新学习起来。和Java一样，C++也是一门面向对象的语言，即拥有面向对象的特征(封装，继承，多态)。那么它们之间又有什么不同，在学习的时候我会主要拿来比较它们之间的语法规则和不同点。下面是我学习的第一个程序。\n\n<h3>第一个C++程序</h3>\n```c++\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    cout << \"HelloWorld\" << endl; // endl换行，并清空缓冲区\n    int a;\n    cin >> a;\n    cout << \"a的值为：\" << a;\n\n    system(\"pause\");\n    return 0;\n}\n```\n\n1.首先是第一行代码，“#”的语句称为宏定义或预编译指令。这里就是引用我们的头文件。\n2.第二行则是一个命名空间，如果从C语言过来的可能一开始没有多大感受，这个下面再细说。\n3.后面的cout和cin则是输入输出流，<strong>在C++中这是一个对象，而不是变量或者函数</strong>，而\"<<\"和\">>\"则是对流的操作。\n\n<h3>关于命令空间</h3>\n\n不知道大家遇到过这种事没有，上学的时候班上竟然有和你同名同姓的同学，这个时候就尴尬了。于是，老师为了区分，就给你换了另一个名字，一个叫高xxx，一个叫低xxx，总之加了点修饰把你们区分开了。在编程中也一样，程序代码千千万万，如果每一个变量或函数我们都要起一个新的名字就会很头疼，所以在C++中就加了命名空间的说法，在Java中则称为包。\n这个东西没有什么神秘的地方，就是用来区分同名的函数或者变量的。我们只要懂得用法就可以了。\n\n创建：\n```\n规则：\nnamespace 名字\n{\n    常量，变量，函数等对象的定义\n    void fun()\n    {}\n}\n实例：\nnamespace name\n{\n    void fun()\n    {}\n    namespace name1\n    {\n        void fun1()\n        {}\n    }\n}\n```\n\n使用：\n```\n方法一： \n    using namespace 命名空间的名字\n    fun();\n方法二：\n   规则：  命名空间的名字::内容\n   例如： name::fun();\n```\n\n<strong>说明</strong>\n1.<strong>namespace和using是关键字</strong>。有点类似Java中的<strong>package和import</strong>。嵌套的命名空间就类似包的子包。下面Java中包的创建和使用。\n```\n创建：\n    package com.test;\n使用：\n    方法一：\n    import com.test;\n    fun();\n    方法二：\n    com.test.fun();\n```\n\n像其他的基本数据类型和C中都差不多，下一次我们来看看C++中的类和引用和Java中有什么不同。","categories":["C++编程"]},{"title":"我的大学生活","url":"/2018/10/10/3/","content":"<Excerpt in index | 首页摘要>\n\n我的大学在某普通的二本学校，我的大学生活真的挺失败的。没参加过多少比赛，也没得过什么牛逼的奖。别人女朋友都换了好几个，而我大学都没谈过恋爱，也没有女生喜欢，朋友也没认识几个，就连旅游也没去过几个地方，虽然在大学的城市生活了三年多了，但是一点也不熟悉。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n本专业的东西没学懂多少，数学烂的不行，算法一点都不懂。唯一欣慰的是没有挂过科，英语四级和计算机二级这些还没有来得及担心就已经过了。\n\n大学的圈子过的很小，参加过一个日语协会，那是我在这个学校认识的为数不多的几个人，副部和部长，柠檬学姐还有振振，我还没有和她们好好说再见她们就已经毕业了。不过开心的是偶尔还能听到她们的消息，而我的小学和初中像是未存在过早已没了联系，高中宿舍倒是认识了一帮不错的人每次回去都会聚一下玩的很开心。\n\n我的大学就这样快要结束了，没有什么起眼的地方。\n\n<h3>认真做自己</h3>\n\n在大学以前我身边的大部分人每天就是玩，也没有学习目的，而我也如此毫无目的每天不是玩就是听课，也不知道学的是什么，老师教的这些用来干什么，就只会老师考什么就投机取巧去学什么背什么。可是我家里并没有矿这样下去我就会变成人渣，我也很想到处去玩买各种喜欢的设备可是我必须要有一份工作支撑我的家庭。于是我开始想我以后要做什么，我喜欢的是什么，我要有一个目标而不是每天毫无目的的生活，我要每天做自己喜欢的事。我花了好几天都在想我喜欢的是什么，游戏吗？画画吗？音乐吗？还是做动画？还是摄影？还是教师？还是...我想了很久，最后得到的答案是：我想玩。哈哈，这看起来真是个废话，一点也不好笑。\n\n不过并没有错，我每天想做的就是玩，我是一个不喜欢工作的人。我在高中的时候挺幸运的，有了手机，通过手机了解到原来还有这么好玩的东西。\n\n我第一次听说乐器的东西，了解到了吉他。\n\n我第一次听过一副上百的耳塞，发现原来听歌还可以这么舒服，我以前的耳机都是什么垃圾啊。\n\n我第一次喜欢上了玩游戏。我错过了玩红警和魔兽还有dota的时代，但是却遇上了英雄联盟，讨鬼传，战神，怪物猎人，我发现游戏真的很好玩。\n\n我第一次读到一本好书，发现看书也是不错的事情。\n\n我第一次有机会在网上选自己想看的日本动画，知道了日本动画做的非常不错，那个年代有了手机和网吧后看动画挺方便的。\n...\n...\n\n可是，这些并不能成为我的工作。直到某一天，在2016/4/27这一天，我遇到了一个人，他给了我一样东西，我终于明白我想做的是什么。\n这个人便是我的C语言老师，那一天我开始接触了编程。\n\n那时候玩游戏经常出问题，或者别人给的教程看不懂，于是我就想自己搞清这些联系，而编程就是这个大门的入口。我明白了原来现在我用的这些关于软件的所有东西都是别人用编程做起来，但是有些东西并没有我想要的，我很不满意，于是我想自己做出一些东西来。而且，我发现这东西也能作为我的工作。\n\n<h3>我的编程之路</h3>\n\n想法是简单的，但是要做出来却特别难。我发现我这人说起大话来一点都不含糊，学C语言一段时间后我就觉得难了，开始搞不懂，每天看了好多教程就是不太理解。而我的C语言老师也没有讲多少内容，刚讲到一点指针的东西就结课了。后来又学了数据结构，可是由于C语言的基础没学好很多数据结构用到的C语言东西都没有学，这门课也学的很烂。那时候我的心情很糟糕，我有很多问题但是无从知晓答案，我每天都在想学习C语言问题。\n\n后来，勉强算是学完了C语言基础，可是接下来我就不知道要学什么了。后来听说去学Python，就学了Python可是也没懂多少。再后来知道了Java有一套做Web的教程，这个时候我已经快大三了，为了混口饭吃找份工作，我学了这一套教程。\n\n学习的过程挺困难的，一个人看着视频和书自学，身边的人每天都在玩，没人会喜欢我喜欢这些，我也无法和别人交流学习的想法。如果你遇到了愿意和交流的人，请好好珍惜她。\n\n我在网上曾经遇到过一个女孩，我教她装了Ubuntu系统，并收取了她一定的费用。那时候感觉她和自己挺投缘的，我厚着脸皮硬是问了别人很多问题，那是我很久以来从没有过的开心，我很想见她了解她。那是第一次有女生愿意和我聊编程，吉他的东西，她也给我分享了她看的照片。虽然联系的时间并不长久，很快就没了联系，但是和她在一起聊天的日子让我真的发自内心的开心。\n\n国庆前的一段时间，也去面试了好几家公司，那段时间每天就是听宣讲，笔试然后面试等通知。offer到手后另一个考虑到的问题就是工资和前景，我一同学面试了很多公司拿了好几个offer，他对工资普遍不满意，他想要有8k的工资。而当我选择深圳7k工资的时候，他对我说：\" 不行啊，你太急了，以你的能力可以拿到更多，你不想拿了?我还想去试试。\"\n\n说实话，我面试了好几家公司，其实每家的要求和工资都差不多，我觉得这样的工资对我来说还不错了。工资高的自己也达不到要求，我觉得时间应该放在更多有意义的事情上，我对底层很多东西都不懂，于是又重新学了C语言和数据结构，现在正在重新学习C++。\n\n<h3>做个乐观的悲观主义者</h3>\n\n我是一个悲观主义者，负能量爆棚的人。人们说喜欢踢足球的人很自负，而喜欢编程的人却自卑到了骨子里。我两样都喜欢，却是一个悲观的人，我的同学也觉得我很自卑。我不是一个自负的人，因为我根本没有炫耀的资本了。但我也是乐观的悲观主义者，就像我写这篇文章的时候觉得根本不会有人想看，但是我还是会厚着脸皮发到朋友圈里。\n\n我觉得我是一个乐观的悲观主义者。在看东西的时候我是悲观的，但是做事的时候我却是乐观的。有些人总会说：\"我不行，我做不到，别人有钱我们哪里有那种条件。\"我这个时候就会先看不起这个人，然后再看看他的做法。虽然我也会经常觉得自己怎么样比不上别人，但是我还是会往高质量的生活去努力，认真工作赚钱去买这些。\n\n(最近的b站有个【我的装备清单】活动，评论最多的就是up主家里有矿。现在家里没矿都不好意思称自己为肥宅了，对不起我给肥宅丢脸了。我倒是挺喜欢看这些，看到别人装备这么好的时候，我也会努力工作让生活变得更好。)\n\n有些人觉得自己穷，或者别人买了什么就觉得别人有钱在那酸。一个人要有自己的正确消费观，有些人总觉得有些东西不是自己能消费的起的，这就是一种悲观的做法。我觉得买一样东西，你要去了解它，低价位是怎么样的高价位又是怎么样，自己的需求是什么，使用时间有多长，要先攒一下还是用花呗等等，不要什么都往便宜的买或者觉得不是自己可以用的。\n\n比如在我们的村里，有钱大家就会酸你嘲讽你，没钱人家就会看不起你。这种让我非常讨厌，总是以最坏的恶意看别人。在我们村里，家长大部分都忙于工作，以为让孩子好好读书吃饱饭就很好了，却大大限制了孩子的自由和思想，他们会觉得买电脑不好，孩子会沉迷游戏并且浪费钱浪费电。他们不懂却用自己的思维去限制别人。\n\n<strong>所以如果你想选择或者批判，你就要去了解它，用知识去做选择。</strong>\n\n<h3>接下来的打算</h3>\n\n我的大学生活所剩无几，也就两个月左右了。接下来的时间我打算重新学习C++，然后研究算法，大数据。还有不久我也要实习了，我也会去研究一下怎么做菜，怎么搭配营养，这些都是非常不错的事情。有些人觉得这样的生活太拘束很累，我觉得你只有懂得了才能更好的选择，而这就是我的选择，我觉得这样的生活很棒。\n\n我会去了解很多的东西，接触到什么我就去了解什么。如果有空我又会继续研究吉他音乐，或者学其他乐器。我也会去了解有什么好玩的科技产品让生活变得更方便更酷。如果有人碰巧喜欢上了我，我会带她一起去喜欢的地方。现实是悲观，但是生活可以变得美好。\n\n不要因为工作而忘记了喜欢的东西，我是一个喜欢玩的人，我一直在做自己。","categories":["千纱镇辉夜小屋"]},{"title":"数据结构-队列","url":"/2018/10/06/数据结构-第3章/","content":"队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。\n\n队列的精髓之处在于，<strong>只能在队首(front)删除，在队尾(rear)插入,具有先进先出的特点</strong>\n\n队列的实现又分两种方式，一种是链式队列，还有一种是静态队列(也就是说用数组去实现)。而这里讲的是用数组去实现。\n\n<h3>要考虑的几个问题</h3>\n\n首先队列是只能在front删除，而在rear插入，也就是说<strong>只能单向移动</strong>，这样就有一个问题了，如果我们移到数组的最大值了怎么办，是不是就不能再继续插入或者删除了？这个时候就会造成了资源的浪费。\n\n但是想想，如果是循环数组，形成一个圈，这样就可以在不满的队列情况下插入了。也就是我们说的<strong>循环队列</strong>。\n\n那接下来又要考虑几个问题：既然是循环队列，那我们在插入的时候就要保证插入的位置是正确的。<strong>这个时候就要用到取余的思想，取余可以保证数在一定的范围内。</strong>这个在C语言中随机函数也有应用。\n\n1.如果确定队列是空的？\n答：只要front-rear想等，就说明没有元素了。\n2.如果保证队列是满的？\n答：front和rear都是单向的，并且方向是一样的。所以只要rear的下一个是front就说明不能插入了。即：(rear+1)%length == front\n3.入队和出队的时候，下标该如何表示？\n答：前面说了，用取余的思想，rear = (rear+1)%length；或front = (front+1)%length，久能确保下标一直循环在一个范围内了。\n4.如何遍历队列？\n答：队列的遍历是从front开始的，因此只要保证当前的i下标不等于rear就行了。而如何移动下标，则通过i = (i+1)%length；\n下面就开始用C语言实现一个静态队列,代码如下:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef enum{false, true} bool;\n\ntypedef struct Queue\n{\n    int* pBase;\n    int iFront;//队首\n    int iRear; //队尾\n}QUEUE, *PQUEUE;\nint iLength = 6;\n\nvoid init(PQUEUE, int);\nvoid traverse(PQUEUE);\nbool isEmpty(PQUEUE);\nbool isFull(PQUEUE);\nbool push(PQUEUE, int);\nbool pop(PQUEUE, int*);\n\nint main(void)\n{\n    QUEUE queue;\n    init(&amp;queue, iLength);\n    if (isEmpty(&amp;queue))\n    {\n        printf(\"队为空\\n\");\n    }\n    printf(\"入队：\");\n    push(&amp;queue, 23);\n    push(&amp;queue, 4);\n    push(&amp;queue, 7);\n    traverse(&amp;queue);\n    int iVal;\n    pop(&amp;queue, &amp;iVal);\n    printf(\"出队的元素为：%d\\n\", iVal);\n    traverse(&amp;queue);\n    return 0;\n}\n\n\nvoid init(PQUEUE pQueue, int iLength)\n{\n    pQueue->pBase = (int*)malloc(sizeof(int) * iLength);\n    pQueue->iFront = 0;\n    pQueue->iRear = 0;\n}\n\nvoid traverse(PQUEUE pQueue)\n{\n    if (isEmpty(pQueue))\n    {\n        return;\n    }\n    int i = pQueue->iFront;\n    while (i != pQueue->iRear)\n    {\n        printf(\"%d\\t\", pQueue->pBase[i]);\n        i = (i + 1) % iLength;\n    }\n    printf(\"\\n\");\n    return;\n}\n\nbool isEmpty(PQUEUE pQueue)\n{\n    if (pQueue->iFront == pQueue->iRear)\n    {\n        return true;\n    }\n    return false;\n}\n\nbool isFull(PQUEUE pQueue)\n{\n    if (pQueue->iFront == (pQueue->iRear + 1) % iLength)\n    {\n        return true;\n    }\n    return false;\n}\n\nbool push(PQUEUE pQueue, int iVal)\n{\n    if (isFull(pQueue))\n    {\n        return false;\n    }\n    else\n    {\n        pQueue->pBase[pQueue->iRear] = iVal;\n        pQueue->iRear = (pQueue->iRear + 1) % iLength;\n        return true;\n    }\n}\n\nbool pop(PQUEUE pQueue, int* iVal)\n{\n    if (isEmpty(pQueue))\n    {\n        return false;\n    }\n    else\n    {\n        *iVal = pQueue->pBase[pQueue->iFront];\n        pQueue->iFront = (pQueue->iFront + 1) % iLength;\n        return true;\n    }\n}\n```","categories":["数据结构"]},{"title":"数据结构-栈-堆","url":"/2018/10/06/数据结构-第2章/","content":"在学习编程的时候，我们就会听到堆栈，栈，堆，队列这些名词。\n\n其实堆栈本质就是栈(Stack)，只是换了另一种说法，它是一种数据结构，具有先进后出的特点，FILO(First In Last Out)，就像我们的瓶子一样。我们在学习编程的时候，也会了解到，对于静态分配的存储是在栈区，而对于动态存储的是在堆区中。<strong>和栈不同的是，堆有两种意义。在数据结构中堆是一种完全二叉树，而在程序中，堆(Heap)是程序运行时申请的动态内存，在内存中有一块就叫堆区。而栈只是指一种使用堆的方法(即先进后出)</strong>\n\n<h3>堆、栈区别</h3>\n\n1.堆栈空间分配\n 栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的<strong>栈。</strong>\n堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于<strong>链表。</strong>\n\n2.堆栈缓存方式\n栈使用的是一级缓存， <strong>他们通常都是被调用时处于存储空间中，调用完毕立即释放。</strong>\n堆则是存放在二级缓存中，<strong>生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</strong>\n\n3.堆栈数据结构区别\n堆（数据结构）：堆可以被看成是一棵树，如：堆排序。\n栈（数据结构）：一种先进后出的数据结构。\n\n<h3>栈的应用</h3>\n\n基于栈的先进后出的思想，我们就可以做很多事情，比如函数的调用，在函数中调用其他的函数就是一种栈的思想。又或者我们写一个计算器，也可以通过这种思想。具体的还有很多，如果可以自己实现一个会对其理解更深。\n\n<h3>用C模拟栈的操作</h3>\n\n在栈中，最重要的两种操作是入栈和出栈，下面就模拟栈的先进后出的思想，用C语言去实现。\n1.主要难一点的地方是一开始如何初始化一个栈。思想是申请一块空间给栈顶，然后栈底和栈顶指向同一个空间，这样就生成了一个没有实际意义的栈了。\n2.入栈和出栈和链表的操作和思想差不多。\n以下是代码部分：\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <malloc.h>\n\ntypedef enum {false, true} bool;\ntypedef struct Node\n{\n    int iData;\n    struct Node* pNext;\n}NODE, *PNODE;\n\n\ntypedef struct Stack\n{\n    PNODE pTop;    // 栈顶\n    PNODE pButton; // 栈底\n}STACK, *PSTACK;\n\nvoid init(PSTACK);\nbool pop(PSTACK, int*); // 出栈\nvoid push(PSTACK, int);// 入栈\nbool isEmpty(PSTACK);\nvoid traverse(PSTACK);\nvoid clear(PSTACK);\n\nint main(void)\n{\n    STACK stack;\n    init(&amp;stack);\n    printf(\"入栈前\\n\");\n    traverse(&amp;stack);\n    printf(\"入栈\\n\");\n    push(&amp;stack, 23);\n    push(&amp;stack, 4);\n    push(&amp;stack, 9);\n    push(&amp;stack, 1);\n    traverse(&amp;stack);\n    printf(\"出栈\\n\");\n    int iData;\n    if (pop(&amp;stack, &amp;iData))\n    {\n        printf(\"出栈的元素：%d\\n\",iData);\n    }\n    traverse(&amp;stack);\n    clear(&amp;stack);\n    printf(\"清空栈!\\n\");\n    traverse(&amp;stack);\n    return 0;\n}\n\nvoid init(PSTACK pStack) \n{\n    // 注意，初始化栈的时候，只要申请pTop就可以了，然后pButton和pTop指向同一块内存区域\n    pStack->pTop = (PNODE)malloc(sizeof(NODE));\n    if (NULL == pStack->pTop)\n    {\n        exit(-1);\n    }\n    pStack->pButton = pStack->pTop;\n    pStack->pTop->pNext = NULL;\n}\n\nvoid push(PSTACK pStack, int iData)\n{\n    PNODE pNew = (PNODE)malloc(sizeof(NODE));\n    if (NULL == pNew)\n    {\n        exit(-1);\n    }\n    pNew->iData = iData;\n    pNew->pNext = NULL;\n\n    pNew->pNext = pStack->pTop;\n    pStack->pTop = pNew;\n    return;\n}\n\nbool isEmpty(PSTACK pStack)\n{\n    if (pStack->pTop == pStack->pButton)\n    {\n        return true;\n    }\n    return false;\n}\n\nbool pop(PSTACK pStack, int* pData)\n{\n    if (isEmpty(pStack))\n    {\n        return false;\n    }\n    PNODE pTemp = pStack->pTop;\n    *pData = pTemp->iData;\n    pStack->pTop = pStack->pTop->pNext;\n    free(pTemp);\n    pTemp = NULL;\n    return true;\n}\n\nvoid traverse(PSTACK pStack)\n{\n    // 从栈顶遍历\n    PNODE pTemp = pStack->pTop;\n    while (pTemp != pStack->pButton)\n    {\n        printf(\"%d\\t\", pTemp->iData);\n        pTemp = pTemp->pNext;\n    }\n    printf(\"\\n\");\n    return;\n}\n\nvoid clear(PSTACK pStack)\n{\n    PNODE pTemp = pStack->pTop;\n    while (pStack->pTop != pStack->pButton)\n    {\n        pTemp = pStack->pTop;\n        pStack->pTop = pStack->pTop->pNext;\n        free(pTemp);\n    }\n    pStack->pTop = pStack->pButton;\n    pTemp = NULL;\n    return;\n}\n```","categories":["数据结构"]},{"title":"数据结构-非循环单链表","url":"/2018/10/05/数据结构-第1章/","content":"这一章是用C语言创建一个简单的非循环单链表，代码如下。尾插法我没有写，因为我没有保存尾指针，实现起来也非常的简单。\n主要的几个难点要理解：\n1.头插法和尾插法都是要<strong>先连接再断</strong>，这个用笔画两下就可以理解，非常简单。\n2.在指定位置插入或者删除的时候，我们找的节点应该是该位置之前的节点。删除之前要用临时指针变量保存避免内存泄漏。\n3.遍历链表没什么好说，这个太简单了。\n4.创建链表的时候，注意给指针域赋值为空，避免野指针。\n5.链表排序的时候，这里用的是冒泡法，首先理解冒泡的原理。每次内层的循环都是确定一个最小或者最大值，这样每次比较完后，最后面的或者最前面的就是最小或者最大值了。\n6.插入数据的时候，建议创建的节点先把数据域赋值和指针域赋值为空，然后再插入。\n下面是代码：\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <malloc.h>\n\ntypedef enum{ false, true } bool;\ntypedef struct NODE\n{\n    int iData;\n    struct NODE* pNext;\n}NODE, *PNODE;\n\nPNODE create(void);\nvoid traverse(PNODE);\nbool insertToHead(PNODE, int);\nbool insertToTail(PNODE);\nbool insert(PNODE, int, int);\nbool delete(PNODE, int, int*);\nbool isEmpty(PNODE);\nint length(PNODE);\nvoid sort(PNODE);\n\nint main(void)\n{\n    PNODE pHead = create();\n    if (isEmpty(pHead))\n    {\n        printf(\"链表为空！\\n\");\n    }\n    else\n    {\n        printf(\"链表不为空！\\n\");\n    }\n    insertToHead(pHead, 16);\n    insertToHead(pHead, 20);\n    insertToHead(pHead, 3);\n    insertToHead(pHead, 9);\n    traverse(pHead);\n    int iLength = length(pHead);\n    printf(\"链表长度为：%d\\n\", iLength);\n    sort(pHead);\n    insert(pHead, 1, 10);\n    traverse(pHead);\n    insert(pHead, 3, 5);\n    traverse(pHead);\n    int iVal;\n    delete(pHead, 4, &amp;iVal);\n    printf(\"删除的元素是：%d\\n\", iVal);\n    traverse(pHead);\n    return 0;\n}\n\nPNODE create(void)\n{\n    PNODE pHead = (PNODE)malloc(sizeof(NODE));\n    if (NULL == pHead)\n    {\n        printf(\"内存分配失败，程序结束！\\n\");\n        exit(-1);\n    }\n    pHead->pNext = NULL;//指针域赋值，不然会成了野指针。数据域可以不存放有效数据\n    return pHead;\n}\n\nbool insertToHead(PNODE pHead, int iData) \n{\n    PNODE pNew = (PNODE)malloc(sizeof(NODE));\n    if (NULL == pNew)\n    {\n        printf(\"内存分配失败，程序结束！\\n\");\n        exit(-1);\n    }\n    pNew->iData = iData;\n    pNew->pNext = NULL;\n\n    // 链表为空直接插入\n    if (isEmpty(pHead))\n    {\n        pHead->pNext = pNew;\n    }\n    else\n    {\n        //插入节点\n        pNew->pNext = pHead->pNext;\n        pHead->pNext = pNew;\n    }\n    return true;\n}\n\nvoid traverse(PNODE pHead)\n{\n    if (isEmpty(pHead)) \n    {\n        return;\n    }\n    PNODE pTemp = pHead->pNext;\n    while (NULL != pTemp)\n    {\n        printf(\"%d\\t\", pTemp->iData);\n        pTemp = pTemp->pNext;\n    }\n    printf(\"\\n\");\n    return;\n}\n\nbool isEmpty(PNODE pHead)\n{\n    if (NULL == pHead->pNext)\n    {\n        return true;\n    }\n    return false;\n}\n\nint length(PNODE pHead)\n{\n    if (isEmpty(pHead))\n    {\n        return 0;\n    }\n    int iLength = 0;\n    PNODE pTemp = pHead->pNext;\n    while (NULL != pTemp)\n    {\n        iLength++;\n        pTemp = pTemp->pNext;\n    }\n    return iLength;\n}\n\n// 冒泡排序\nvoid sort(PNODE pHead)\n{\n    if (isEmpty(pHead))\n    {\n        return;\n    }\n\n    PNODE pTemp; // 用于遍历链表的临时指针遍历\n    PNODE pFor; // 用于循环控制的指针变量\n\n    for (pFor = pHead->pNext; NULL != pFor->pNext; pFor = pFor->pNext)// 外层循环次数，冒泡\n    {\n        for(pTemp = pFor; NULL != pTemp->pNext; pTemp = pTemp->pNext)\n        {\n            if (pTemp->iData > pTemp->pNext->iData)\n            {\n                int iTemp = pTemp->iData;\n                pTemp->iData = pTemp->pNext->iData;\n                pTemp->pNext->iData = iTemp;\n            }\n        }\n    }   \n}\n\n// Pos从1开始\nbool insert(PNODE pHead, int iPos, int iData)\n{\n    int iLength = length(pHead);\n    if (iPos > iLength || iPos < 1)\n    {\n        printf(\"参数不合法，插入失败！\\n\");\n        return false;\n    }\n    PNODE pNew = (PNODE)malloc(sizeof(NODE));\n    if (NULL == pNew)\n    {\n        exit(-1);\n    }\n    pNew->iData = iData;\n    pNew->pNext = NULL;\n\n    PNODE pTemp;\n    if (1 == iPos)\n    {\n        pNew->pNext = pHead->pNext;\n        pHead->pNext = pNew;\n        return true;\n    }\n\n    int i;\n    for (i = 1, pTemp = pHead->pNext; NULL != pTemp; pTemp = pTemp->pNext, i++)\n    {\n        //因为我们是在pos的位置之前插入数据，所以我们找的节点应该是pos之前的节点\n        if (iPos-1 == i) {\n            pNew->pNext = pTemp->pNext;\n            pTemp->pNext = pNew;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool delete(PNODE pHead, int iPos, int* iData)\n{\n    int iLength = length(pHead);\n    if (iPos > iLength || iPos < 1)\n    {\n        printf(\"参数不合法，删除失败！\\n\");\n        return false;\n    }\n    PNODE pTemp;\n    if (1 == iPos)\n    {\n        pTemp = pHead->pNext;\n        pHead->pNext = pHead->pNext->pNext;\n        free(pTemp);\n        pTemp = NULL;\n        return true;\n    }\n\n    int i;\n    PNODE pDeleteNode;\n    for (i = 1, pTemp = pHead->pNext; NULL != pTemp; pTemp = pTemp->pNext, i++)\n    {\n        // 找到要删除的节点之前的节点\n        if (iPos - 1 == i) {\n            pDeleteNode = pTemp->pNext;// 保存要删除的节点\n            *iData = pDeleteNode->iData;\n            pTemp->pNext = pTemp->pNext->pNext;\n            free(pDeleteNode);\n            pDeleteNode = NULL;\n            pTemp = NULL;\n            return true;\n        }\n    }\n    return false;\n}\n```","categories":["数据结构"]},{"title":"数据结构-数组与链表","url":"/2018/10/04/数据结构-第0章/","content":"首先祝大家国庆假期愉快！在假期间，我列了我几个计划：一个就是继续看数据结构，另一个就是打算重新学习英语，了解外国的语言思维。\n\n在编程的学习过程中，有一门很重要的课程，那就是数据结构。我觉得这是我们学习编程的基础之一，但是现在随着IT技术的发展，编程技术也在一步步的发展，由原来的机器语言到汇编，再到高级语言可以说是一个非常大的变化，可能以后人人都会编程，而这些可能也越来越少人知道。但是至少在我现在还是要知道这些，数据结构在我开始学的时候非常头疼，因为你好像听懂了明白了也在纸上画出来了，但是自己又写的不完整。原因在于你还没有这种设计思维，考虑的没有这么多，而这些都是靠积累而来。所以慢慢来。\n\n数据结构如果你搜索网上的定义，会说的非常复杂。而我个人觉得其实数据结构就是研究数据元素之间的联系。而联系又分为一对一，一对多，多对一，多对一。这就是我们后来说的链表，树，图。\n\n<h3>数组和链表</h3>\n\n学习数据结构，首先要了解的就是数组和链表，这是我们学习的基础。比如我们在Java中学习的ArrayList本质上就是数组，HashTable本质上就是链表，只不过别人已经写好了相应的方法。\n\n关于数组和链表的区别也是一个非常经典的问题。数组的存储是地址是连续的，因此查询的时候通过地址偏移很快就能找到该值，但是当要删除或者插入的时候，需要对地址进行移动效率就低于链表了。而链表只能通过一个节点找到下一个节点，因此查询的效率比较慢。而如果要删除或者插入的时候只需要重新指向就可以了，效率非常的高。\n\n而对于(离散存储)链表：链表的存储地址就不要求是连续的了，而是通过指针(地址)相连，就是在存储数据的时候里面存一个地址。每一个首节点都有唯一的前驱节点和唯一的后续节点。首节点没有前驱节点，尾节点没有后续节点。\n\n<h3>自定义实现集合</h3>\n\n下面是简单模仿集合的一个实现过程，进而更深的理解。就拿ArrayList好了。下面写的纯属瞎玩，代码要保证鲁棒性需要考虑的东西还很多，下面只是简单的实现一些方法。\n<strong>注意：在ArrayList中可以一直添加，这里呢就限制一下，初始化的时候限制长度，但是要实现也是可以的，当要添加的时候判断是否为满，如果满了而扩充数组的长度，而这个长度我们称之为增长因子。因为我们不可能频繁的扩充，而是一次性的扩充一部分</strong>\n1.数组的定义\n```c\ntypedef struct ListStruct\n{\n    int* pBase; // 数据域，数组的首地址\n    int iLength; // 数组的长度\n    int iCurrentNum; // 当前元素有效的个数\n}List, *ListNode;\n```\n\n2.数组初始化\n```c\nvoid init(ListNode pArray, int iLength)\n{\n    pArray->pBase = (int *)malloc(sizeof(List));\n    if (NULL == pArray->pBase)\n    {\n        printf(\"数组初始化失败！\\n\");\n        exit(-1);\n    }\n    pArray->iLength = iLength;\n    pArray->iCurrentNum = 0;\n    return;\n}\n```\n\n当我们在new一个集合的时候，就是创建并初始化的过程，只不过我们这里是要确定一个数组的长度。我们结构体存储的是数组的首地址，<strong>当我们试图要访问一个越界的下标的时候，编译器往往提示我们索引超出了，这里也可以自己判断。如果超出的话系统会随机分配一个值，而这个值不是我们能掌控当然也没有意义了。</strong>\n\n当创建好了之后，我们就需要往里面添加元素了。\n3.数组的添加和插入\n```c\nbool append(ListNode pArray, int iVal)\n{\n    if (isFull(pArray))\n    {\n        return false;\n    }\n    // 添加元素\n    (pArray->iCurrentNum)++;\n    pArray->pBase[pArray->iCurrentNum-1] = iVal;\n    return true;\n}\n\nbool insert(ListNode pArray, int iPost, int iVal)\n{\n    if (iPost < 1 || iPost > pArray->iLength+1)\n    {\n        printf(\"插入的位置不合法！\\n\");\n        return false;\n    }\n    if (isFull(pArray))\n    {\n        return false;\n    }\n    // 因为是在指定的位置插入，因此post位置的元素就是插入的值了，其他的元素往后移动\n    (pArray->iCurrentNum)++; // 先增长数组\n    for (int i = pArray->iCurrentNum - 1; i >= iPost; i--)\n    {\n        pArray->pBase[i] = pArray->pBase[i - 1];\n    }\n    pArray->pBase[iPost - 1] = iVal;\n}\n```\n\n4.接下来是删除\n```c\nbool delete(ListNode pArray, int iPost, int* pVal)\n{\n    if (iPost < 1 || iPost > pArray->iLength)\n    {\n        printf(\"删除的位置不合法！\\n\");\n        return false;\n    }\n    if (isEmpty(pArray))\n    {\n        printf(\"数组为空!\\n\");\n        return;\n    }\n    *pVal = pArray->pBase[iPost - 1];\n    for (int i = iPost; i < pArray->iCurrentNum; i++)\n    {\n        pArray->pBase[i-1] = pArray->pBase[i];\n    }\n    (pArray->iCurrentNum)--;\n    return true;\n}\n```\n\n5.查询指定位置的元素\n```c\nint get(ListNode pArray, int iPost)\n{\n    if (iPost < 1 || iPost > pArray->iLength)\n    {\n        printf(\"查找的位置不合法！\\n\");\n        return -1;\n    }\n    return pArray->pBase[iPost-1];\n}\n```\n\n还有好多方法都可以通过自己定义去实现，你可以发现里面很多操作都是和数组的操作差不多，这也说明了<strong>我们的函数在使用数组作为参数的时候，其实传的就是我们首元素的首地址，而[]是我们下标运算符</strong>.可以看到有些人写代码是下面这样的，也就不难理解了。\n```c\n方法一：\nvoid AddStuMSGToLinkHead(char* arrStuNum, char* arrStuName, int iStuScore)\n方式二：\nvoid AddStuMSGToLinkHead(char arrStuNum[20], char arrStuName[20], int iStuScore)\n```\n\n当数组作为函数参数的时候，其实是作为指针传过来。因为数组的地址是连续的，我们只要把首元素的首地址传过来就行了，这样节省了很多传输消耗。\n\n<h3>链表</h3>\n\n和数组不同的是，链表定义的时候我们需要定义一个和<strong>当前数据类型一样</strong>的指针变量，这个变量指向我们下一个数据的地址。这样我们就通过指针把数据元素联系起来了。我觉得要理解链表首先就要理解其的本质思想：通过指针联系。一个是节点保存有我们的数据，而另一个是指针域存放的是我们的地址。数据域和指针域一定要分清楚。\n```c\ntypedef struct NODE{\n    int data; //数据域\n    struct NODE* pNext;//指针域\n}Node, *pNode;\n```\n\n<h3>认识几个专有名词</h3>\n\n之前我一直以为首节点就是头节点，后面才发现是我搞错了，<strong>头节点其实是首节点前面的节点</strong>\n首节点：第一个有效节点，这个有效定义是说存放有一些有效数据。\n尾节点：最后一个有效节点，同上。\n头节点：第一个有效的节点之前的节点也就是首节点前面的节点，一般来说并不存储数据，这是和首节点的区别。头节点的目的在于<strong>便于通过头指针对链表进行操作</strong>\n头指针：指向头节点的指针\n尾指针：指向尾节点的指针\n\n当我们要对链表进行操作的时候，我们往往是通过头指针去操作。\n\n<h3>链表的分类</h3>\n\n链表其实就是通过指针指向相同的数据类型联系起来，这样好玩的地方就很多了，我们就可以把生活中很多东西联系起来了，比如人与人之间的关系，就像是一个多重指针域，我认识他，也认识她，而她认识她，我就可以通过她去认识她。我们把链表进行分类一下，分为：\n单链表，双链表：单链表也就是每个节点只有一个指针域，而双链表是每个节点有两个指针域，我们可以指向前一个，也可以指向下一个。\n循环链表，非循环链表：如果是循环链表我们可以通过一个节点找到其他的所有节点，就是形成一个环嘛，非循环链表反之。\n\n现在仔细想一下，数组和链表设计真的很棒，能够把我们生活中的很多东西表示出来，把很多问题都交给计算机去处理，大大方便了我们的生活，所以我们处在科技发展的年代真的非常不错啊。链表的东西还有很多，下一次我们再研究吧。国庆假期愉快！","categories":["数据结构"]},{"title":"C语言编程-命令行参数","url":"/2018/09/15/C语言编程-第9章/","content":"<h3>第九章 标准的C语言主函数和命令行参数</h3>\n\n在网上有很多种C语言主函数的写法，虽然有些运行起来并没有什么错误。但是在C99标准后，在标准的C语言主函数中，只有两种形式，我们应该尽量去遵守标准避免不必要的错误，形式如下：\n```c\nint main(void)\n{\n\n}\n\nint main(int argc, char* argv[])\n{\n}\n```\n\n<h3>为什么要加void的？</h3>\n\n有些教程是不加void的，但是在C语言里面对于参数列表<strong>为空</strong>的时候<strong>，C语言表示这个函数可以传任意参数。而C++表示这个函数没有参数，</strong>所以注意<strong>C语言中没有参数的时候要加void。</strong>\n\n那今天就来说一下这个命令行参数的标准主函数，对于一个函数，我们可以从函数名和参数去了解该函数的作用。那首先我们来看看这两个参数表示什么。\n\n<h3>参数意义</h3>\n\nargc：是命令行总的参数个数。\nargv[]：是argc个参数，也就是说argv数组的长度就是argc。<strong>其中第0个参数是程序的全名</strong>\n<strong>argc: argument counter</strong>\n<strong>argv: argument vector</strong>\n\n当我们在Visual Studio中点击开始执行的时候，Visual Studio就会帮我们运行程序。这个过程，其实就是运行了可执行程序。Visual Studio会通过自己的方式，找到程序的路径，然后运行。比如我们在linux的Terminal中打开vim就直接输入vim了。在windows中我们要运行程序，也可以在终端里找到程序的路径然后回车执行。比如：\n```\nC:\\Users\\xxxxx>C:\\Software\\MarkdownEditor.exe\n```\n\n<strong>这里的命令行参数指的就是我们在Terminal输入的命令。</strong>\n\n其中，这里第0个参数默认是程序的全路径。我们可以打印出来看看。\n```\n    printf(\"%d\\n\", argc);  // 结果：1\n\n    for (int i = 0; i \n    \n    \n     argc; i++)\n    {\n        printf(\"%s\\n\", argv[i]);\n    }\n    //结果：E:\\XXXXX\\CLearn\\x64\\Debug\\CLearn.exe\n```\n\n如果要传入更多的命令参数，我们也可以自己在Visual Studio设置，项目属性-调试-命令参数\n```\n\"command1\" \"command2\" \"command3\"\n```","categories":["C语言编程"]},{"title":"C语言编程-大端模式和小端模式与预处理和宏定义","url":"/2018/09/14/C语言编程-第8章/","content":"第八章 大端模式和小端模式与宏\n\n<h3>了解什么是大小端</h3>\n\n我们知道C语言中char存储是1个字节，int是4个字节。但是在计算机中，我们每个地址单元都对应一个字节。那这个时候就有一个多个字节如何存储的问题。\n\n<h3>高数据位-低数据位-高地址位-低地址位</h3>\n\n高数据位，低数据位：0000 0000 0001 0011。左是高数据位，右是低数据位。\n高地址位，低地址位：比如一个四字节内存0x10 0x20 0x30 0x40。左是低地址位，右是高地址位。\n\n<h3>大小端</h3>\n\n大小端其实就是系统对数据在内存中的存储规则。因此我们的数据分为两种方式存储。\n大端模式（Big-endian）存储：数据的低数据位 放在 内存的高地址位。这和我们的阅读习惯一样。\n小端模式（Little-endian）存储： 数据的低数据位 放在 内存的低地址位。\n\n作用：在两个机器A和机器B如果要进行通信的话，那么我们就必须保证它们的存储方式是一致的。这个时候如果不一致的话就要进行转换。<strong>这里是按字节反转，而不是按位反转。</strong>\n\n<h3>测试大小端</h3>\n\n那接下来我们就进行测试，如何测试呢？那就是打印每个字节呗，这时候我们就想到了union了，里面的每一个变量的地址是一样的。\n```c\nint main(void)\n{\n    // 测试大端存储和小端存储。\n    // 思路：测试第一个字节的值.使用联合体\n\n    union MyUnion\n    {\n        int i;\n        char ch;\n    } u = {0x123456};\n\n    printf(\"%x\\n\", u.ch); // 结果：56 // 说明该系统采用的小端存储。 x86\n```\n\n分析：int是四个字节，当转为char的时候就会舍弃三个字节，那么这个时候我们就可以看到低地址位的数据到底是什么。结果是56,说明了我们的低地址位存储的是低数据位。\n\n目前Intel的80x86系列芯片是唯一还在坚持使用小端的芯片，ARM芯片默认采用小端，但可以切换为大端；而MIPS等芯片要么采用全部大端的方式储存，要么提供选项支持大端——可以在大小端之间切换。另外，对于大小端的处理也和编译器的实现有关，在C语言中，默认是小端（但在一些对于单片机的实现中却是基于大端，比如Keil 51C），Java是平台无关的，默认是大端。在网络上传输数据普遍采用的都是大端。\n\n其实我们不用union也可以测试，原理也是通上面分析的一样,通过类型的转换打印出首地址。当一个字节存储的时候就没有大小端的说法了。\n```c\nint i = 0x123456;\nchar ch = i;\nprintf(\"%x\\n\", ch);\n```\n\n<h3>大端模式和小端模式的交换</h3>\n\n转换的思想就是前后交换，那首先我们看下代码。\n```c\n#define uint32 unsigned int\n#define Tranverse32(X) ((((uint32)(X) &amp; 0xff000000) >> 24) | \\\n                          (((uint32)(X) &amp; 0x00ff0000) >> 8) | \\\n                          (((uint32)(X) &amp; 0x0000ff00) << 8) | \\\n                          (((uint32)(X) &amp; 0x000000ff) << 24))\n测试\n    uint32 i = 0x123456; \n    i = Tranverse32(i);\n    printf(\"%x\\n\", i); // 结果563412\n```\n\n解释：这里测试的4个字节的存储，也就是32位。从结果来看，说明已经交换了。<strong>注意是按字节反转，而不是得到0x65432100</strong>。需要注意的是，我们这里使用的宏定义，那变量需要括起来，然后整体再需要括起来，所以每个括号都是有意义的。\n\n那开始分析，这其实不难理解，主要是写的时候注意宏的要点，下面会介绍宏。(uint32)(X) &amp; 0xff000000)得到的就是第一个字节的值，然后移24位就是变成了\n<strong>0x000000第一个字节</strong>，以此类推。这里主要是使用&amp;来得到每个字节的值然后再通过位移符号，最后通过|符号合并。\n\n<h3>预处理</h3>\n\n和其他高级语言不同的一点，C语言具有预处理和使用预处理的功能。\n预处理程序，比如：宏定义，条件编译等。\n作用：预处理功能便于程序的修改，阅读，移植和调试。也便于实现模块化程序设计。\n\n<h3>宏</h3>\n\n宏定义指令#define用于定义一个标识符替换一串字符(可以是常数，表达式，你可以大胆测试)，编译器遇到时自动替换。\n<strong>作用：单纯的替换</strong>\n使用的地方： 多次使用的东西。增加代码的扩展性。\n注意：只替换一行的东西，多行需要加\"&#92;\"，它不同于定于变量，不需要分配空间。\n示例：\n```c\n#define DEF_NOE 1; // 预编译期  编译器\n#define DEF_INT int; //   预编译期时候， 单纯的替换\n```\n\n深入理解宏是单纯替换的，测试\n```c\n#define DEF_ADD(x,y) x+y;\nint a = DEF_ADD(3, 3);// 区别函数原型，没有类型\n\n#define DEF_MUL(x,y) x*y;\nint b = DEF_MUL(3+2, 3+4);// 13    3+2*3+4 = 13\n更加证明是单纯的替换。 因此需要给参数加括号，整体加一个括号，#define DEF_MUL(x,y) （(x)*(y));\n```\n\n<strong>需要给参数加括号，整体加一个括号</strong>\n\n<h3>#include指令</h3>\n\n这在我们写程序的时候第一行就是写这个，作用是用来将另一个源文件的内容全部引进来，就是替换。因为我们的程序不可能都写在一个源文件中，要进行模块化的话就需要多个文件分类了。\n\n#include指令经常用来包含的是我们的头文件，也就是形如\".h\"的文件。所以在这里你应该对下面的代码有了很了更多的理解。\n```c\n#include <stdio.h>\n#include <stdlib.h>\n```\n\n<h3>条件编译</h3>\n\n上面我们也说了宏替换，也就是单纯的替换。但是有个要注意的问题，那就是如果我们在包含另一个文件的时候，如果重复包含会怎么样？那当然就会重复定义了。所以有了条件编译，防止我们多次包含的时候出错。常用的有下面几种:\n```c\n#if\n#engif\n\n#ifdef\n#ifndef\n#endif\n\n#undef\n```\n\n#pragma:设定编译器的状态，或者指示编译器完成一些特定的动作。","categories":["C语言编程"]},{"title":"C语言编程-头文件和结构体的研究","url":"/2018/09/13/C语言编程-第7章/","content":"第七章 头文件和结构体的研究\n\n<h3>头文件</h3>\n\n我们在写程序的时候，不可能把所有的东西都写在一个文件里。这时候我们就需要多个文件进行分类，相当于这里是我们的数学，这里是语文，这里是英语。如果我们把函数放在不同的文件中，就可以大大增加程序的可读性了。\n创建自己的头文件的步骤：\n1.编写test.h头文件，里面放函数声明。避免重复定义，需要用到#ifndef。\n```c\n#ifndef _FUN_H\n#define _FUN_H\nvoid fun(void);\n#endif\n```\n\n1.编写test.c源文件，里面写函数的定义。\n```c\n#include \"test.h\"\nvoid fun(void)\n{\n    printf(\"自定义头文件测试.\\n\");\n}\n```\n\n3.引用头文件\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include \"test.h\"\n\nint main(void)\n...省略\n```\n\n<h3><> 和 \"\" 的区别</h3>\n\n这个问题大家想必也经常见到，其实就是一个搜索时候路径的问题。那它们区别我也不多说了，看下面吧。\n1. <>包含系统文件的， \"\"是包含我们自己写的头文件。\n2. <>作用是告诉编译器去系统目录查找改头文件。（编译器安装的地方）\n3. \"\"作用是告诉编译器去当前目录去找，如果没找到，则去编译器安装的环境。\n\n<h3>问题：函数怎么和头文件的函数联系在一起？</h3>\n\n同一工程下的所有文件，编译的时候所有文件都会编译。当编译的时候，编译器看到这函数名的时候，\n函数名对应的函数地址，编译器就会去内存这个地址找到指令。 其实是通过地址关联的，同一个函数名对应同一个地址。\n\n<h3>typedef</h3>\n\n就是定义别名，下面这种操作真的是骚的不行，暂时不知道有没有下面这种使用的地方。\n```c\ntypedef int i1;\ntypedef i1 i2;\n```\n\n<h3>结构体</h3>\n\n说到结构体，我就很容易想到类。因为无论是数组还是基本数据类型，描述的变量都只能表示一种类型，但是很多时候我们都需要用一个变量却能表示多种类型。那么这个实现，就是靠我们的结构体了。\n```c\nstruct STUDENT\n{\n    char name[10]; // 成员\n    char sex;\n    int age;\n    int* score;\n}; \n```\n\n我记得第一次学的时候，那时候很搞笑，我一直搞不懂为什么有时候分号前加变量有时候有不加。后来我再回去看的时候，哎呀，太蠢了我。这不就是<strong>相当于声明了一个类型</strong>吗。\n就是类似于int。 如果按照下面这样写你是不是理解就好多了呢。\n```c\nstruct STUDENT{char name[10];char sex;};\nstruct STUDENT{char name[10];char sex;} stu;\n```\n\n<strong>我们在结构体中可以放置不同的类型，那这个时候我也会想，像Java中或者其他面向对象编程的语言中。一个类有成员变量和成员函数，那么结构体是否也可以呢？</strong>\n答案是：可以的。\n实现的原理很简单，我们知道函数名就是函数的地址，那么这时候如果我们的结构体中的成员是<strong>函数指针类型</strong>就可以用来调用函数了。\n注意哦这是指针，就是用来装地址的。我们还记得数组指针吗，写法是怎么样的呢？回忆一下，是int (&#42;p)[5]，那么这个函数指针我们就可以推断出来了。\n```\n    首先是指针类型，那就是 *p, 我们假定是int类型的指针，那就是 int *p。\n    下一步是什么，接着这是一个函数，那函数是怎么表示的。假如我们声明了一个函数如下：\n    void fun()\n    {\n\n    }\n    那这个时候函数指针就是int (*p)()了。\n```\n\n下面我们通过在结构体中声明一个函数指针类型来实现，结构体成员包含函数的功能。\n```c\n    struct NODE\n    {\n        int(*p)(); // 函数指针\n    };\n    struct NODE node = { fun };\n    node.p(); // 调用函数\n```\n\n这个时候，我们不得不佩服一下C语言的作者，这种设计真的很厉害。\n\n<h3>结构体嵌套</h3>\n\n在我们使用函数的时候或者流程控制语句的时候，我们就经常使用嵌套的思想，那么这里是否可以呢？当然是可以的。\n```c\nstruct NODE\n{\n    int n;\n    struct SMALL sma;\n};\nstruct SMALL\n{\n    int n;\n};\n```\n\n说到嵌套，我就想起了递归，就是自己调用自己，这个类似于循环的思想，反复执行代码块。<strong>那么嵌套自己是否可以呢？</strong>\n答案是：可以的。\n```c\nstruct NODE1\n{\n    int n;\n    // struct NODE1 nod;  // 错误(活动) E0070   不允许使用不完整的类型。\n    什么是不完整的类型？其实就是说明我们的结构体还没有分配空间。不知道分配多少空间\n\n    //解决方法\n    struct NODE1* pNod; // \n};\n```\n\n<strong>我们发现，如果是直接在里面声明一个结构体类型是不行的，但是声明一个结构体指针类型就可以，为什么会换成指针类型就可以了呢？</strong>\n接下来我们就更加深入的去了解指针吧。首先指针是一种类型，指针变量是用于存储地址的，而这个时候不同数据类型决定了访问空间的形式不同，\n换句话来说，<strong>在声明一个指针的时候我们需要指定指针的类型(这句话是我说的，可能有误)，比如int类型，double类型</strong>\n```\n    你看我们都是\n    int* p;\n    double* d;\n    却从来没有说:\n    * p;\n```\n\n所有当我们声明一个结构体的时候，如果是指针类型的成员，我们就知道了这个成员是表示什么类型的指针，而指针的大小是固定的，之前我们也用sizeof()函数测试了不同类型的指针变量。而如果是直接声明的话编译器就会一直找啊找啊，你这个是什么类型啊，我该给多少空间啊。\n\n这个其实就是我们的链表原理，以后再详细说。\n\n<h3>结构体的大小，结构体的存储方式</h3>\n\n首先我们声明一个结构体，然后用sizeof函数打印一下结构体的大小。\n```c\nstruct NODE2\n{\n    char ch; // 1\n    short sh; // 2\n    int in; //4\n    float fl; //4\n    double db; //8\n    char arr[9]; //9\n};\n```\n\n如果我们猜结果是28那就错了，<strong>结果竟然是40。</strong>\n这个是怎么来的呢？这就涉及到影响结构体的存储的因素了。\n<strong>结构体的大小，不仅与成员大小有关，还和内存对齐有关，默认是根据我们结构体最大成员类型对齐（最大的基本数据类型）</strong>\n\n每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。程序员可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。如果我们指定的n超过了默认的最大成员类型，其实是没有效果的，可以自己测试一下。\n内存对齐作用：每个数据单元安排在适当的位置，增快内存数据的读取效率。\n\n<a href=\"https://i.loli.net/2018/09/16/5b9dd4232b0e9.png\"><img src=\"https://i.loli.net/2018/09/16/5b9dd4232b0e9.png\" alt=\"\" /></a>\n\n<h3>union</h3>\n\n联合的大小也是和内存对齐有关，跟最大的基本类型有关.\n用法： 联合体只允许初始化一个成员。\n联合体的存储：所有成员公用一块地址。\n<strong>说明所有成员的地址是一样的。测试：打印所有成员的地址</strong>\n用法： 联合体只允许初始化一个成员。默认是第一个。\n编程建议： 初始化最大空间的成员，把最大空间成员放第一个\n赋值也会覆盖. --跟最新的赋值有关\n\n<h3>成员选择符->和.的区别</h3>\n\n在结构体中，我们会经常见到这两个符号。\n点运算符在C语言中也叫<strong>成员选择(对象)符</strong>，那么当结构体类型的变量如果是一个对象的时候，我们就用.\n\n->叫做<strong>成员选择(指针)符</strong>，当结构体类型的变量如果是一个指针类型的时候就可以用它了。\n\n<h3>枚举类型</h3>\n\n作用： 增加程序的可读性。\n枚举类型的大小：4字节。\n我们可以直接使用枚举类型。相当于给整型常量取别名，默认从0开始。\n```c\nenum COLOR\n{\n    black, red, white, blue\n    // 成员是一些有意义的字符串\n    // 我们可以自己指定\n    , gray = 14\n    // 0，1，2\n};\n```","categories":["C语言编程"]},{"title":"C语言-变量和关键字","url":"/2018/09/12/C语言编程-第6章/","content":"<h3>第六章 变量和关键字</h3>\n\n在编程中我们要经常用到的就是变量，而变量如果不小心使用很可能给我们带来非常大的麻烦。我们这次研究的是变量和被C语言中一些关键字修饰的变量，看看这些有什么作用。要深入理解一个变量，我们就要从三个方面了解它：<strong>存储位置，作用域，生命周期</strong>。请记住，当你要学一个东西从这三个方面去研究能够帮助你更好的理解。比如：我在Java学习中，其中的cookie和session的生命周期就是一个非常关键的地方，这也是决定了我们应该怎么使用。\n\n所以我们研究的目的，是为了更好的使用。\n\n<h3>auto自动变量</h3>\n\n存储位置： 栈区--空间由系统自动分配和释放\n作用域：局部变量\n生命周期：有效时间所在的{}\n\n<h3>全局变量</h3>\n\n存储位置： 静态存储区\n作用域：在函数外\n生命周期：\n注意： 全局变量系统自动初始化为0，建议手动。\n\n<h3>const修饰符</h3>\n\n类型修饰符：const 常量修饰符。\n使用地方：const的使用， 可读不可改。\n注意：const修饰的必须是个常量。\n```c\n//const int a;\n    //a = 12; //错误(活动)  E0137   表达式必须是可修改的左值.\n    // 说明a是一个常量\n    // const int a = 12; // 合法\n    // const int arr[2] = {12, 2}; // 合法\n```\n\n<strong>那么如果const修饰的是一个指针会怎么样呢？我们来研究一下const int&#42; p 和 int&#42; const 的区别</strong>\n```c\n    //int a = 12;\n    //int b = 13;\n    //int* const p = &amp;a;\n    //*p = 32;  // 合法\n    //p = &amp;b; // 错误\n\n    //int a = 12;\n    //int b = 13;\n    //const int* p = &amp;a;\n    //*p = 32;  // 错误\n    //p = &amp;b; // 合法\n\n    //const修饰指针\n    // 1.右侧*p，*p常量， p非常量                const int* p = &amp;a;\n    // 2.在*p之间，*p可以修改，p不可以修改。      int* const p = &amp;a;\n    总结：修饰的是谁，谁就不可以修改，否则报错。修饰的是*p则*p不可以被修改，\n                                            修饰的是p则p不可以被修改。\n```\n\n<h3>static静态变量</h3>\n\n存储： 静态存储区，全局变量也是\n生命周期： 与程序共存亡\n作用域： 局部变量。可以从存储的位置不同去理解。\n初始化，要用常量，不能用变量。\n\n<strong>注意1：static的生命周期是与程序共存亡</strong>\n我们来测试一下\n```c\nvoid fun1()\n{\n    // 每次执行后不释放，与程序共存亡\n    static int d = 12;\n    d += 1;\n    printf(\"%d\\n\", d);\n}\nvoid fun2()\n{\n    // 每次执行完释放\n    int d = 12;\n    d += 1;\n    printf(\"%d\\n\", d);\n}\n我们通过多次调用函数来看看里面的变量的值\n//  fun1();\n//  fun1();\n//  fun1();\n//  fun2();\n//  fun2();\n//  fun2();\n//  //结果：\n//  //  13\n//  //  14\n//  //  15\n//  //  13\n//  //  13\n//  //  13\n```\n\n我们在书上也可能会经常看到这个东西，那时候我还不太理解，后来对生命周期理解更深的时候，慢慢就理解。<strong>static在编译的时候分配空间，而auto自动变量在程序运行的时候。</strong>\n\n<strong>我们来测试一下：static在编译的时候分配空间，而auto自动变量在程序运行的时候</strong>\n```\n    int b = 12;\n    static int c = b; // 错误 初始化，要用常量，不能用变量。\n    解释： 报错的结果的告诉了我们，b还没有分配，也就是没有值，我们可以通过debug的时候\n    测试一下，看看没有运行到语句的时候，c和b的值，你很快就会恍然大悟了。因此，我们不能\n    把b的值赋给c。\n```","categories":["C语言编程"]},{"title":"C语言编程-函数和函数指针","url":"/2018/09/11/C语言编程-第5章/","content":"<h3>第五章-函数和函数指针</h3>\n\n这里的函数跟数学中的函数很像，比如x+y = z。那么这里x和y就相当于函数的形参，z就相当于我们的返回值。\n\n<h3>无参无返回函数</h3>\n\n在标准C语言中，函数没参数要写个void。void表示不支持任何类型参数，没写代表参数不确定。\n\n<h3>函数名就是函数的地址</h3>\n\n我们知道数组名其实就是数组的首元素的首地址，其实这里函数名也是一样。那么我们怎么测试呢？可以看看下面，我也是后来才知道原来函数还有这么多好玩的东西。\n```c\n//int* fun(char ch, long* lg);\n//int main(void)\n//{\n//  // 函数指针\n//   int* (*p)(char, long*) = fun == &amp;fun; // 函数名就是函数的地址\n//   p('a', NULL); // 我们就可以这样直接调用函数了。\n//\n//  system(\"pause\");\n//  return 0;\n//}\n```\n\n<h3>传值和传地址</h3>\n\n<strong>传值</strong>\n```c\n    // 传值\n    void Exchange1(int a, int b)\n    {\n        // 这里传入的是实参的值，那这里a变量装的就是值，我们操作是形参。\n        int temp;\n        temp = a;\n        a = b;\n        b = temp;\n        printf(\"函数里传值后：%d, %d\\n\", a, b);\n        printf(\"函数里传值后：%p, %p\\n\", &amp;a, &amp;b);\n    }\n```\n\n<strong>传地址</strong>\n```c\n// 传地址\nvoid Exchange2(int* a, int* b)\n{\n    // 这里传入的是实参的地址，那这里a变量装的是地址，我们通过形参间接操作实参。\n    int temp;\n    temp = *a;\n    *a = *b;\n    *b = temp;\n    printf(\"函数里传址后：%p, %p\\n\", a, b);\n    printf(\"函数里传址后：%d, %d\\n\", *a, *b);\n    printf(\"函数里传址后：%p, %p\\n\", &amp;a, &amp;b); \n}\n```\n\n<img src=\"https://i.loli.net/2018/09/15/5b9c8d830a35e.png\" alt=\"\" />\n形参和实参：\n1.形参在函数未调用时是不占用内存中的存储单元的。<strong>只有在发生调用函数时，函数的形参才被分配内存单元，函数结束后形参所占的内存单元会被释放</strong>\n2.在函数调用时，会将实参的值赋给形参。\n3.实参与形参类型应相同。\n4.实参与参数之间是单项传递，只能由实参传递给形参，而不能由形参传回来给实参。\n\n<h3>return的意义</h3>\n\n<ol>\n<li>返回数据类型</li>\n<li>结束所在函数\n我记得有个问题是如何结束一个多层循环，那么有时候我们就可以通过return结束函数来结束多层循环，这里有很多方法，我们到时就按照自己的需求来用。比如：还可以用标签，goto这些，或者设置一个flag在循环的控制条件里。</li>\n</ol>","categories":["C语言编程"]},{"title":"C语言编程-指针的大小和堆栈和堆","url":"/2018/09/09/C语言编程-第4章/","content":"<h3>第四章-指针的大小和堆栈和栈</h3>\n\n<h3>指针的大小研究</h3>\n\n32为系统最大支持4字节指针，64为系统最大支持8字节指针\n Q:\n程序的位数是由什么决定的？\nA:\n指针也就是我们的地址，这个由开发环境(编译器)决定，区别于基本数据类型的存储大小。<strong>你想一个是要表示我们的数据大小，而另一个是要表示我们的地址大小，或者说指针大小。</strong>我们可以测试一下。\n```\n//  // 32bit程序\n    //  int a = 12;\n    //  int *p = &amp;a;\n    //  printf(\"%d， %d\\n\", sizeof(p), sizeof(int*)); // 结果：4， 4     \n    //  double a1 = 12;\n    //  double *p1 = &amp;a1;\n    //  printf(\"%d, %d\\n\", sizeof(p1), sizeof(double*)); // 结果：4，4     \n    //\n    //  printf(\"%d, %d\\n\", sizeof(int(*)[1]), sizeof(int(*)[2][3])); // 结果：4，4  \n```\n\n<h3>栈区和堆区</h3>\n\n在C语言中，对数据的存储是分为几块的：\n```\n//      栈区，以前堆栈的说法就是指内存的栈区，也叫系统栈。   堆栈 == 栈               stack overflow爆栈\n    //      堆区：特点：由我们随时申请，由我们自己随时释放。实际上会限制我们使用大小，堆保留大小：默认值是1MB。虚拟内存中堆分配的大小是可以自己设置的。\n    //      全局区(静态存储区)\n    //      字符常量区\n    //      代码区\n```\n\n我们也经常开玩笑，开完会之后Java程序员经常是直接就走了，而C程序员还要留下了打扫，说的就是对内存的管理。在Java中只不过把对内存的管理交给了GC(垃圾回收机制)来管理，如果你去研究的话，Java中也会把变量存储在不同的地方，也有堆栈，堆，静态区这种概念，原理其实也是一样的，只是一个要自己管理，一个不用我们自己管理。\n\n栈区的空间就是由系统分配的，程序运行——>操作系统统一>调配——>程序结束——>释放资源——>如果不释放资源则其他无法使用。在运行中的多个程序之间，内存是不交叉的。\n\n那么我们就会有一个需求，我们想自己选择释放，自己申请空间管理。\n思考：如果我们申请空间，不是操作系统管理，而是自己管理(申请与释放)，那么就不会占用系统的额外资源了。\n\n<strong>那我们就会关心我们那最多可以申请多少空间呢？这其实是由我们的编译器决定的。</strong>\n```\n    // 32位程序\n    // int a[1000000000000000000]；\n    // 错误   C2148   数组的总大小不得超过 0x7fffffff 字节。 \n    // 错误   C1126   自动分配超过 2G   \n    // 0x7fffffff ==  2,147,483,647字节 == 1024*1024*1024*2字节(2^31-1) == 2GB \n    //int a[INT_MAX/6]; // 理论上我们32位操作系统可申请用的的内存是4GB，但是有2GB是操作系统使用的，\n                         所以理论上可以申请2GB的空间， 实际测试我们无法申请2GB的空间，因为系统也运行着其他程序，每一个程序都占用一定的内存空间。\n    //printf(\"%d\", INT_MAX);\n```\n\n<strong>但是要注意的是：必须是连续的一段空间，如果有10字节的连续空间，但是要申请连续20字节的连续空间是申请不到的。</strong>\n当我们申请为空或者申请的空间不够怎么办，这个时候就要注意了。\nmalloc returns a void pointer to the allocated space, or NULL if there is insufficient memory available. \nTo return a pointer to a type other than void, use a type cast on the return value。\n\n因此我们申请空间使用之前需要判断是否为空再继续执行下面代码，如果都申请不成功我们就无法使用了。这也是我们经常看到别人代码这样写的原因。\n```\nif (NULL == p2)\n    {\n    }\n```\n\n<strong>如果不使用了则应当释放掉</strong>\n解释：释放之后就恢复初始值了\n```\n    //int* p = (int*)malloc(4);\n    //*p = 12;\n    //printf(\"%d, %p\\n\", *p, p);\n    //free(p);\n    //p = NULL;\n    //printf(\"测试:%d, %p\\n\", *p, p); // 没有具体指向的指针，叫做野指针，这个东西不能直接使用，没有访问权限。因此这里是不会打印的\n    // 野指针： 没有具体指向的指针。比如未初始化的指针，free掉的。\n```\n\n释放的时候一定是释放头指针。不能重复释放同一块空间。 释放之后就没有访问权限了。不能释放栈区空间(栈区间是由操作系统控制的)。\n\n<h3>malloc和free函数</h3>\n\n这两个函数是C语言中申请内存空间和释放的函数。\n内存的分配和释放: malloc free\nmalloc的全称是memory allocation，中文叫动态内存分配，用于申请一块连续的指定大小的内存块区域以void&#42;类型返回分配的内存区域地址，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存。void&#42; 类型表示未确定类型的指针。C,C++规定，void&#42; 类型可以通过类型转换强制转换为任何其它类型的指针。一般需和free函数配对使用。\n\nmalloc功能：在堆区申请指定大小的连续的一段空间，并返回该空间的首地址。\n注意：必须是连续的一段空间，如果有10字节的连续空间，但是要申请连续20字节的连续空间是申请不到的。\n\n<strong>Q:为什么malloc需要强制转换？</strong>\nA：因为在malloc默认的是返回void&#42;。返回的其实都是内存区域的首地址，这个时候如果不进行强制类型转换的话，就不知道这个区域存储的到底是什么类型。\n\n<h3>编译环境决定了数据类型的存储方式</h3>\n```\n// void *malloc( size_t size); 参数是无符号类型\n\n    // size_t类型的解释：size_t (unsigned __int64 or unsigned integer, depending on the target platform)\n    // 32编译器环境：unsigned int 4字节。 64编译环境： long unsigned int 8字节。\n\n    // Definitions of common types\n    #ifdef _WIN64\n        typedef unsigned __int64 size_t;\n        typedef __int64          ptrdiff_t;\n        typedef __int64          intptr_t;\n    #else\n    typedef unsigned int     size_t;\n    typedef int              ptrdiff_t;\n    typedef int              intptr_t;\n    //printf(\"%d\\n\", sizeof(size_t)); // x64: 8    x86: 4\n```\n\n<h3>(2&#42;1024&#42;1024&#42;1024 - 1)问题</h3>\n```\n    // warning C4307: “-”: 整型常量溢出\n    解释：这种做法看似没问题，其实问题大了，我们知道int的最大范围是2^31-1。但是在2*1024*1024*1024时候就已经溢出了，然后再-就是用溢出的数去减一个数。\n    //  // 解决思路：用无符号的int代替有符号的int。 2u*1024u*1024u*1024u\n    //  int* p2 = (int*)malloc(2u * 1024u * 1024u * 1024u); // 无法读取内存 0xcccccccc {???},说明无法申请那么多\n```\n\n<h3>申请数组空间</h3>\n```\n    // 申请一维数组\n    //  //int (*p)[5] = (int(*)[5])malloc(sizeof(int)*5);    // int(*)[5]类型\n    //  //int a[5];\n    //  //int (*p1)[5] = &amp;a;\n    //\n    //  //for (int i = 0; i < 5; i++)\n    //  //{\n    //  //  (*p)[i] = i;\n    //  //}\n    //  //for (int i = 0; i < 5; i++)\n    //  //{\n    //  //  printf(\"%d\\n\", (*p)[i]);\n    //  //}\n    //  //free(p);\n    //\n    //    // 申请二维数组\n    //  int (*p)[2][3] = (int(*)[2][3])malloc(sizeof(int)*5);    // int(*)[5]类型\n    //\n    //  for (int i = 0; i < 2; i++)\n    //  {\n    //      for (int j = 0; j < 3; j++)\n    //      {\n    //          (*p)[i][j] = i+j;\n    //      }\n    //  }\n    //\n    //  for (int i = 0; i < 2; i++)\n    //  {\n    //      for (int j = 0; j < 3; j++)\n    //      {\n    //          printf(\"%d\\t\", (*p)[i][j]); // (*p)[i][j] ==  *(*(*p+i)+j)   *(p+n) = p[n]\n    //      }\n    //      printf(\"\\n\");\n    //  }\n    //\n    //  free(p);\n```\n\n<h3>calloc函数</h3>\n```\n    //  //void *calloc(\n    //  //  size_t num, // 元素的数目\n    //  //  size_t size // 每个元素字节长度。\n    //  //);\n    //  // calloc 函数分配数组的 num 元素，每个存储区长度 size 字节。 每个元素初始化为 0\n    //  // clear allocation。动态内存分配并清零\n    //\n    //  // 与malloc的区别：\n    //  //      calloc在动态分配完内存后，自动初始化该内存空间为零，\n    //  //      而malloc不初始化，里边数据是随机的垃圾数据。\n    //\n    //  int* p = (int*)calloc(5, 4);\n    //  for (int i = 0; i < 5; i++)\n    //  {\n    //      printf(\"%d\\t\", p[i]);\n    //  }\n    //  // 结果： 0 0 0 0 0\n```\n\n<strong>malloc和calloc的区别</strong>\n1. calloc申请数组合适，初始化为0方便。\n2.但是其他数据结构，比如链表，树，图，一次申请sizeof(节点)，这些用malloc更合适\n3.calloc会初始化内存，所以申请的内存数很多的时候，效率会低一点点，有些事不需要初始化的。当然效率问题微乎其微\n\n<h3>realloc</h3>\n\nrealloc 返回一void指针用来重分配的 (可能移动）内存块。\n\n<h3>跨函数使用内存</h3>\n\n在我们的函数里，如果是局部变量，函数调用完就没有了。这个时候如果你希望把一个变量通过一个函数指向一个合法的地址是不行的。但是如果是通过malloc函数我们动态申请分配就可以了。","categories":["C语言编程"]},{"title":"C语言编程-指针-数组指针-指针数组","url":"/2018/09/09/C语言编程-第3章/","content":"<h3>第三章-指针-数组指针-指针数组</h3>\n\n<h3>指针</h3>\n\n指针是一种数据类型，就像int，float一样，指针装的是地址，int装的是整型。所以这个指针变量的值就是装的地址了。\n指针的关键点：偏移，内存操作。 对内存的三种操作：读 写 取地址\n```\nint* p;\n    //*表示p是一个指针变量\n    //p是指针名字\n    //int表示p装的地址，对应的空间的数据类型。（指针装的是一个变量的地址，而变量就有数据类型）\n\n    int a = 12; // 声明一个变量，指向这个变量的空间.// 这里的*和定义的*不一样。  *: 节引用运算符。 &amp;:取地址运算符。\n    int *p = &amp;a;\n    // 初始化，  指针指向空间\n    // 这里的*和定义的*不一样。  *: 节引用运算符。 &amp;:取地址运算符。\n```\n\n指针指向空间\n指针就是装地址的变量，变量就要赋值，即一定要装一块空间的地址，或者指向一块空间，才能被使用。就像int a;没有初始化和赋值我们就无法使用。\n指针变量也是同理，不装地址无法使用，称为野指针。\n\n<h3>深入理解&#42;的意义</h3>\n\n今天看了C3程序员的指针教程后，对指针又有了新的了解。想起初学的时候怎么也没搞懂，这次作者重新录制的新的一版C语言教程，对我来说帮助非常的大，我从中解决了很多困惑的问题。在C语言中最让人头疼的就是指针了，但是看完了他的教程后我豁然开朗了。所以当你们初学的时候遇到问题也是一样不要慌，随着知识的积累你会慢慢理解的。你看，我不是重新回来学C了嘛。\n\n总结：\n在int &#42;p;中&#42;的意义只是表明这个变量是指针变量。\n而在其他地方，一个指针指向一个变量，重点：&#42;这个指针，就是那个变量本身。换句话来理解，就是&#42;一个变量(指针变量)，就是得到该变量存储数据的值。\n```\n一级指针\n    //  int a = 12; // 声明一个变量，指向这个变量的空间\n    //  int *p = &amp;a;\n    //  printf(\"%d\\n\", a);  // 12        变量a的值\n    //  printf(\"%p\\n\", &amp;a); // 012FFB38  a的地址\n    //  printf(\"%d\\n\", *p); // 12        指向的空间存储的值， a的值。*p就是得到指向空间存储的值。p是存储a的地址，*这个变量，就得到该存储的值，就是a了。\n    //  printf(\"%p\\n\", p);  // 012FFB38  指向的空间，就是a的地址\n    //  printf(\"%p\\n\", &amp;p); // 001DFBD8  保存指针变量的地址\n    //  printf(\"%p\\n\", &amp;*p);// 0135F728  先是*p，得到的是a的值，之后得到a的地址\n    //  printf(\"%p\\n\", *&amp;p);// 0135F728  &amp;p得到的是装p的地址，然后*之后就是得到该变量存储的值。这个存储的值就是p的值，p的值就是a的地址。\n    //  printf(\"%d\\n\", *&amp;a);// 12        &amp;a得到a的地址，a的地址存储的数据\n\n    二级指针\n    //  int a = 10;\n    //  int *p = &amp;a;   // 一级指针\n    //  int * *p1 = &amp;p; // 二级指针：指针的指针。  意义：用来装一级指针的地址。\n    //  printf(\"%p\\n\", &amp;a);   // 00D7FB84    a的地址\n    //  printf(\"%p\\n\", p);    // 00D7FB84    p就是装a的地址，就是a的地址了。\n    //  printf(\"%p\\n\", &amp;p);   // 00D7FB78    装p的地址。\n    //  printf(\"%p\\n\", p1);   // 00D7FB78    p1就是装p的地址\n    //  printf(\"%p\\n\", *p1);  // 00D7FB84    *p1就是p了，而p就是a的地址。\n    //  printf(\"%d\\n\", **p1); // 10         *p1就是p了，然后再*就是a的值了。\n    //  printf(\"%p\\n\", *&amp;p);  // 00D7FB84   &amp;p就是装p变量的地址了，*之后就是得到该变量存储的空间的值，这个值就是p变量，p变量就装a的地址。所以就是a的地址了。\n\n    // *p1 == p\n    // **p1 == *p == a  \n```\n\n<h3>&#42;p++和&#42;(p+i)</h3>\n\n这是其实&#42;p++后p指向了下一个地址，这时候p已经改变指向了。\n\n<h3>数组名和指针变量的区别</h3>\n\n我们知道数组名其实就是数组的首地址，不同的是\n```\n//  int a[5] = { 3, 4, 1, 19, 6 }; // *(a+2)\n//  int *p = &amp;a[0];                // a和p的区别：a是常量，不能改变，不能++。 而p是指针变量。这是它们的区别。\n```\n\n<h3>[]运算符的意义</h3>\n\n以前一直以为这是数组专属的符号，也没有注意到运算符优先级中，这是属于分隔符，后来发现有人写<strong>2[p]</strong>的时候觉得还能这样写？\n这说明了下标运算，就是先算2+p，无论是p[2]还是2[p]。\n```\n// *(p+2) == p[2] == 2[p];\n```\n\n<h3>深入理解指针数组和数组指针</h3>\n\n经常搞混了的指针数组和数组指针，其实他们之间并没有什么联系，可能是因为名称读起来很容易的混乱的缘故。不过你看了我下面总结的一句话你就不会混乱。\nint&#42; p[5]: 指针数组， 装地址的数组。\nint (&#42;p)[5]: 数组指针， 装数组的地址。(指针就是用来装数组的)\n\n指针数组，很好理解，这是一个数组，里面装的是地址。\n而数组指针，这是一个指针类型，那什么叫指针啊，指针就是用来装地址的。那这里装的地址就是数组的地址。&amp;a[0]是住户的地址，而&amp;a则是小区的地址。\n\n那这样就好理解了，指针数组，首先是一个数组 int p[5],接着这是装地址，所以是int&#42;，指针数组的定义就是int&#42; p[5];\n而数组指针，首先是指针，那就是int &#42;p;里面装的是数组的地址，那就是int (&#42;p)[5]了.这里你一定要知道这里的&#42;是用来表示声明一个变量是指针类型。\n\n下面是我学习的笔记\n```\n#include <stdio.h>\n    #include <stdlib.h>\n\n    int main(void)\n    {\n        // 指针数组与数组指针\n\n        // 指针数组\n        //int b = 1,\n        //  c = 12,\n        //  d = 3,\n        //  e = 6,\n        //  f = 8;\n        //int* a[5] = {&amp;b, &amp;c, &amp;d, &amp;e, &amp;f}; // 指针数组， 比如int数组，指针就是一种类型。\n        // a[5]表明是数组\n        // int* 表明是指针类型\n        // 加起来就是指针数组\n        // 里面的值就是指针。\n        //*a[0] = 100; // 通过数组去操作修改，a[0]得到的是指针数组里面的元素，就是&amp;b,然后再*就得到b的值了。\n\n\n        // 数组的拉链结构\n        //int b[2] = { 1, 2 };\n        //int   c[4] = { 3, 4, 5, 6 };\n        //int   d[3] = { 7, 8, 9 };\n        //int   e[2] = { 10, 11 };\n        //int   f[5] = { 12, 13, 14, 15, 16 };\n        //int* a[5] = {b, c, d, e, f}; \n\n        // 利用指针数组取值，比如访问4\n        //printf(\"%d\\n\", a[1][1]); // 4就是c[1]，而这个c的地址就是a[1]。所以就是a[1][1]      a[1] == c\n        // 说明[]下标运算符，需要一个地址和常数。a[1]是地址，a[1][1]就是一个地址和一个常数了。\n\n        // 数组的拉链结构和二维数组的区别：\n        // 1.二维数组的存储是连续的空间\n        // 2.二维数组的每一个列和行是相同的\n\n\n\n        // 数组指针\n        // 地址是数值，指针是一种类型，\n        // 指针数组：装的是住户      int* a[5];相当于int *(a[5])\n        // 数组指针：装的是小区      int (*p)[5];\n        int a[5] = { 1, 4, 5, 3, 2 };\n        int *p = &amp;a[4];\n        // int *p1 = &amp;a; // 问题：“初始化”:“int *”与“int (*)[5]”的间接级别不同\n        // 解决方法\n        int (*p1)[5] = &amp;a;\n        // 分布理解\n        // 1. *p1 指针类型\n        // 2. int[5] 数组  个数必须和a的数组个数一样\n        // 3. p1是指针\n        // 4. *的优先级低于[]\n\n        // 利用数组指针取值，比如访问4\n        printf(\"%d\\n\", (*p1)[1]); // p1存储的是a的地址,而*p1就是得到这个值，a的地址。a[1]就是得到4了。\n\n        // 用处：数组指针用来作为函数参数比较多\n\n        // 深入理解指针数组和数组指针\n        // int* p[5]: 指针数组， 装地址的数组\n        // int (*p)[5]: 数组指针， 装数组的地址。(指针就是用来装数组的)\n\n\n        system(\"pause\");\n        return 0;\n    }\n```\n\n<h3>补充</h3>\n\n当定义多个变量的时候，指针的声明通常有两种。\n```第一种\nint *p1, *p2;\n第二种\nint* p1;\nint* p2;\n```\n\n可以看到一种是&#42;后面紧贴是变量，而另一种是类型后面紧贴&#42;。有些人觉得int&#42;是一种类型，其实并不是完全这样说，int是一种类型，而&#42;则表示改变量是指针变量。所以如果你像下面这样声明的话得不到想要的结果\n```\n// int* p1, p2; //这个时候p1是指针变量，而p2是普通变量。\n```\n\n在C++ Primer一书中，推荐的是将&#42;与变量名连接在一起，我个人认为这样也会更好理解写。如果使用一种风格就不要随便改变，整体要保持这种风格。\n```\n(int *i, int &amp;key)\n```","categories":["C语言编程"]},{"title":"C语言编程-C中对内存的存储方式","url":"/2018/09/09/C语言编程-第2章/","content":"<h3>第二章-C中对内存的存储方式</h3>\n\n如果是基本数据类型，比如int那么内存就会分配4个字节取存储。那么数组是怎么样的呢？\n\n数组，是一次申请多个空间，比如int a[5]，那么内存会分配4&#42;5个字节去存储，而这个内存是线性的，意思就是说每个数的首地址+一个类型就是等于下一个数的首地址,我们说一个数的地址，说的是这个数的首地址，比如\n\n```\nint a[2] = {3, 4}\n12\n0000 0000 0000 0011    0000 0000 0000 0100\n首地址                  首地址\n```\n\n注意的重点是：数组的内容的地址是连续的,即数组的地址是连续的。既然知道内存是线性的，下面就说一下地址加1的意义。\n\n<h3>C语言数组中的a, &amp;a, &amp;a[0]的区别和地址加1的意义</h3>\n\n那时候我学C的时候问题没有那么多，现在重新学习反而对这些很有兴趣。C语言数组中的a, &amp;a, &amp;a[0]是不是傻傻分不清楚？地址的加法又是怎么回事？\n其实也没有那么难，一维数组的地址加1其实加上<strong>一个类型</strong>的大小，并不是普通的加1。你要明白我们说的数组的地址是首元素的首地址。\n\n<strong>而数组名a是一个常量，首元素的地址。&amp;a是数组的地址，相当于小区。&amp;a[0]是首元素的首地址，相当于住户，单个元素的地址</strong>\n<strong>Q：&amp;a和&amp;a[0]的区别？</strong>\n<strong>A:</strong>\n1.小区地址与具体用户的地址\n2.&amp;a+1加上一个类型(整个数组)的大小，<strong>一个小区的下一个，是下一个小区</strong>\n3.&amp;a[1]+1加上一个类型(一个元素)的大小，<strong>住户的下一个，是下一户。</strong>\n\n数组名的意义：首元素的地址\n            a = = &amp;a[0];\n\n<h3>下面是我学习的笔记，感兴趣的可以看看</h3>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n//int main(void)\n//{\n    // 数组， 一次申请多个空间，数据的集合。 内存都是线性的\n    //int a[5]; // 数组声明\n    // 字母，下划线，数字，首位不能是数字\n    //int a[5] = {1, 2, 3, 4, 5 };// 数组声明和初始化\n    //int a[5] = { 1, 2 };// 数组声明和初始化，初始化部分元素，其他默认位0\n    //int b[5] = {0};\n    //int c[] = { 1, 2, 3 }; //不指定个数，但是这样就一定要初始化\n\n    // 给数组赋值 \n    // 越界\n    // 数组名是个常量\n\n    //int a[3] = { 1, 2, 3 };\n    //printf(\"%d, %d, %d\\n\", a[0], a[1], a[2]);\n    //printf(\"%p\\n%p\\n%p\\n\", &amp;a[0], &amp;a[1], &amp;a[2]);\n\n    //printf(\"\\n\");\n    //// 地址偏移\n    //printf(\"%p\\n%p\\n%p\\n\", &amp;a[0], &amp;a[0]+1, &amp;a[0]+2); // 通过a[0]的地址得到a[1]， 地址+1：其实是地址加上类型的大小，不是普通的加。\n    //printf(\"\\n\");\n    //// 地址+1：其实是地址加上类型的大小，不是普通的加。\n    //printf(\"%p\\n%p\\n%p\\n\", a, &amp;a, &amp;a + 1); \n    /*\n        &amp;a是数组的地址。\n        &amp;a[0]是首元素的首地址，单个元素的地址\n        &amp;a和&amp;a[0]的区别：\n            小区地址与具体用户的地址\n            &amp;a+1加上一个类型(整个数组)的大小，一个小区的下一个，是下一个小区\n            &amp;a[1]+1加上一个类型(一个元素)的大小，住户的下一个，是下一户。\n\n        数组名的意义：首元素的地址\n            a = = &amp;a[0];\n     */\n     // 结果\n         //1, 2, 3\n         //012FFA1C  &amp;a[0]\n         //012FFA20  &amp;a[1]\n         //012FFA24  &amp;a[2]\n\n         //012FFA1C  &amp;a[0]\n         //012FFA20  &amp;a[0]+1 加的是一个元素的大小\n         //012FFA24  &amp;a[0]+2\n\n         //012FFA1C  a 小区\n         //012FFA1C  &amp;a 一个小区\n         //012FFA28  &amp;a+1 下一个小区，加的是整个数组的大小\n\n    //int a[2][2] = { {1,2},{3,4} };\n    //printf(\"%p\\n%p\\n%p\\n%p\\n\", &amp;a, &amp;a[0], &amp;a[0]+1, &amp;a[1]);\n    //printf(\"\\n\");\n    //printf(\"%p\\n%p\\n%p\\n\", a, &amp;a, &amp;a+1);\n    //printf(\"\\n\");\n    //printf(\"%p\\n%p\\n\", &amp;a[0][0], &amp;a[0][1]);\n\n    // &amp;a[0] === a\n    // 结果\n        //00EFF794  &amp;a\n        //00EFF794  &amp;a[0]\n        //00EFF79C\n        //00EFF79C  &amp;a[1]\n\n        //00EFF794  a\n        //00EFF794  &amp;a\n        //00EFF7A4\n\n        //00EFF794  &amp;a[0][0]\n        //00EFF798  \n\n//  system(\"pause\");\n//  return 0;\n//}\n```\n\n从结果来看，我们就和很好的明白了数组中地址加1的意义。\n\n下图是我看C3程序员的教程截取的图，如有冒犯立删。从图中对二维数组的描述，我们就能更好的理解这个地址加1的意义了。\n<img src=\"/images/pro07-数组的地址png.png\" alt=\"\" />\n","categories":["C语言编程"]},{"title":"C语言编程-常见问题和注意的东西","url":"/2018/09/08/C语言编程-第1章/","content":"<h3>第一章-常见的问题和注意的东西</h3>\n\n<h3>不同main的写法</h3>\n\n学习C语言的时候我们经常看到有不同形式的main函数，虽然有些看起来执行没什么错误。但是我们应该遵守标准的写法。\n\n```C\n/*\n int main(void) // c99 新的标准，1999年。初学使用。\n {\n    return 0;\n }\n\n int main(int argc, char* argv[]) // 标准主函数，命令行\n  {\n    return 0;\n }\n\n int main() // c++标准形式  // 老版本编译器，c语言可以不加void。\n {\n    return 0;\n }\n\n */\n ```\n\n在这里我重新学C的时候用的编译器是Visual Studio2017，这里需要设置工程编译为C。\n解决方案下的——项目名——属性——所有配置——C/C++——高级——编译为C\n\n<h3>调试程序</h3>\n\n另外在编程的时候，经常会遇到一些bug，这时候就需要我们进行调试了，而在Visual Studio2017中，\n运行程序: Ctrl + F5 或调试 >“开始执行(不调试)”菜单\n调试程序: F5 或调试 >“开始调试”菜单\n断点\n\n<h3>注释</h3>\n\n给程序注释有助于增加程序的可读性，在Visual Studio2017中多行注释快捷键 Ctrl+K Ctrl+C，在工具栏中本地Windows调试器右边也有显示。\n多个变量不要同一行写，便于注释。\n\n<h3>格式化输出符号</h3>\n\n在学习的时候我们经常要打印输出，那么选择合适的格式输出就非常重要了。\n\n```\n格式化输出符号 转义字符  %d %o %x %X <——> 十进制，八进制，十六进制\n    %p 打印十六进制的地址， %u表示无符号十进制整型输出\n    printf (\"%d, %o, %x, %X\\n\", 12, 12, 12, 12);// 12 14 c C\n\n    // %m.nf  %.2f   m:占多少位， n:多少位小数，最后一位会四舍五入\n    // %-m.nf  -:左对齐  没有就是右对齐。\n```\n\n<h3>数据类型</h3>\n\n为了更准确的表示数据，编程语言中通常会把数据分为基本数据类型和其他类型。\n在C语言中基本数据类型为：int， short，float， long， double， long long 这些，还有字符类型。还有一种就是构造类型：数组，结构体，联合体，枚举。最后还有一种特殊的指针类型。\n\n数据是需要存储的，而我们计算机对于数据类型都有不同的方式。比如int就是四字节，我们可以通过sizeof()函数得到类型的大小进行测试一下，sizeof(变量) ，sizeof(类型)。\n\n我们接下来简单探究一下计算机是怎么存储类型的。在int类型中，分为有符号整型和无符号整型，表示的范围是不一样的，这个需要注意。无符号类型就不用说了，四个字节都是用来表示正数。而有符号的整型正负数的个数各一半。我们主要是说一下浮点数的存储，float和double的有效精度是不同的，这个跟编译的环境有关，以实测为准。\n```\n// 有效数位(单精度) 不同机器上不同，以测试为准，实测是8位。\n    // 双精度，实测是18位\n\n    // float:1bit符号位，8bits指数位，23bits尾数位 ， 2^23=8388608，一共七位//32bit\n    // double:1bit符号位， 11bits指数位，52bits尾数位\n```\n\n<h3>取位数</h3>\n\n这个用处不多，但是可以理解一下这个思想。比如%10得到的数范围就是0~9， %6得到的数范围就wei是0~5。\n```\n//int a = 12312;\n    //int b = a % 10; // 个位\n    //int c = (a / 10) % 10; // 十位\n    //int d = (a / 100) % 10; // 百位\n    //printf(\"%d,%d,%d\\n\", b, c, d);\n```\n\n<h3>前缀++ 后缀++，前缀-- 后缀--</h3>\n\n我们经常会看到网上出题,然后问我们a和b的结果是什么：\n```\n//int a = 3;\n    //int b = (a++) + (++a) + (a++);\n```\n\n但是这种题目其实没什么意义，因为不同的编译器得到的结果是不一样的，而且我们也不会这样使用。同一个变量的自增自加不能出现在同一条语句中两次以上。\n\n<strong>a++的意义</strong>\n相当于 系统申请了一个空间x，x=a把a的值赋值给x，之后a = a + 1；最后返回x,令c=x把x的值赋值给c。    ---啊，看来我以前理解错误了。把申请空间的省略了。\n<strong>不是c = a, a = a+1。 解释如上，而且=号的运算优先级是低于++的。</strong>\n\n<strong>前缀++ 和 后缀++的区别？</strong>\n1. 优先级不同，后缀++ 高于 前缀++\n2. 所在语句汇总，参与运算的值不一样。前缀是自加后的，后缀是自加前的。\n3. 注意自增的本质是变量自身的++，常量是不可以的。\n\n**a=a+1 和 a += 1 和 a++的区别**\n1. a++;解释如上面。\n2. a = a + 1; 这个是复合运算符， 是先取a的值，在进行加加操作。它等同于a++;\n3. a += 1;   注意+=是个单独运算符是先对a进行加1操作，在返回a的值。它等同于++a;\n\n<h3>goto语句</h3>\n\n这个被标记为红色警告使用的关键字，一般来说不建议使用，而且使用的情况非常有限，一般是用于跳出多层循环。在Java中也有标签的说法，通过break 标签可以直接跳出多次循环。","categories":["C语言编程"]},{"title":"C语言编程-前言","url":"/2018/09/07/C语言编程-第0章/","content":"<h3>第0章-前言</h3>\n\n这是C语言编程系列的第0章，主要先来说说接下来的文章将会写什么。\n\n可能有同学第一次听说C语言，那么我就先简单介绍一下，让大家感受一下。在我们生活中，经常使用的电脑和手机还有一些智能设备，这些东西极大的丰富了我们的生活。大家有没有想过，我们使用手机的时候，这些软件是怎么做出来，或者大家有没有想过自己做一个软件出来，我们有时候想要一个什么什么样的功能，但是却没有的时候如果我们能够自己做那么是不是非常的不错啊，至少我觉得是非常开心的事。那么C语言就是可以帮我们实现这个想法，我们知道语言是用来交流的，那么C语言就是帮助我们和计算机交流的，然后我们使用这么语言告诉计算机要做什么，这时候计算机就会接收到我们的信息帮我们做一些事情。至于计算机是怎么做的这个过程其实是非常的复杂。但是我们现在已经知道了C语言是我们用来和计算机交流的，当然和全世界有很多语言一样，我们和计算机交流也不只是一种语言，大家可以去了解一下还有什么语言。但是我们这里就只是说C语言。\n\nC语言是我学习的第一门编程语言，这门语言让我懂得了很多编程的知识和思想。但是中途的时候遇到了各种问题，那时候我一直没搞懂暂时就放下了，我并没有放弃。然后一直过了很久，我又突然知道那时候遇到的问题怎么解决了，于是我决定重新学习C语言。\n\n在我们遇到的很多问题其实都是这样，弄不懂就先别弄先了。有些东西需要有必备的基础知识才能解决，虽然现在网络很发达，但是并不是所有问题我们都能够找到，很多问题可能是我们的知识不够造成的，所以大家如果遇到问题的时候，不要觉得难，或者觉得这太痛苦了不学了。我们可以换个思路，先去学基础，然后再回头看看。你说一个什么都不懂的人，他搜索问：如果自己写一个操作系统？这时候他的内心是怎么想的呢，最好网上有教程而且还是有图片的告诉他一步一步怎么做。但是我们要知道知识的海洋是非常大，想要一个从零开始的人，跟着教程写一个操作系统出来那教程不知道得写多长，而且这也没有人会从零开始写，比如写的时候可能默认你了解操作系统熟悉C语言编程了。\n\n其实我在学习的时候也是这样，我也很希望有个教程告诉我一步步怎么来，但是并没有。这个时候只有靠自己探索了，即使是老司机也是从新手慢慢来的，所以不要急，自己慢慢探索吧，遇到问题要学会思考，想着怎么解决。\n\n所以，我这一系列主要是面向一些有基础的，然后说一些基础的原理和注意的东西，当我们回过头来看的时候我们没有注意到的东西。网上有很多讲的教程，我们就不重复造轮子了。那么下一次我们就开始讲注意的东西。","categories":["C语言编程"]},{"title":"局域网内配置ssr代理服务器","url":"/2018/06/30/13/","content":"主要是给无法安装ssr客户端的机器提供f/q服务。你只要有机器能f/q，就能够通过局域网内代理给另一台机器。\n\n首先机器确保是在同一个局域网下，可以连接同一个路由器。\n## 配置ssr客户端\n具体的就不说，几个设置：\n1. 本地代理设置为**允许来自局域网的连接**\n2. 系统代理模式设置为**全局模式**\n3. 代理规则设置为**全局**\n\n## 配置机子\nhttps://www.gugefan.com/t/18","categories":["笔记"]},{"title":"Ubuntu17.10修改主题","url":"/2018/05/28/linux从入门到放弃11/","content":"Ubuntu默认的主题并不是很喜欢，于是修改了主题。\n### 效果\n![](/images/mac1.png)\n![](/images/mac2.png)\n### 1.安装工具\n```\nsudo apt-get install gnome-tweak-tool\nsudo apt-get install docky\nsudo apt update\n```\n\n### 2.下载主题\n下载主题见[linux公社](https://www.linuxidc.com/theme/)\n或者搜索在[GNOME主题网站](https://www.gnome-look.org/browse/cat/135/)\n下载相应的主题，解压.\n把对应的文件移到/usr/share下对应的目录.\n比如：\n主题/usr/share/themes\n图标/usr/share/icons\n\n\n### 3.配置\n搜索tweak，打开tweak－外观然后修改成自己喜欢的主题，光标，图标，shell这些.\n","categories":["Linux"]},{"title":"吉他学习第十一弹——练习方法","url":"/2018/04/09/吉他学习第11弹/","content":"这个暑假，我终于有机会去请教老师学习吉他了，我跟着表弟去旁听学吉他，真的受益匪浅。\n我的感触很深，老师讲课的时候我得到了我以前困惑一直找不到的答案，我在自学吉他的道路上确实一点天赋都没有。\n所以希望有条件的话或者条件稍微差一点，也最好请一位好的老师学习一段时间，初学的姿势和感觉非常重要，还有\n一些弹奏的时候的细节处理，会一直影响到你后面的练习，而且会打击你的信心，你练习的时候不知道自己有没有问\n题，而且你有问题可能也解决不了，而你如果有一位老师，可能这些都轻易解决了。当然，有了好的正确练习方式，\n剩下的就是自己努力练习了，一起加油吧。\n\n学习吉他，我觉得首先乐理知识很重要，我经常会回过头重新看乐理知识，有些不懂的地方慢慢的就又懂了，而且乐理\n知识的了解对于提高吉他的弹奏都有帮助。其次练习基本的右手的手指节奏型和扫弦节奏型，最好跟着节拍器或者网上\n的教学视频练习，循环的播放，这些对于你的节奏感提高都有很大的帮助。还有爬格子的练习也很重要，提高你的手指\n灵活性，有时候你一直感觉自己换弦不流畅，硬着头皮练习，可能就是练习的不对了，一步一步来可以试着先提高手指\n的灵活性。练习节奏型的时候先慢后快，快有利于提高我们，突破我们的极限。练习的时候一定要突破自己的极限去练习，\n这样的练习才会进步，如果你一直做自己能做到的练习就没有什么意义了。暂时就想到了那么多。\n\n\n\n\n\n\n\n\n\n\n\n","tags":["乐理"],"categories":["音乐与生活"]},{"title":"吉他学习第十弹——手指操","url":"/2018/04/09/吉他学习第10弹/","content":"1、手指的捏拉动作\n用大拇指与食指，将另一只手的每根手指从指尖部位往外拉，停留于指甲根部附近，用力下压1－2秒钟，每根手指各重复5－6次。如果能在热水中稍微浸泡后再做效果会更好。\n\n2、手指关节的按摩动作\n用大拇指与食指从指根的部位朝指尖方向拉，至指甲末梢时再一口气“啪”的放开。各手指重复5－6次。此动作能够促进血液循环，帮助脂肪达到容易分解状态。若手指拉拨不易，可涂抹些按摩霜滋润。\n\n3、举手\n这种简单的动作可以使您的手恢复白嫩，并减少青筋显露，只要展开五指，高举双手过头，每次数分钟就可以。\n\n4、握拳神展。\n这是解除紧张的良好动作，并可以使手部柔软，先紧握拳头，然后展开，尽量伸展五指，每天用力地做三至五分钟。\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["乐理"],"categories":["音乐与生活"]},{"title":"吉他学习第九弹——扫弦","url":"/2018/03/26/吉他学习第9弹/","content":"### 一、扫弦节奏练习\n以C和弦为例，按C的时候可以大拇指按住六线。第一个不扫到6弦，第二个不扫到56弦.\n![](/images/扫弦练习1.png)\n\n### 二、扫弦要点\n1.扫弦不要吃太多弦，手臂和手腕自然，放轻松。\n2.**扫弦就是一个向下向上翻手腕的一个过程，手腕向外翻。**\n3.两指扫弦：拇指与食指交叉成“十”字，扫弦时，右手的运动应该**以手腕为主，手腕发力，手腕运动带动小臂**\n运动，手指同弦应该接触是个60°左右的锐角。手指扫弦的轨迹应该是个弧形，下击时手指按顺时针\n方向画圈，上击时手指按逆时针方向画圈，类似一个翻手腕的过程。\n4.**手指的入弦角度很难把握，这需要大量的练习，不能太平行琴弦，不然声音会很难听，尽量做到靠垂直的方向**\n5.节奏、强弱、该扫哪些弦、感觉\n6.空的时候手指不弹但是也要下去\n\n拨片法\n1. 用拨片演奏时，吉他的音色清脆明亮，扫弦时层次感比指弹好。\n2. 拨片握法：伸出右手食指，手指自然弯曲，手指的侧面朝上，将拨片放在食指侧面的**顶端**，用大拇指的第一指节压在它的二分之一处。尽量放松，保证拨片刚好不好掉下来的力度。\n3. 拨片的弹法：拨片的平面不要垂直于琴面，成一共50°左右的夹角最佳。0.46毫米到0.5毫米的较薄拨片更适合扫弦，厚一点的更适合电吉他。\n\n### 三、扫弦节奏型练习\n下 下上 0上 下上\n四分音符  下 上 下 上 \n八分音符  下上 下上 下上 下上\n十六分音符 下上下上 下上下上 下上下上 下上下上\n\n十六分音符的演变\n![](/images/节奏型.png)\n\n\n### 四、切音、闷音\n切音通常在上面点一个点，切音节奏型练习。下上切上\n![](/images/切音.png)\n\n强弱对比，咚嗒嗒咚嗒嗒咚嗒，长箭头用力弹\n![](/images/闷音.png)\n1.掌握闷音的要点第一就是你的左手是否压好了。左手本身没压好，那么闷音本身也是不成功的。\n2.力度的掌握是一个比较重要的地方,力度的话与其说是“压”还不如说是小鱼际“靠”在琴上更加合适\n3.小鱼际的位置,确定你的右手小鱼际尽量垂直压在弦上面，以减少压的面积。然后你压的位置尽量靠\n近琴枕，如果开始觉得很难掌握，可以干脆就压在琴枕上也是可以的。 \n4.一般尽量使用拨片 指弹闷音是很难的，利用拨片可以在拨弦的时候用更大一点的力度。闷音本来就是需要更大一些的拨弦力度的。 \n\n","tags":["乐理"],"categories":["音乐与生活"]},{"title":"吉他学习第八弹——吉他演奏常用技巧","url":"/2018/03/26/吉他学习第8弹/","content":"### 一、符号解释\n附点：在一个音符的后边加一个小圆点，音符的时值被延长一半。\n例如：**1-.**就是附点二分音符，现在也由**1--**的写法。\n\n延音线：把两个或两个以上音高相同的音符用弧线连起来，把这些音唱成一个音，时值是它们的总和。\n连音符：把一个音符的时值均分成若干份。常用有三连音、五连音、六连音。三连音是把一拍分成均等的三部分。\n![](/images/连音.png)\n\n休止符：表示停顿时值长短的音符，通常用0表示。\n变音符号： 升调#、降调b\n![关系调](/images/音符符号.jpg)\n||:   :||反复记号\n||:  |   :||另一种反复记号\n![](/images/反复记号1.png)\n![](/images/反复记号2.png)\n\n### 二、吉他演奏常用技巧\n![](/images/符号.png)\n颤音(Vib或)\n1. 平行颤音\n用左手按弦的手指在指板上个沿着琴弦的方向快速地、小范围地反复运动。(平行于弦)\n2. 垂直颤音\n在指板上急促、交替、小幅度地把琴弦推起——下拉\n\n推弦(B或)\n先弹响一个音，接着将这根弦推起(123弦向上推弦，456弦向下拉弦)\n\n弱音(M或P.M)\n1. 左手弱音\n左手手指压力放松(不要离弦)，然后弹响。如果想消音就左手放松即可。\n2. 右手弱音\n把右手手掌的小鱼际放在弦桥处弱音或消音。\n消音(·)\n\n泛音\n泛音单纯，容易辨别音高。共振定音，音高同的会发送共振，频率相同。\n1. 自然泛音(Natural harmonics)Harm\n左指轻轻虚按在琴弦上，右手手指用适当的力量拨弦，同时按弦的左指立即离开琴弦。\n2. 人工泛音(Artificial harmonics)A.H\n左指实按，右手食指在离左指实按的地方的后面第十二个音品上虚按，用拇指或者无名指或拨片弹起产生泛音。\n\n连音(上行连音、下行连音)\n上行连音：由低音到高音。H：Hammer on的缩写。演奏方法是：第一个弹出后，左手手指用力(较大的力量，动作迅速干脆)敲击琴弦发出第二个音。\n下行连音：又高音进入低音。P：pull off的缩写。演奏方法是：左手两指同时按住指定音，第一个音弹响后，按在较高音啥昂的那个手指由内像外勾出，发出第二个音。\n1. 击弦H\n2. 勾弦P\n3. 滑音S\n\n1.击弦力度要够，击完之后就先按住不动，不要马上放开\n2.**谱中的Em写错了，是24**\n![](/images/击弦练习.png)\n![](/images/平凡之路.png)\n琶音(波浪线)\n\n靠弦指法\n一个音弹完靠在下一根弦，如果是双音，则先弹低音再靠弦。\n只用食指靠弦\n\n切音、闷音\n\n### 三、音的强弱\n![](/images/音的强弱.png)\n除了常用的强弱变化，还有用切分法来进行强弱变化。\n**切分法**：就是通过延长弱拍音符的时值使强拍的重音位置向前移动弱拍。，改变了以强拍为重音。\n切分音的记法是在一个小节或一拍之内记成一个音，跨小节的记成加连线的两个音。\n![[](/images/切分法.png)\n\n### 四、节奏视唱\n![](/images/节奏视唱.png)![](/images/节奏视唱1.png)\n\n\n\n\n\n\n","tags":["乐理"],"categories":["音乐与生活"]},{"title":"吉他学习第七弹——和弦练习、卡农和声走向、独奏曲编配方法","url":"/2018/03/26/吉他学习第7弹/","content":"这一期就开始正式学几个和弦，C大调的自然音阶和弦。\n\n### 一、C大调的自然音阶和弦\n![](/images/卡农和声走向.png)\n说明：数字就是表示我们的手指，x表示我们不需要用到的音。\n\n在Do音上构成的三和弦即1 3 5，记为C；\n在Re音上构成的三和弦即2 4 6，记为Dm；\n在Mi音上构成的三和弦即3 5 7，记为Em；\n在Fa音上构成的三和弦即4 6 1，记为F；\n在Sol音上构成的三和弦即5 7 2，记为G；\n在La音上构成的三和弦即6 1 3，记为Am；\n在Si音上构成的三和弦即7 2 4，暂不讨论。\n\n### 二、卡农和声走向\nC G Am Em | F C F G称为卡农和声走向，编曲之万能和弦走向，所谓万能和弦就是指大部分流行歌\n曲所用的和弦，这些和弦走向非常悦耳动听。我们可以尝试着使用编配一些好听的曲子。\n\n**Q：如何使用万能和弦编曲？**\n1. 万能和弦--它的和声构成是：1级-5级-6级-3级-4级-3级-2级-5级-1级~ \n2. 万能和弦的变体--它的和声构成是：1级-3级-6级-3级-4级-3级-2级-5级-1级~ \n3. 1-6-4-5加万能和弦--前面是1级-6级-4级-5级，副歌接万能和弦1~ \n\n比如我们听说的5323 1323，这是一个四四拍，配合我们的和弦就会非常的好听。首先弹奏的是根\n音，C的根音是C弹的是五弦，G的根音是G弹的是六弦，Am的根音是A弹的是五弦，Em的根音是E\n弹的是六弦，F的根音是F可以弹六弦也可以是四弦。\n在这里我们可以把5323中的2和1323中的1弹的重一点，显得更有层次感和音乐性。\n\n我们通常都是说T3231323，我们练习的时候不要这样，而是把简谱写出来，听听我们弹的每一个音\n是什么。![](/images/T3231323.jpg)\n![](/images/和声走向.png)\n\n### 三、独奏曲编配方法\n单旋律配上的和弦就成了独奏的曲子，比如加上和弦的根音。单音版的歌曲配上我们的和弦根音就会变得非常好听。\n\n### 四、和弦转换要点\n![](/images/和弦转换1.png)\n<font color='red'>9.力度要适度以刚按住为界限</font>\n#### 送别歌曲练习，每天进步一点点，从基础练习开始\n![](/images/和弦转换2.png)\n\n### 五、和弦练习\n这些和弦练习不要以为简单就不练习了，必要的练习是非常重要的，可以训练我们左右手配合还有和弦的转换。\n\n**Q：在练习的时候，为什么我弹的音发出来很难听？**\nA：确保按和弦的位置还有姿势是对，慢慢来，前面可以把节拍器速度降低一点来练。前面的没弹\n完不要着急弹下一个。弹下一个和弦的时候一般都是从根音开始的，那么可以先按住根音。\n\n**Q：左右手配合不行，断断续续怎么办？**\nA：先单独练习一只手，比如左手练习和弦转换想着音但是不要弹。右手就是按着谱子来弹。然后左右手\n练习的时候可以注意力在右手，想着那个音要出来，然后左手自然的去按和弦，千万不要急。你可以\n多读几遍我说的话，想着那个音要出来的时候再去按，很自然的去按和弦。\n\n**Q：为什么我的弹完的时候，手指离开会有难听的声音？感觉声音很不干净**\nA：这是因为手指在琴弦离开品丝的一瞬间还在震动，碰撞品丝瞬间产生了打品现象。练习久了就自己控制了，前期是正常现象。\n\n**Q：F和弦按不了怎么办？要怎么样练习？**\nA：F和弦是初学吉他遇到的第一个大横按，也是让很多人望而却步的和弦。首先坚持每天爬格子，练习\n手指的灵活性，力量，还有左右手配合，然后分三步骤练习，每做下一步都要确保前一步练好了。\n1. 第一步先练习234指\n2. 第二步1指按照12弦\n3. 第三步再把1指按照六弦\n\n好了，下期见。","tags":["乐理"],"categories":["音乐与生活"]},{"title":"吉他学习第六弹——认识和弦","url":"/2018/03/24/吉他学习第6弹/","content":"### 一、和弦\n和弦由三个或三个以上的音，按照一定的音程关系叠置起来(即同时奏响)的音的组合。\n**基础和声知识主要内容就是研究和弦的构成、性值、运用**\n\n和弦按弦音的多少可分为：三个弦(三个音组成)、七和弦(四个音组成)、九和弦(五和弦)。\n按和弦的性值可以分为：协和和弦(大小三和弦)、不协和和弦(增减三和弦、七和弦、九和弦)\n\n### 二、三和弦构造\n大三度+小三度 = 大三和弦\n小三度+大三度 = 小三和弦 \n大三度+大三度 = 增三和弦\n小三度+小三度 = 减三和弦 \n![](/images/三和弦.png)\n大三和弦：音响协和，色彩明亮\n小三和弦：音响协和，色彩暗淡\n增三和弦：音响不协和，有扩张感\n减三和弦： 音响不协和，有收缩感\n属七和弦：音响不协和，有强烈倾向主和弦的特点\n\n### 三、C大调的自然音阶和弦\n在Do音上构成的三和弦即1 3 5，记为C；\n在Re音上构成的三和弦即2 4 6，记为Dm；\n在Mi音上构成的三和弦即3 5 7，记为Em；\n在Fa音上构成的三和弦即4 6 1，记为F；\n在Sol音上构成的三和弦即5 7 2，记为G；\n在La音上构成的三和弦即6 1 3，记为Am；\n在Si音上构成的三和弦即7 2 4，暂不讨论。\n\n音程中低的音称为\"根音\"，高的音称为\"冠音\"。音程的读法是：先读根音后读冠音。\n在C和弦中，根音与三音之间为大三度，三音和五音之间为小三度，这类和弦为大三和弦。\n在Dm和弦中，根音与三音之间为小三度，三音和五音之间为大三度，这类和弦为小三和弦\n\n\nCFG三个和弦的根音到三音为大三度，三音到五音为小三度，是大三和弦。而Dm，Em，Am是小三和弦。\n**minor(意大利语意思为小调，选修)major(意思为大调，主修)**\n在C大调中，C和弦是最稳定的，它被称为**主和弦**；G和弦对主和弦最具有支持力，进行到主和弦的倾\n向也最强烈，它被成为**属和弦**；F和弦可以进行到主和弦也可以进行到属和弦，称为**下属和弦**。\n\n### 四、G大调和弦\n调，通俗地说，调就是调门，也就是\"1\"的音高位置。C调的意思就是把C音唱为\"1\"，D调的意思就是把D音唱为\"1\"。**这样就确定了各音的音高的全音、半音关系。**\n唱     名 1 2 3 4 5 6 7  1\nC大调音阶 C D E F G A B  C\n和     弦 C  Dm Em F  G  Am C\nG大调音阶 G A B C D E #F G\n和     弦 G Am Bm C D Em\n\n### 五、七和弦和属七和弦\n七和弦由四个按三度音程叠置起来的音组成。**即三和弦上方再叠置一个三度音**就构成了七和弦。\n最上方的音与根音相距**七度**，因此也称为七度音。(哦，七和弦的由来，七和弦式由四个和弦音)\n简称为C七和弦，G七和弦，E七和弦。\n\n分类：大小七和弦、增大七和弦、减七和弦、半减七和弦、小大七和弦。\n\n#### 属七和弦\n属七和弦是在调式音阶的V级属和弦上方再叠置一个三度音所构成的七和弦。由于和弦内含有导音(大\n调为7，小调为#5)与主和弦根音(大调为1，小调为6)相距小二度。因此强烈倾向于主和弦。\n\n**自然大调、和声大调、和声小调、旋律小调中，属七和弦的性质是大小七和弦**\n**自然小调、旋律大调中，属七和弦的性质是小七和弦**\n**本调属七和弦的特征是降七级和弦，可以完成下属音功能的转调**\n![](/images/属七和弦.png\n\n### 六、和弦名称\n和弦的名称以和弦的根音的音名来表示，根音也就是低音。\n![](/images/和弦1.png)![](/images/和弦2.png)\n\n好了，下期见。\n","tags":["乐理"],"categories":["音乐与生活"]},{"title":"吉他学习第五弹——调式","url":"/2018/03/24/吉他学习第5弹/","content":"前面说的不知道有没有认真练习啊。这一节说一下调式。\n### 一、调式与音阶\n当一场演奏中处于最稳定的音称为**主音**，有时终止在属音上。组成音乐的一些音以主音为中心，按照\n它们彼此之间的高低及稳定与不稳定等关系，构成一个体系，这个体系叫做**调式**。调式中从主音到主\n音，按照音的高低顺序排列起来称为**音阶**。\n**当音阶从低向高进行时叫做上行，当音阶从高向低进行时叫做下行**。\n\n### 二、大调式\n大调式式一种以**1(Do)**为主音的由七个音构成的调式。用这种调式写作的音乐作品其色彩明朗、热烈。\n**大调式分自然大调、和声大调及旋律大调。**\n![](/images/大调式.png)\n\n### 三、小调式\n小调式以**6(La)**为主音的由七个音构成的调式。用小调式写作的音乐作品色彩较为暗淡，有忧伤的意味。\n**小调式分自然小调、和声小调及旋律小调。**\n![](/images/小调式.png)\n\n### 四、调式中各音的级数和专有名称\n![](/images/级数.png)\n\n\n### 五、补充\n大调和小调，就是说，找到七个音，只要音程关系符合**全全半全全全半**就是大调，音程关系符合**全半全全半全全**就是小调。\n\n嗯，下期见！\n\n","tags":["乐理"],"categories":["音乐与生活"]},{"title":"吉他学习第四弹——音程、音阶、十二平均律、C调音阶","url":"/2018/03/24/吉他学习第4弹/","content":"今天又来练习吉他了，之前说的打拍子、音名和爬格子练习一定要每天都练习，尤其是无名指和小指\n要多练习。在这里先了解一些专有名词。\n\n### 一、音程、度\n![](/images/音程11.png)\n\n音程：即两个音的音高上的距离，音程的单位为”度”，距离要用半音来算。\n\n音名相同的两个音，音程关系为一度。如1-1为一度，1-2为二度。其中1-2、2-3、5-6、6-7之间相\n差一个音，音程关系为**大二度**。而3-4、7-1之间相差半个音，音程关系为**小二度**。\n\n大三度跨了四个半音，就叫大三度，如果跨三个半音叫小三度，跨两个叫减三度，跨五个叫增三度。\n小二度音程+大二度音程=小三度音程(全半，距离三个半音)\n大二度音程+大二度音程=大三度音程(全全，距离四个半音)\n\n**Q：那么在我们的吉他上怎么表示这个大三度和小三度呢？**\n前面说了距离是用半音来算的。在吉他中：\n1. 相邻品之间为半音，小2度关系。\n2. 隔一品为全音，大2度关系。\n3. 隔两品小3度关系。\n4. 隔3品大三度关系。\n5. 在吉他中隔11品为一个八度，就是12品的位置。\n![](/images/音程性质表.png)\n\n### 二、音程的转位\n![](/images/音程转位1.png)![](/images/音程转位2.png)\n\n### 三、音阶\n在相邻两音之间，有一个音高关系：全音=半音+半音。\n音阶就是以全音、半音以及其他音程顺次排列的一串音。在钢琴上弹奏时全用白键。音阶分为“大音\n阶”和“小音阶”，即“大调式”和“小调式”。\n大音阶由7个音组成，其中**第3、4音之间和第7、8音之间是半音程**，其他音之间是全音程。小音阶**第\n2、3音之间和5、6音之间为半音程，**其他音之间是全音程。\n通俗来说，音乐里的CDEFGAB就是音阶。基本音阶为C调大音阶。\n**全全半全全全半**\n![](/images/相邻音高.png)\n\n### 四、十二平均律\n十二平均律是我国明代音乐理论家朱载堉运用科学的计算首创的定律法：**将一个八度平均分成十二均\n等的音，**其中每个音作为音高的最小单位，称为\"半音\"。两个半音构成全音。在七个基本音中，EF\n和BC之间为半音，其他为全音。\n在吉他中隔11品为一个八度，就是12品的位置。\n\n\n### 五、C大调音阶\nC大调(C Major)是一个以**C音**开始的音乐的自然大调，组成的音有C、D、E、F、G、A、B，**是一个没\n有升号和降号的调。**这个后面再说，有大调和小调之分，不同的调弹出来的情感都不一样。学会这个\n就可以给歌曲变调了。\n\n**C调音阶，吉他的六根空弦音为C调的362573(EADGBE),其中前面36是低音，257(234弦)是中音，\n3是高音。其中EF，AB(3-4，7-1高音)两个音相差半个音。**\n![](/images/音阶1.png)\n![关系调](/images/音阶.jpg)\n\n### 六、如何练习C调音阶\n音阶的练习主要是练习我们音感，能够听到这个音知道是什么，并且知道这个音在吉他的哪个位置。\n右手还是im指法，**练习的时候把唱名唱出来，记住弹的每一个声音，能够做到弹几弦几品知道是什么\n音。**这个音阶的练习并不仅仅像爬格子那样去练习，因为这里要我们记住每一个音，按照爬格子那样\n的话打乱了我们就忘记了。**所以这里的练习时不用六线谱，用简谱符号或者五线谱最好。**\n\n这里是很多网上视频坑爹的地方，他们基本上就是告诉你怎么对照谱来弹，以及一些基本技巧。完全\n忽略了音阶的练习，导致我们到后面都不知道怎么学了，只会看谱来弹，很烦。去网上找一些C调的\n谱子，看着谱子来看看我们能不能把那些音找到并弹出来，弹的时候唱出来，并且可以加入我们之前\n学的节奏，拍子，强弱。\n这些都是新手容易忽略却是非常重要的练习细节。\n\n以下内容复制于网上，可以参考看一下，重点部分我都有加粗。\n\n#### 练习音阶的目的：\n1.大多数音阶，左右手8个手指都用的上，练习音阶可以训练手指平衡能力。 \n2.音阶练习可以**熟悉指板音位**，全部音阶**由24个大小调式组成**，而我们接触最多的欧洲音乐，几乎全\n部属于这些调式，熟悉了音阶，也就大体上熟悉了这些调式。 \n3.实际上音乐就是由完全或不完全的音阶组成的，尤其是旋律声部。 \n4.音阶看似简单，其实严格要求均匀、快速、颗粒感的话，是很难作好的。 \n5.在音阶练习中加入不同的节奏、重音、并力度，并使用所有能够想象的到的右指组合。\n(使用im、ia、ma、pi、pm、pa、ich、mch、ach、ami、ima、mia、mai、pima、pami等等凡能\n够想的到的组合来练习，有的组合可能缺乏实用性，比如ch指加入的组合，但对训练右指作用\n极大)会发现音阶练习真的很博大。 \n6.**音阶练习对左右手协调能力训练作用极大。** 经过训练 ch 指后，**a指难以控制自如的难题**似乎迎刃而\n解。其实练习手指无非是练习大脑对手指的控制能力，手指、耳朵接受并反馈信息，经神经输，大脑\n分析判断、发出指令，神经再传输回去。控制能力的训练是全面的，我以为不应当因为ch 指用的少就不练习。\n\n#### 音阶练习常见的缺点：\n1.做不连贯，象弹顿音。  \n2.颗粒感差，含混不清。  \n3.音色、力度不匀、缺乏统一性。 \n4.右指各指没有独立的拨弦动作，有时是一个手指带出了另一个手指。  \n5.左手指移动时多余动作过多。  \n6.只强调速度，忽视声音质量。  \n7.在四五六弦左指不能作到直起直落，杂音太多。  \n8.缺乏音乐性，表情干巴麻木。\n\n#### 音阶练习的基本要领： \n1.手指垂直起落，**抬起时的高度不可过高，以一厘米左右为宜。**  \n2.为了连贯，**下一指按实前，前一指不能抬起。 ** \n3.左手始终保持恰当的弧度，不能因为换弦而动作走形。  \n4.左指尽量垂直与指板，以指尖按弦，  \n5.发力以按实琴弦为准，不能太大。左指动作要连贯、柔和、自然。  \n6.速度不能求快，应以能够清晰、连贯、均匀地演奏为准，逐步提高。  \n7.高把位注意声音控制，不能“虚”，右指适当加力。  \n8.**最低音和最高音最好强调一下。 ** \n9.右手各指一定要独立完成每个拨弦动作，不能“顺势”带过去，注意想邻的音音色要统一，力度也要统一。  \n10.最好加上**不同的节拍、力度练习。**\n\n\n好了，这一期就是介绍了一些专有的名称，音阶是什么，C调是什么，如何练习C调音阶。\n\n嗯，下期见。","tags":["乐理"],"categories":["音乐与生活"]},{"title":"吉他学习第三弹——认识吉他及手指符号、手指练习","url":"/2018/03/24/吉他学习第3弹/","content":"啦啦啦，我们了解一些知识后，那这一期就开始摸我们的吉他吧。\n\n### 一、品和弦\n学习吉他的时候首先是持琴的姿势要正确(三点)，这个网上搜一下就行了。注意一下持琴的时候左边\n一定不能低于右边，我们的琴可以稍微往外靠一点。\n\n品：我们左手边一格一格的就是品，靠近琴头的是一品，依次往二品，三品...通常在3品，5品，7\n品，9品，12品会**有一个点作为标记，叫做品位记号或者把位记号**，注意看的话侧面也有一个记号便于我们演奏的时候看。\n\n弦：我们持琴的时候从上往下依次叫做六弦、五弦、四弦、三弦、二弦、一弦。其中六弦最粗，一弦\n最细。这些都是规定好的东西，也不是我说的，为了是弹的时候能够说清楚怎么样弹，弹几弦几品。\n\n而这个每一个位置都会对有以个音，比如我们弹六弦空弦的时候，E这个低音。如果按住六弦3品弹起六弦就是G这个低音。\n\n**这里就有一个054555调弦法**，就是利用共振原理，音高相同时发生共振，会引起另一根弦振动。还有泛音调弦，调音器调弦等方法可以调弦。\n1弦为基准，1弦的空弦和2弦的五品的音高一样，2弦的空弦和3弦的4品的音高一样，以此类推。\n![关系调](/images/吉他弦对应的唱名.jpg)\n\n### 二、手指符号认识\n我们的弦和品说明了弹的位置，同样的我们手指也要有标记。\n**左手符号**\n左手大拇指T 食指1 中指2 无名指3 小指4\n\n**右手符号**\np——大拇指(pulgar)\ni——食指(indice)\nm——中指(medico)\na——无名指(anular)\nch——小指(chico)\n左手还有点好记住，右手是不是就觉得很难了，没事，我们可以先**简单记为pimach。**等练多了，就\n自然不用刻意去记了。通常我们用ima控制321弦，用p控制654弦。这个不是非要这样，根据曲子的\n弹奏方式可以自己灵活变通。以后还会学到更多指法。\n\n右手弹奏的方法：\n靠弦法，拨弦法。\n注意：右手弹奏的时候，拇指不要弹进手掌内，拇指稍微往前，弹完的时候在食指的外侧，应用**手指与手掌相连的那个关节（俗称大关节）**发力，否则会影响弹奏的速度和力度。\n(也不知道为什么，我弹了很久的琴后面才知道我的右手其实是错误的，当时我对着视频学习的时候并没有讲到这个，不过我花了一点时间就改过来了。注意：右手拇指靠前一点，拨弦的时候手指沿着略微有点倾斜的垂直琴弦的方向，就是说你的手指弹奏的时候勾弦和拨弦时候**琴弦方向**是往上或者往下的，而不是会往外的。还有就是用手指关节发力，手臂是不用发力的，如果你觉得自己手臂练了一下就很累那就是方式可能不对了。)\n\n\n### 三、爬格子\n接下来说一下手指练习，基础的练习是非常重要的，之前我就是由于练习的方式不对，所以即使练习\n的再多和弦的转换进步也不明显，那么我们就来认识正确的爬格子方式。\n\n**Q：为什么要练习爬格子？**\nA：爬格子是认可对我们手指练习非常有帮助的一个练习。爬格子是为了练习你手指的灵活性和力\n量，你手指的张力，以及左右手的灵活性和配合。比如你按和弦或者转换和弦不顺畅，就是手指\n的力量还有灵活性不够。当灵活性不够的时候你会发现你按和弦非常困难。\n**在1-4品能够练习手指扩展性，9-12品训练的我们双手配合与弹奏速度。**\n\n注意要点：\n1. 各指在弹奏时都应用**手指与手掌那个关节(俗称大关节)发力**，否则会影响弹奏的速度和力度。\n2. 右手触弦的位置应该在音孔附近，太靠前音色偏暗，太靠后音色又偏硬。\n3. 左手臂自然下垂，手腕略向外送出。拇指自然放在琴颈上，手心处要空。\n4. 各指第一指节应以与琴弦垂直的角度用指尖去按弦，**不要折指。**按弦的时候用指尖最前面的尖端，**不要用\n指腹**。按弦的位置应在音品的下1/3处。\n5. 按弦的力量以刚好按住为佳，太大力会浪费，太小又会发出奇怪的音。\n\n### 四、左右手练习——爬格子\n1.练习的时候**一定要标准**，慢慢来。**食指按完不能马上松开，要接着中指，然后中指不能马上松开，\n接着食指换另一个音，这样才可以练习手指的张力。**\n\n2.**想弹下一个音的时候才换，才按下一个音。不能这个音还没弹完就急着弹下一个音了。**\n\n3.**左手拇指，尽量跟中指对应**\n\n4.多练习im指法，这个im就是我们上面说的右手的食指和中指的符号表示，看现在就用到了，为什么\n不用1234表示呢？因为这都是先前就规定的，属于国际符号。im指法的练习，有利于在我们需要连续弹一根线的时候，**声音连贯性会更好。**\n\n**注意：**如果以后我们练习一些谱，不要非要用ima控制321弦，用p控制654弦。很多吉他谱都不会标\n明右手用哪个手指弹，如果我们什么谱都按照这种规定，就会发现有些谱很难练，练了很久也不知道\n为什么就是练不好。这里我们的im指法就是一种指法，还有很多指法，这些指法都是能够在以后用到\n的。**所以一定要认真练im指法。**\n\n**右手练习**\n![](/images/右手练习1.png)\n这些写的并不是很完全，在这里用文字做一些补充。\n四二拍： 6321、6 3 21 3\n四三拍：6 3 21 3 21 3、 6 3 2 1 2 3\n四四拍：63231323、 6 3 2 1延 3 2 1\n可以自己去找一下左右手常见的节奏型来练习，我一开始学吉他的时候\n没有注重练习，现在觉得很重要，又重新练了起来，这对于我们的左右手非常有帮助，以及我们的节奏。最后，当练习好左右手的时候，可以机械的不用经过大脑思考就能弹出的时候，这个时候我们就想着听，然后自己就弹出来了，就好像虽然是你自己在弹，但是给你感觉却是你也是听众，你在听着一首好听的曲子。\n**左手练习**\n![](/images/左手练习1.png)\n\n\n嗯，这一期说了如何正确的练习我们的手指，这样才能保证我们后期的练习。如果抛开这些直接练习\n和弦就会非常困难，甚至付出了很多得到的回报并不多，这会很打击你的信心，并且你还不知道为什\n么练习了那么多，但是还是按不好，换不好和弦，很烦人对吧。所以一开始就认真正确的爬格子才是\n最实在的。如果不太明白的就多看几遍。重点是手指的练习，一定要按照正确的方式。\n\n好了，下期见。\n\n","tags":["乐理"],"categories":["音乐与生活"]},{"title":"吉他学习第二弹——唱名与音名、音符与休止符、拍号","url":"/2018/03/24/吉他学习第2弹/","content":"又开始学吉他咯。\n学习吉他之前我们先来了解一下乐理知识，为什么要学乐理知识呢？最简单的是为了看谱，其次重要\n的是了解我们弹的是什么，当你了解这些你就可以改编曲子，自创曲子，升调降调原曲。**如果只是看\n谱练习就实在没意思，这样只能说是单纯的会弹，而不是懂的弹。**这个也是后来练习我遇到的一个瓶\n颈，因为我随手就拿来一个谱子疯狂练习却忽略了很多基础的练习，是非常严重的错误。所以一开始\n就练习乐理知识，从一个正确的方式开始是非常重要的！！！\n\n### 一、唱名\n唱名就是用来唱的名字，在乐理中用Do Re Mi Fa Sol La Si表示，很熟悉吧。即使没有学过乐理的人\n也听过吧。\n\n**Q：那这个唱名要怎么样练习？为什么要练习这个唱名？**\nA：这个要求我们会唱就行，什么叫会唱呢，要唱的对唱的准，音高一样，这个练习可以下载人人钢\n琴或者freepiano软件来练习，按的时候把音高唱出来，而且不要一直以Do Re Mi Fa Sol La Si的顺\n序练习，可以换一下，比如Re Do So。还可以随便按几个，然后我们看看能不能听出来是什么，这个\n练习的目的是为了练习我们的音感。你想，如果别人弹了一首曲子，你一听就知道是哪个音，一听就\n知道他按的是那个键，一听就会弹那该多棒啊。并且前期的时候吉他练习可以用简谱或者五线谱，不\n要依赖六线谱。如果想学好，这个是必须的，不要抗拒五线谱和简谱。\n![](/images/人人钢琴.png)\n\n### 二、音名\n上面是我们唱出来的，既然我们有了唱名，那这个唱名也要有个名字吧，这个就是音名。我们用C  D  \nE  F  G   A  B表示。这个C就是我们唱的Do，D就是Re，以此类推。\n\n**Q：为什么是从C开始，不是从A开始呢？**\nA：据说字母“A’”是牛头的象形，以后才倒过来写，当时牛在人们的生活中占有很重要的地位，所\n以字母“A”被排在首位。中世纪早期，希腊人用字母标记音高时，字母“A”也是首先被采用，当时\n的一种调式音阶的第一个音就是“A”。以后经过演变，音名音高被固定下来，各种调式相继出现，\n逐渐形成了以大、小调式音阶为主的音乐理论体系。这两种音阶又与中世纪音乐有一定的联系，小调\n式音阶还是从“a”开始，只是要用小写字母，以区别于大调式音阶。大调式音阶则因为物理上和使\n用方便的原因（如C大调音阶在键盘上全是白键），则以“C”音为音阶里的第一个音。近代音乐理论\n是以C大调为基础的，因此音名序列也就习惯成自然，变成以“C”为主了，并将“C”排在音名的首位。\n\n要做到看到音名就能说出唱名，这些都是要练习的，不能小视啊。可以找一下谱子来读一下。\n\n### 三、音符\n我们需要一种符号来**记录音的长短**，这就是音符，不然的话我们怎么知道这个要弹多久啊。\n通常有以下几种，每个音符都有自己的写法表示：\t\n**全音符 二分音符 四分音符 八分音符 十六分音符 三十二分音符**\n![](/images/音符00.png)\n注意到了吗？这里的写法是5然后加上自己的符号表示，这个5就是简谱符号，可以是1234567。\n只是我们通常用5来表示，像如果我写**4-**也是一个二分音符哦。\n\n**Q：那音符与音符之间是如何转换的？**\nA：音符的时值采用二进制，即两个八分音符=一个四分音符\n全音符=两个二分音符=四个四分音符=八个八分音符\n一个四分音符=四个十六分音符\n\n**Q：这个音符说用来记录音的长短，那是以一个什么样标准，比如四分音符是多少？**\nA：时值就是我们一个时间的长短，而时值的单位为\"拍\"，那一拍又是多少呢？当我们手从一定距\n离拍一下回到最先的位置就是一拍。严谨的乐谱都标明了拍速，即每分钟应该弹多少拍。通常我们\n用一个**\"V\"字**表示。\n\n打拍子对于我们的节奏感是非常有必要的，一开始的时候千万不要很随便就按照自己方式去练习。训\n练的时候一定要跟这节拍器练习，可以用脚跟着节拍器打拍子，手上弹一拍脚下同时打一拍。\n\n一开始练习的时候手跟脚练习可能不自然，可以先分开练习，再做到自然。当我们弹吉他的时候，右\n手的动作是不停止的。这个训练一定要配合节拍器练习哦，不能凭自己的感觉用脚打。如果节奏感没\n有练好，弹出来的吉他就会没有感觉。之前我节奏感一直没有认真练习，完全是靠感觉弹的吉他，自\n己听可能听不出来，但是别人一听就知道节奏有没有对。\n\n这个是觉得不错的[在线节拍器1](http://www.daweijita.com/7315.html/comment-page-1)&nbsp;&nbsp;[在线节拍器2](https://www.jitatang.com/jiepai)\n不知道以后有没有机会学钢琴，先存个教程网站吧，[人人钢琴](http://www.everyonepiano.cn/Article.html)\n![关系调](/images/音符.jpg)\n\n### 四、休止符\n休止符就是不弹，这个好理解，不过**需要注意休止符的写法是有些不同，二分音符是00并不是0-哦**\n![](/images/休止符.jpg)\n\n### 五、拍号\n![](/images/拍号.png)\n如图中，我们的谱子都会有一个**3/4**这样的表示，四三拍。这个就是我们的拍号，用来表示节奏，\n我们有了音符表示拍子的速度，那肯定要有能表示多少拍的符号，这个就是拍号。\n**3代表每小节三拍，以四分音符为一拍。那这样就好办了，四分音符为一拍，那么我们的一个八分音\n符就是半拍。**这样你就知道了，哦，我要弹多快，多久弹一次，要弹多少次。\n\n**强弱关系**\n强弱是用于突出层次感，把主要的音强化，辅助的音弱化。相同的谱子强弱不同弹出来的感觉都会不\n同。通常来说就像上面图那样，四四拍就是强 弱 次强 弱，四三拍就是强 弱 弱。不过这个要看乐句走\n向，上面的也只是通常情况。像我们扫弦也会用这个强弱体现层次感。\n\n比如我们的5323 1323一个四四拍，在这里我们可以把5323中的**2**和1323中的**1**弹的重一点，这样就比别人弹的好听点。\n\n一拍念作\"哒\"，空的时候念\"空\"，除了用脚打拍子，我们练习的时候也可以嘴巴喊出来。\n\n### 六、总结\n```\n简谱符号 1  2  3  4  5   6  7  1\n音    名 C  D  E  F  G   A  B  C\n唱    名 Do Re Mi Fa Sol La Si Do\n级    数 一 二 三 四 五  六 七\n和    弦 C  Dm Em F  G   Am    C\n```\t \n在吉他中每一个音有一个级数，比如C和弦就是一级和弦。\n\n\n这一期讲了唱名，音名，音符，休止符，拍号，以及强弱来突出层次感，这些都是我们弹奏看谱时候\n用到的技巧。后面还会反反复复提到这些知识，打拍子和唱名这些一定要练习哦，要做到看到音名或\n者简谱符号就能唱出唱名，唱出对应的音高。这些真的非常非常重要，初学就要以一个正确的方式去\n练习。好了，下期见。\n\n\n","tags":["乐理"],"categories":["音乐与生活"]},{"title":"吉他学习第一弹——吉他入门","url":"/2018/03/24/吉他学习第1弹/","content":"### 第一把吉他\n大家好，这里是HanaeYuuma的博客。又开了一个新坑了，在这里记录我学习吉他的一个过程。在这\n里我会从头开始写一篇吉他初学教程，对初学的知识做一个总结和记录。老实说当写这一系教程的\n时候我还是一个入门的小白一个，所以写的文章如果有错误的地方请多指正。大学自学过一段时间\n学的断断续续，现在回想起来其实也不算太努力。归根还是因为错误的练习方式，当我练习了很久\n却没有进步的时候阻止了我继续练习，如果每天坚持弹说不定也不会像现在一样只会几个和弦。\n\n现在又重新拾起了吉他，因为我终于意识到了我以前的练习是错误的。在踩坑方面，我还是有很多\n话可以说。目前很多网上视频教程都只是简单的教你一些看六线谱，然后一些基本的弹奏技巧，但\n是忽略了一个重要的细节就是**乐理知识和音感的练习**。这些都是需要我们能够在吉他上面表现\n出来的，而不是按部就班六线谱上弹奏，我们要知道我们弹的是什么，是什么样的音，为什么要这\n样弹。然后我们还可以自己扒谱子，编曲和改编，这个才是学习吉他的最大乐趣。而这些都是很多\n视频教程坑的地方，基本就是教完你会看几个谱子，会弹几个和弦就够了，然后再推荐你买吉他。\n现在想起来，没有老师教被这个坑了很久，而这个是一个大坑。很多教程都不会告诉你为什么要这\n样做，对啊我们为什么要这样做，为什么要用C和弦，G和弦。对啊为什么？音阶练习网上也不会刻\n意说明这个重要性，基本上觉得你会几个和弦会弹几首就可以了。而这些，作为你继续深入练习来\n说，是一个误区。所以如果你还在看一个视频教程，多想一下为什么我们要用这几个和弦练习。而\n不是上来就练习，然后天天在那练几个和弦的转换，如果不知道为什么真的没意思。在这里，我就\n是想说一下为什么。\n\n好了，那么下面开始说说吉他的入门，我先默认你是了解过吉他的或者准备开始学吉他的。对于吉他\n入门，我没有建议，有的只是自己的心得。毕竟我在练习的过程中遇到了很多问题，我可能算是比较笨的一个了。\n\n#### 一、吉他的选择\n首先是吉他的挑选，这个我不太了解各个牌子，材质。而我也只有一把吉他，所以做不了推荐。**贴吧\n里也很多做新手推荐琴，实际上是卖琴的无道德商家，这个要特别注意。**但是注意一点就是，不要贪\n便宜买劣质的吉他，烧火棍不仅音色不行，做工等等，很容易打击你的信心，还有影响你的听感。总\n之合适的才是最好的，经济不够的可以买学长的二手吉他，手感往往还可以的，自己小心点不要被坑\n了。无良的人很多，你分不清谁好谁坏，被坑点的钱贵点是其次，但是最怕被坑钱了还买的是垃圾。\n**买吉他需谨慎！**\n\n**心得：**这个我为什么要这么说呢，因为我的第一把吉他我弹了很久，当我弹别人的吉他时候，我就觉\n得很舒服，你会想我的什么垃圾吉他，别人的吉他按和弦容易多了。所以初学者的话建议吉他价位不\n要太低，如果暂时不够钱，就努力攒先，千万不要为了急而买把烧火棍。如果你经济支持当然越高的\n品质更高了。还有一点非常重要，初学的时候一定要找一个懂吉他的人帮你调好吉他，这个调好不仅\n仅是说调音，还有其他的比如弦高，以及琴弦合不合适。\n\n### 二、配件的选择\n买了吉他之后，你就可以去网上搜一下吉他结构，了解吉他的结构。\n![](/images/吉他结构1.jpg)\n其他的设备的话，效果器，拾音器，音响有能力就买吧。常见的配件，比如：拨片，调音器，变调\n夹，卷弦器，剪弦器，置琴架，背包，琴谱架，弦距调节器等等。\n\n上面说的这些都不贵，而且用起来非常方便。按照自己的需求来买吧。\n\n### 三、说说换弦吧\n换弦一般是因为弦断了就要换了，还有一种情况是弹久了，氧化了。换弦之前首先要了解一下买什么\n样的弦，同样的我不想说牌子，低到几十贵到几百块甚至更好的都有。我只说一下一般买弦的时候介\n绍会写清楚粗度，或者标明L,xL之类的，一般我们初学者买的**012-适中的，或者说L的**，太软的和\n弦并不是最好的，因为这样很难训练到你的手指。如果觉得困难就买软一点但是不要太软的。\n换弦的技巧，我换弦算换的多了，开始就先松开，**顺时针的方向是紧，逆时针的方向是松，这个是以\n你面对弦扭方向，所以左右两边的你不要扭错扭反，不知道我说什么的，开始先试着扭，看看什么方向是紧和松。**\n\n主要说一下卷弦的方向，**这个你把弦穿过琴头的那个弦孔，然后用卷线器逆时针方向扭动就可以了。**\n说的再细一点，**弦不是从弦孔出口那头开始卷的(下图中的1)，而是下图中的3就是你要卷多少卷的长\n度卷动的过程你会发现下图中的2位置的弦一直往收缩方向**。多余的弦就用剪弦器剪掉，如果没有就\n自己想办法吧。\n![](/images/换弦1.png)\n\n### 四、吉他的保养\n吉他就像是我们的爱人，你要好好呵护她，每次弹了之后就要用干净的布擦一下，然后空气温度湿度\n对吉他的影响都很大，不弹的时候就放在背包里吧。长期不弹就把弦松了然后放到背包里。琴弦是几\n个月换一次，小心磕碰，最好有一个置琴架子和背包。不要给家里的熊孩子随便碰。\n\n\n### 五、总结\n这一期就基本讲了对吉他的认识，选择和保养要注意的东西。网上还有很多具体的说明，可以去查来\n看看。好了，这一期就到这里了。下次就开始说乐理知识了以及一些我认识正确的练习方式。\n\n好了，下期见。","tags":["乐理"],"categories":["音乐与生活"]},{"title":"吉他学习第零弹——简单的歌唱入门","url":"/2018/03/24/吉他学习第0弹/","content":"唱歌是很开心的事情，但是唱歌是我最不擅长的事情了，事实上我感觉自己五音不准，并且一点都不会唱歌。我在网上看了一些唱歌的教程，可是对我这种理解能力差的来说并不起作用，看了很多都不知道如何唱歌，找不到感觉。所以我对唱歌还是零基础，并且我的声音唱歌也不好听。所以不要叫我唱歌。\n\n可是有时候还是会自嗨哼起歌来，我曾经问过一些朋友怎么唱歌，但是大多是说的模糊，或者说的不多，毕竟唱歌不是几句话就能说完的。自学唱歌是一个反反复复循环探索的过程，我也把这些我看过的放在这里，不管有没有用，懂不懂，就先记着吧，说不定那天就领悟了。\n\n### 一、 歌唱的呼吸\n**补充：吸气的过程，腹腔，胸腔，腹腔侧肌，这个过程中小腹这里是收缩的，要用力**\n**用横膈膜来支撑你的呼吸，找到这个支撑点。**\n(1)吸气\n想象自己处于一个美丽的花园之中，深深地闻了一下鲜花的香味，这就是唱歌时的吸气。吸气要用**鼻和口**同时自然地进行，尽量做到平稳，轻巧，柔和，不可用强制力量，不能僵，**气要吸得深，不可吸在上胸和心窝处**。吸气以后，要像打喷嚏那样短暂的一憋，体会一下**腰**周围的扩张，膨胀的感觉。找到这种感觉是歌唱的关键。\n(2)呼气\n呼吸的方法就是利用**横膈膜**的理论，**把腰圈扩张的感觉一直保持住**。想象自己手里拿着一大瓶香油往一个小瓶里灌时那种小心翼翼，憋住气息的感觉，呼吸要均匀，舒缓。各位可以准备一张10平方厘米大小的薄纸片，放在墙上，距离它4-6公分，吸气后保持一下，然后用口吹起使之不落地，坚持半分钟以上便合格。\n(3)怎样训练横膈膜的力量\n1. 数数字：深吸一口气，利用腰圈的力量将它保持住，从1开始数，数到60为合格。数数要均匀有节奏，不能偷气。\n2. 吹灰：深吸一口气，然后就像吹调桌上的灰尘一样往前吹气，节奏是一慢二块，体会横膈膜的力量。\n3. 多做仰卧起坐，增加**腰腹**的力量。   \n![呼吸](/images/呼吸.jpg)\n\n### 二、歌唱的共鸣\n有了正确的呼吸后，便可以开口唱歌了。气息振动声带发出的声音是原始的基音，要使歌声圆润，悦耳，只能通过共鸣。我们唱歌主要利用的共鸣腔体有：胸腔、咽腔、鼻腔、头腔。声音要好听，必须在唱高中低音时都有部分胸腔以上的共鸣，也就是\"声音的高位置\"。\n(1)歌唱的基本状态\n要获得声音的高位置，**必须放松喉头，内收下巴，这两个器官不能再歌唱中用力**。很多人唱高音都是靠挤压喉头发声，这是错误的方法。应放松喉头，使之成为气息的通道，然后抬软腭，提笑肌，使声音能通向鼻腔。\n(2)共鸣的位置\n一般来说，演唱低音时以胸腔共鸣为主，同时挂上鼻腔，否则声音会显得呆板、浑浊；到中阴、高音后，高位置\n共鸣腔比例逐渐加大，以鼻腔共鸣为主，**同时也要有一定的胸腔、咽腔共鸣**，这样声音才既明亮、清澈又饱满、圆润。\n![发音器](/images/发音器.jpg)\n### 三、其他\n**通过摇头可以放松喉咙**   \n高音时可以用气息支撑\n\n真假声的位置\n真声：惊讶式呼吸状态下咬字，口腔稍微打开。找到气息吸进去的位置，放松身体，口腔立体。\n假声：小声哼唱高音可以找到假声位置，嘴唇鼻腔之间，口腔后部闭合\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t","tags":["乐理"],"categories":["音乐与生活"]},{"title":"我与音乐的相遇","url":"/2018/03/24/吉他学习第00弹/","content":"\n### 年少的日子\n年少不懂的日子，幸好有着劣质便宜的mp3陪伴我度过了我的初中时代。\n\n当我第一次对音乐震撼的时候，大概是高中的时候，同桌用他的耳机给我听了一首歌，可我现在不记得那首歌了。但是我至今记得那是我第一次用着接近百元的耳机听到时候的震撼，那种架子鼓的敲击感，那种安静而又兴奋的感觉。\n\n### 高中时期的音乐日子\n我第一次知道了原来耳机听歌是这么快乐的事情，原谅我的无知以前我用的都是路边摊的那种噪音很大很嘈杂还有电流声的耳机，那时候听歌就是随便一听。但是就是因为这一次，我开始喜欢上了音乐。可是当我去了解想去学习音乐的时候，我查了很多资料看了很多东西，然后经济限制了我的想象力。一开始想学的是吉他，因为钢琴这些我根本买不起，其他架子鼓也不方便，bass也不适合我。然而我也没有钱去买吉他，听说吉他容易撩妹，当然一开始我有一丝这样的想法。我那时候就想买一副好的耳机，还有一把吉他。当然我那时候不知道播放器和声音的音质对声音影响也那么大，不然我那时候应该会想买一台播放器设备和CD。\n\n于是高中那年我买了人生中的第一副上百的耳机，那时候对我来说真的是奢侈品。当没有吉他的时候，我就上网看着网上的介绍学点吉他的知识，当然那都是自嗨。有幸朋友在学校的音乐社有点交情，那时也摸过吉他，不过也只是自己简单玩一下，并没有学到太多。\n\n### 第一把吉他\n当大学的时候，我终于存够钱买了第一把五百块的吉他。那时候就拼命练习，天天军训回来就练吉他看着网上的视频，乐此不疲。网上的教程都看懂了，我坚信着只要多加练习就能有很大的进步。终于在一个月后有了进步，可是从此就没有什么进步了。之后断断续续练了一两个学期，我接受了现实。\n\n### 音乐 停止了\n是的，就这样停止了。我遇到了很多问题，而我不知道怎么解决，这个时候我对音乐也许谈不上喜欢吧，大概就是想学音乐。比如节奏感不行，扫弦不好听，和弦按不了，我不知道如何去改进。最困扰我的就是我的手指长度，我量过我的中指只有7cm左右的长度，我练习了很久F和弦，试了网上很多方法，可是也只能是勉强弹。**有时候弹吉他感觉手指不够长想按住会有略微的抽筋感觉。**不知道看到这篇文章的朋友能否指点一二，打通我的任督二脉。\n(2018-7-14补充，前几天表弟去学吉他，开始的第一节课我去旁听了一下，老师是一个年过半百却依然幽默风趣的男老师，他讲了很多东西，我认真听了后真的受益匪浅，我对左手按弦和右手拨弦有了新的认识，我又发现了我以前还是有很多小问题，我又开始练习有了改进)\n\n我在网上找了一点，不知道有没有用\n**练左手的手指操是：\n第一节：把右手拇食指放于左手拇食指之间，用右手拇指第一指节向外推左手拇指第一指节，右手食指第二指节向外推左手食指第二指节，就像给左手手指劈叉！\n第二节：将右手拇指、食指放于左手食指、中指之间，右手拇指第一指节轻压左手食指第二指节，食指指尖推中指指尖，同时向外用力，嘴里喊1.2.3，第三，四节是依次换左手手指，方法同！\n练右手的手指操是：\n预备动作：左手放松手指轻拢，右手拇指盯住左手掌心，手指并排放于左手手背中央,\n第一节：右手食指不动，其他手指抬起。然后，其他手指放下，食指抬起，反复进行。嘴里默数 123。然后再中指抬起，其他手指放下，其他手指放下，中指抬起，反复进行嘴里默数123.其他的手指依次进行 .....\n**\n\n不过我知道手指长短并不能阻碍弹吉他，曾经我有一段时间狂练F和弦的曲子，可是最后结果都不尽人意。没有老师的指导，我遇到很多问题都解决不了，阻碍了我前进。是的，我接受了现实。从此，我放下了吉他，毕竟年轻的日子不会太久了，以后需要工作，我开始对工作的寻找和编程学习。我把吉他放进了柜子里，琴弦松了，就这样她在柜子里待了很久。\n\n### 表弟的吉他\n当我有一天放假回家的时候，看到了表弟和堂弟都在学吉他，家里人听说我也买了吉他，就想着让我去教，可是我自己根本就是小白一个。但是还是说起了一些简单的入门知识，我很不想说，因为这样对我来说我不知道是对的还是错的，万一是错的就会误导。后面表弟去找老师学了十天，结果来说还算不错，那时候挺羡慕他有老师教。那十天是买吉他的免费教学，当十天过后就是自学了，那时他的老师还举办了一个表演，他很兴奋的说他去表演了，而且还弹的错。我当时听了也觉得蛮不错的，就建议他继续找老师学。可是由于学习和家里经济的支持并没有选择继续找老师，他拿着吉他回到了家。当我再次遇到他，问他弹吉他怎么样了，他说没怎么弹，在家的时候并没有太多的时间去弹吉他。而我也仿佛看到了那个曾经冲动的谈学吉他的自己，三分钟热度的自己。\n\n我对音乐，对于吉他，也许谈不上喜欢吧。\n\n### 重新拿起了吉他\n许久不弹吉他，已接近毕业的时间了。可是当我再次看到吉他的时候，还是会有想拿起来弹一首的冲动，刚好最近在学习的时间喜欢写文章记录东西，索性就以**音乐**为目录写一个吧，就记录自己学吉他学音乐的过程和心得，吐槽也好，感慨也罢。就这样继续开始学习吧。\n\n在那些休息的日子里，还能拿上一把吉他，弹一首喜欢的曲子。\n\n","tags":["乐理"],"categories":["音乐与生活"]},{"title":"2017年的回忆与总结","url":"/2018/03/14/2/","content":"<Excerpt in index | 首页摘要>\n\n2017年3月3日的那一天，有些无聊，生活的枯燥和迷茫让我的内心很压抑，心里总想有个诉说的地方，于是便萌生了弄个人网站的想法。在没有任何网站搭建知识基础的我，找了很多教程，最后发现了Hexo非常适合我。原因很简单：简单、免费。如今想不到已经过去了一年的时间了。这一年的时间里并没有写太多的东西，因为我实在想不到写些什么。这些东西写来只有我一个人看，这样的话我可以随便写什么，也不担心有人看。不过万一有人看到了误导了也不好，索性就空着等想写的时候认真写点什么。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n在大三上的学期里，报名了学车，想着这个学期拿到驾照，毕竟驾照已经成为了一种必备的技能，你老是让老司机带你怎么行。平时练习的时候没有什么太大问题，半坡虽然有点想要熄火的样子但没有熄火，想着考试应该过了吧，结果两次都在半坡下课了。原因很简单，我对半坡的理解有误，说出来可能会有些人笑话了，我以为半坡起步刹车放完之后，就慢慢放离合上去了。其实并不是，最好是稳住离合然后慢慢上去，上去之后就可以随便放了。后面考完的时候我才发现这个问题，然后快要补考之前练习了几圈就一次过了。其实我们的教练说的很清楚，只是我自己理解错误了。他是一个好教练，很多时候你遇到的问题他都会告诉你为什么，但是也有这种我自己的问题，而教练不知道什么的问题。\n\n上学期的时间断断续续学了一些JavaWeb的内容，可是一个学期结束后并没有记得多少，只是渐渐对这个体系有了了解。在学习的过程中，我遇到的问题基本上都是我一个去解决的。在这个过程中，其实是很痛苦很打击人的，因为并不是所有问题我都能自己去解决，我至今还是存在很多问题并且还在思考中。所以如果可以，建议还是找一个老师，当然这个老师并不是单指那些授课的教师或者培训机构的老师，这也可以是拉上自己的一个小伙伴或者网上的热心网友一起学习。有讨论的问题才容易得到解决，不然你就得像我一样，一个人讨论，想破头皮，然后头皮发麻。可能你会觉得为什么我说的要和别人交流讨论，自己却不去做反倒一个人思考，根本不知道在表达什么。\n\n\n### 老师，这道题怎么解？\n老师说你自己看书吧，在初中生物课本七年级下的第9页。我们继续接着上面，我换一种表达方式。有人指导你方向会更好，因为我们问的很多问题，**其实当你有个体系和了解一些原理后就可以自己解决**，所以我遇到的问题不是什么都拿去问别人，如果问题过于低级也是浪费大家的时间。这些技术性的问题，如果是一开始学习，其实好好理解学习的内容的原理就可以了，但是有些就不可以了，比如一些超出你知识体系范围太多的东西，例如你想了解Linux的一些高级应用，这个时候你就必须从头开始学习，这个**需要一个基础的东西**。如果有老师的话就能告诉你一个学习的方向是最好的，比如说苍老师就是一位好老师。你如果问我苍老师是谁，我其实也不知道，只是谈起的人多了，就渐渐知道了这个名字。就像我没学过拍黄片，但是也听过很多人说过。当我去搜索的时候，就会告诉我，苍老师是日本的一名AV女优，拍黄片是一种很多人都不太愿意做的工作，跟鉴黄师一样需要整天对着电脑进行修改和处理。所以也不要随便问别人一些在你体系范围内的知识，我的一些朋友也会问我一些关于电脑遇到的问题。可能你会感觉愚蠢和简单的问题，但是我都是跟她说帮她解决，因为我知道她只是想解决这个问题，并且如果她想自己解决她需要学习这个方面体系的东西。乐于助人是中华的传统美德，况且是我们的女生，我当然是很开心了。\n\n\n### 没有一个好的学习环境，我该如何去学习？\n接下来也说一下很多人在学习困扰的地方吧，就是一个学习环境。好的学习环境能给人带来很多的益处，但是这个学习环境不是我们想就能够营造出来。大多数时候，宿舍通常是一堆人天天玩着游戏，毕竟大家没女朋友嘛，基本就是没课都在宿舍了。这个时候其实想好是需要一定的定力的。我学习的地方大多时候是在宿舍，偶尔带着笔记本去过几次图书馆，但是反倒没有在宿舍好。怎么说呢，首先，在图书馆没有适当的地方进行充电并且没有网络(不过现在已经开通了校园无线网络覆盖)，在学习的过程中难免会遇到问题，这个不查不行，况且我的流量那时候不多，后面改成了校园无限流量的套餐。其次，如果在图书馆自习室敲代码，里面的人大多数考研或者考前来得到心灵的安慰，你吵到别人也不合适。最后，是我这个人的一个坏毛病，有时敲代码就会连续不断的敲，累了就想直接上床躺会儿，然后下来继续敲，如果是在图书馆我就不能想休息就休息。\n\n后来由于要找工作的压力，就开始静下来戴上耳机就能学习，这个时候你会发现找工作压力已经让你能够忽视外界的环境干扰。宿舍并不是不能学习，这个问题我也没有明确的答案，我的认为是需要自己慢慢调节找到适合自己的学习节奏吧。也是由于要学习的原因，我开始了继续维护写博客，我把我学的东西和内容就写在这里，大多数是我的笔记，估计也没人看的懂。当我想要复习或者找一些东西的时候在这里找就非常的方便。\n\n### 过年遇到的问题\n2018年回家的是时候，感觉算好了很多吧，心态也变平淡了很多。大多数的时间里更愿意陪着家人了与此同时在家的时候学习的时间由我安排，不会像在宿舍如果有人喊的非常厉害就很难受，过年的时间亲戚也开始谈起了结婚、车、房子，不再问你在学校得不得奖，考的怎么样，我很无奈地笑了笑并不想理会。长辈关心你的成绩，却从不关心你其他方面的知识发展，这种是很不好的，他们会向别人炫耀你在学校成绩有多优秀，可他们并不知道你对其他知识的渴望。后来年纪大了一些，也渐渐明白了这点，在我父母的一辈大多数是很早就出来工作了，毕竟那时候信息并不像如此发达，我时常希望父母能够多去了解一些东西，看看书，可是他们的目标就很简单的希望我好，然后家庭幸福安康。我很感动却也很难过，我多么希望他们也能够去追求喜欢的东西。我问过妈妈:\"其实你也可以去学习英语，看看书，或者学习乐器唱歌，学摄影，画画艺术这些。做一些你年轻时候想做就没有做的事情。为什么不去呢？\"人如果没有对自己的追求，我想会是一件难过的事情。于是我也开始重新拿起了吉他。也希望在未来的日子里，能够学学唱歌，摄影，画画，学一门喜欢的运动，不要等到热情和喜欢退却了。\n\n### 学无止境\n学习真的是一件使你快乐的事情。2018年，然后驾照也差不多到手了，可以安心的学习不用每天去练车了。这一年，好好学习，找一份工作。","categories":["千纱镇辉夜小屋"]},{"title":"排序算法工具包","url":"/2018/03/12/数据结构-第6章/","content":"```\nimport java.util.Arrays;\nimport java.util.LinkedList;\n\npublic class Sort {\n\tpublic static void main(String[] args) {\n\t\t//测试\n\t\tint[] arrays = {123, 11,20,66,78,139,144,10};\n\t\tBucketSort(arrays,144,10);\n\t\tfor (int i = 0; i < arrays.length; i++) {\n\t\t\tSystem.out.print(arrays[i]+\"\\t\");\n\t\t}\n\t}\n\t\n\t/**\n\t * 插入排序-直接插入排序(Straight Insertion Sort)\n\t * @param arrays\n\t */\n\tpublic static void StraightInsertionSort(int[] arrays){\n\t\tfor (int i = 1; i < arrays.length; i++) {//大循环只要排length-1次，因为默认第一个排序好了。\n\t\t\tfor (int j = i; j > 0; j--) { //从第二个记录开始和前面的比较，如果大于就交换，没有就直接退出\n\t\t\t\tif(arrays[j] < arrays[j-1]){\n\t\t\t\t\tint temp = arrays[j];\n\t\t\t\t\tarrays[j] = arrays[j-1];\n\t\t\t\t\tarrays[j-1] = temp;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;//没有交换就直接退出这次for，直接下一个记录\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * 插入排序-折半插入排序(Binary Insertion Sort)\n\t * @param arrays\n\t */\n\tpublic static void BinaryInsertionSort(int[] arrays){\n\t\tfor (int i = 1; i < arrays.length; i++) {//大循环只要排length-1次，因为默认第一个排序好了。\n\t\t\tint temp = arrays[i];  //要插入的第i个记录\n\t\t\tint begin =0; //标记排序好的头部\n\t\t\tint end = i-1;//标记排序好的尾部,第i个记录位插入的数据\n\t\t\twhile(begin <= end){\n\t\t\t\tint mid = (begin + end) / 2;\n\t\t\t\tif(temp > arrays[mid]){//在右边\n\t\t\t\t\tbegin = mid + 1;\n\t\t\t\t}\n\t\t\t\tif(temp < arrays[mid]){//在左边\n\t\t\t\t\tend = mid - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*当找到位置的时候，此时begin的位置就是插入点位置，begin后的数往后移动*/\n\t\t\tfor(int j = i; j> begin; j--){\n\t\t\t\tarrays[j] = arrays[j-1]; \n\t\t\t}\n\t\t\tarrays[begin] = temp;//插入i\n\t\t}\n\t}\n\t/**\n\t * 插入排序-希尔排序(Shell Sort)\n\t * @param arrays\n\t */\n\tpublic static void ShellSort(int[] arrays){\n\t\tint gap = arrays.length;\n\t\twhile(gap > 1){ //增量如果为1就结束\n\t\t\tfor(gap = arrays.length/2; gap>0; gap /= 2){//增量逐次减半\n\t\t\t\tfor(int i = gap; i<arrays.length; i++){//i：表示从gap开始到length的数  gap   gap+1  ...  length-1\n\t\t\t\t\tfor(int j = i-gap; j>=0; j -= gap){//i-gap：表示gap开始前面的数        0     1\t\t ...  gap-1\t\t\t\t\n\t\t\t\t\t\tif(arrays[j]>arrays[j+gap]){//gap前面的数 和 gap后面的数 比较大小\n\t\t\t\t\t\t\tint\ttemp = arrays[j];\n\t\t\t\t\t\t\tarrays[j] = arrays[j+gap];   \n\t\t\t\t\t\t\tarrays[j+gap] = temp;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * 选择排序-直接选择排序(SelctionSort)\n\t * @param arrays\n\t */\n\tpublic static void SelectionSort(int[] arrays){\n\t\tfor(int i=0; i<arrays.length; i++){\n\t\t\tint minIndex = i;//minIndex为每次找到的最小的值\n\t\t\tfor(int j=i+1; j<arrays.length; j++){\n\t\t\t\tif(arrays[j] < arrays[minIndex]){\n\t\t\t\t\tminIndex = j;//找出每一次数据中最小的\n\t\t\t\t}\n\t\t\t}\n\t\t\t//如果minIndex和当前的第i个不是同一个数就换，这样第i个位置就是最小的\n\t\t\tif(minIndex != i){\n\t\t\t\tint temp = arrays[i];\n\t\t\t\tarrays[i] = arrays[minIndex];\n\t\t\t\tarrays[minIndex] = temp;\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\t/**\n\t * 选择排序-堆排序(HeapSort)——第一步\n\t * 调整大顶堆\n\t * 从i节点开始调整，n为总节点数。   i的子节点为：2*i+1 和 2*i+2\n\t * \n\t * 一个父节点的子节点数的取值范围为[0,2],子节点数为零的父节点常被称为叶子节点。\n\t * 每一个父节点又可以看成是其子树分支的根节点。 \n\t * 2*i、2*i+1 、 2*i+2\n\t * 0 1 2 \n\t * @param arrays\n\t * @param parent\n\t * @param length\n\t */\n\tpublic static void MinHeapFixdown(int[] arrays, int parent, int length){\n\t\tint child = 2*parent+1;//获得左子节点\n\t\tint temp = arrays[parent]; //保存当前父节点。\n\t\twhile(child < length){\n\t\t\t/*如果有右子节点，child+1为右子节点，并且右子节点大与左子节点,则选取右子节点*/\n\t\t\tif(child+1<length && arrays[child] < arrays[child+1]){\n\t\t\t\tchild++;\n\t\t\t}\n\t\t\t/*如果父节点的值 > 子节点的值， 结束*/\n\t\t\tif(temp >= arrays[child]){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*把子节点的值赋给父节点*/\n\t\t\tarrays[parent] = arrays[child];\n\t\t\tparent = child;//选取左节点，继续向下筛选\n\t\t\tchild = 2 * child + 1;\n\t\t}\n\t\tarrays[parent] = temp;\n\t}\n\t\n\t/**\n\t * 选择排序-堆排序(HeapSort)——第二步\n\t * 循环建立初始堆\n\t * @param arrays\n\t */\n\tpublic static void MakeMinHeap(int[] arrays){\n\t\tfor(int parent = arrays.length/2; parent>=0; parent--){\n\t\t\tMinHeapFixdown(arrays, parent, arrays.length-1);\n\t\t}\n\t}\n\t\n\t/**\n\t * 选择排序-堆排序(HeapSort)——第三步\n\t * @param arrays\n\t */\n\tpublic static void HeapSort(int[] arrays){\n\t\tMakeMinHeap(arrays);\n\t\t/*进行length-1次循环，完成排序*/\n\t\tfor(int i = arrays.length-1; i>0; i--){\n\t\t\t/*最后一个元素和第一个元素交换*/\n\t\t\tint temp = arrays[0];\n\t\t\tarrays[0] = arrays[i];\n\t\t\tarrays[i] = temp;\n\t\t\t/*筛选arrays[0]节点，得到i-1个节点的堆*/\n\t\t\tMinHeapFixdown(arrays,0,i);\n\t\t}\n\t}\n\t\n\t/**\n\t * 交换排序-冒泡排序(BubbleSort)\n\t * @param arrays\n\t */\n\tpublic static void BubbleSort1(int[] arrays){\n\t\tfor(int i=1; i<arrays.length; i++){ //外圈for循环表示大循环只需要比较length-1次。\n\t\t\tfor (int j = 0; j < arrays.length-i; j++) { //内圈for循环开始两两之间比较\n\t\t\t\tif(arrays[j] > arrays[j+1]){\n\t\t\t\t\tint temp = arrays[j];\n\t\t\t\t\tarrays[j] = arrays[j+1];\n\t\t\t\t\tarrays[j+1] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * 交换排序-冒泡排序(BubbleSort)\n\t * 优化改进，设置是否交换标识。\n\t * @param arrays\n\t */\n\tpublic static void BubbleSort2(int[] arrays){\n\t\tboolean flag;//用于标识是否交换\n\t\tfor(int i=1; i<arrays.length; i++){ //外圈for循环表示大循环只需要比较length-1次。\n\t\t\tflag = false;\n\t\t\tfor (int j = 0; j < arrays.length-i; j++) { //内圈for循环开始两两之间比较\n\t\t\t\tif(arrays[j] > arrays[j+1]){\n\t\t\t\t\tint temp = arrays[j];\n\t\t\t\t\tarrays[j] = arrays[j+1];\n\t\t\t\t\tarrays[j+1] = temp;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag){//如果没有交换就直接退出了，说明没有可以换了\n\t\t\t\tbreak;\n\t\t\t} \n\t\t}\n\t}\n\t\n\t/**\n\t * 交换排序-快速排序(QuickSort)\n\t * @param arrays\n\t */\n\tpublic static void QuickSort(int[] arrays,int low, int high){\n\t\tif(low >= high){//如果最低位的下标>=最高位的下标\n\t\t\treturn;\n\t\t}\n\t\tint left = low;//i\n\t\tint right = high;//j\n\t\tint key = arrays[left];//选取第一个key，或者你可以选最后一个\n\t\twhile(left < right){\n\t\t\twhile(left < right && arrays[right] >= key){\n\t\t\t\tright--;//从右边向左，找第一个值小于key的。  左边\n\t\t\t}\n\t\t\tarrays[left] = arrays[right];//找到arrays[left]后和arrays[right]交换\n\t\t\t\n\t\t\twhile(left < right && arrays[left] <= key){\n\t\t\t\tleft++;//从左边向右，找第一个大于key的值。 右边\n\t\t\t}\n\t\t\tarrays[right] = arrays[left];//找到arrays[right]后和arrays[left]交换\n\t\t}\n\t\tarrays[left] = key;//当在当组内找完一边以后就把中间数key回归，就是说此时中间的值为key\n\t\tQuickSort(arrays, low, left-1);//对key左边的元素进行递归排序\n\t\tQuickSort(arrays, left+1, high);//对key右边的元素进行递归排序\n\t}\n\t\n\t\n\t/**\n\t * 二路归并排序(Merge Sort)\n\t * 将有序数组A[]和B[]合并到C[]中\n\t * @param arraysA\n\t * @param arraysB\n\t * @param arraysC\n\t */\n\tpublic static void MergeArray(int arraysA[], int arraysB[], int arraysC[]){\n\t\t/*主要思想：比较两个数组中的数，谁小就先取出谁*/\n\t\tint i = 0;//A[]的开始下标\n\t\tint j = 0;//B[]的开始下标\n\t\tint k = 0;//C[]的开始下标\n\t\twhile(i < arraysA.length && j < arraysB.length){\n\t\t\t/*判断谁小，然后放入，k++， i/j++ */\n\t\t\tif(arraysA[i] < arraysB[j]){\n\t\t\t\tarraysC[k] = arraysA[i];\n\t\t\t\tk++;\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tarraysC[k] = arraysB[j];\n\t\t\t\tk++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\t/*如果B[]已经分配完，而A[]没有分完，那剩下的就都是A直接放入到C[]中*/\n\t\twhile(i < arraysA.length){\n\t\t\tarraysC[k] = arraysA[i];\n\t\t\tk++;\n\t\t\ti++;\n\t\t}\n\t\t/*如果A[]已经分配完，而B[]没有分完，那剩下的就都是A直接放入到C[]中*/\n\t\twhile(j < arraysB.length){\n\t\t\tarraysC[k] = arraysB[j];\n\t\t\tk++;\n\t\t\tj++;\n\t\t}\n\t}\n\t/**\n\t * 二路归并排序(Merge Sort)——第一步\n\t * 将arrays[first...middle]和arrays[middle+1...end]合并\n\t * @param arrays\n\t * @param first\n\t * @param middle\n\t * @param end\n\t * @param temp\n\t */\n\tpublic static void MergeArray(int arrays[], int first, int middle, int end, int temp[]){\n\t\tint i = first;//A[]开始下标\n\t\tint m = middle;\n\t\tint j = middle+1;//B[]开始下标\n\t\tint n = end;\n\t\tint k = 0;  //C[]开始下标,这里为temp[]\n\t\twhile(i <= m && j <= n){\n\t\t\t/*判断谁小，然后放入，k++， i/j++ */\n\t\t\tif(arrays[i] < arrays[j]){\n\t\t\t\ttemp[k] = arrays[i];\n\t\t\t\tk++;\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\ttemp[k] = arrays[j];\n\t\t\t\tk++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\t/*如果B[]已经分配完，而A[]没有分完，那剩下的就都是A直接放入到C[]中*/\n\t\twhile(i <= m){\n\t\t\ttemp[k] = arrays[i];\n\t\t\tk++;\n\t\t\ti++;\n\t\t}\n\t\t/*如果A[]已经分配完，而B[]没有分完，那剩下的就都是A直接放入到C[]中*/\n\t\twhile(j <= n){\n\t\t\ttemp[k] = arrays[j];\n\t\t\tk++;\n\t\t\tj++;\n\t\t}\n\t\t\n\t\t/*将temp[]的值赋给arrays[]，这样arrays[]得到的就是排序好的*/\n\t\tfor(i=0; i<k;i++){\n\t\t\tarrays[first+i] = temp[i];\n\t\t}\n\t\t\n\t}\n\t\n\t/**\n\t * 二路归并排序(Merge Sort)——第二步\n\t * @param arrays\n\t * @param first\n\t * @param last\n\t * @param temp\n\t */\n\tpublic static void MergeSort(int[] arrays,int first, int last, int temp[]){\n\t\tif(first < last){\n\t\t\tint middle = (first+last) >> 1;\n\t\t\tMergeSort(arrays, first, middle, temp);//左半部分排好序\n\t\t\tMergeSort(arrays, middle+1, last, temp);//右半部分排好序\n\t\t\tMergeArray(arrays, first, middle, last, temp);//合并左右部分\n\t\t}\n\t}\n\t\n\t/**\n\t * 计数排序(CountingSort)\n\t * @param arrays\n\t * @param max\n\t */\n\tpublic static void CountingSort(int[] arrays, int max){\n\t\t//max:待排序数组中最大的数\n\t\tint[] result = new int[arrays.length];//保留结果\n\t\tint[] temp = new int[max+1];//初始化数组，默认元素为0\n\t\t\n\t\tfor(int i=0; i<arrays.length; i++){\n\t\t\t//遍历待排序的数组，计算其中的每一个元素出现的次数，比如一个key为i的元素出现了3次，那么A[i]=3\n\t\t\tint value = arrays[i];\n\t\t\ttemp[value] += 1;  //temp[]初始化为0。 之后1，2...\n\t\t}\n\t\t\n\t\t/*对所有计数累加*/\n\t\tfor(int i=1; i<temp.length; i++){\n\t\t\ttemp[i] += temp[i-1];                                                                         \n\t\t}\n\t\t\n\t\tfor(int i = arrays.length-1; i>=0; i--){//逆向遍历源数组（保证稳定性），根据计数数组中对应的值填充到先的数组中\n\t\t\tint value = arrays[i];//记录原数组的每一个数\n\t\t\tint position = temp[value] - 1;//由于下标从0开始，所以这里减1\n\t\t\tresult[position] = value;//放入适当的位置\n\t\t\ttemp[value] -= 1;//放了一个就减一个\n\t\t}\n\t\t\n\t\t/*将结果赋给arrays数组*/\n\t\tfor (int i = 0; i < arrays.length; i++) {\n\t\t\tarrays[i] = result[i];\n\t\t}\n\t}\n\t\n\t/**\n\t * 基数排序(RadixSort)\n\t * @param arrays  待排序数组\n\t * @param radix  基数 10 (任何一个阿拉伯数，它的各个位数上的基数都是以0~9来表示的。所以我们不妨把0~9视为10个桶) \n\t * @param distance  待排序中的数最大的位数\n\t */\n\tpublic static void RadixSort(int[] arrays, int radix, int distance){\n\t\tint length = arrays.length;\n\t\tint[] temp = new int[length];//临时数组，用来暂存元素\n\t\tint[] count = new int[radix];//radix: 10 用于计数排序 盒子 0~9\n\t\tint divide = 1;  //1  10 100\n\t\t\n\t\tfor(int i = 0; i<distance; i++){\n\t\t\tSystem.arraycopy(arrays, 0, temp, 0, length);\n\t\t\tArrays.fill(count, 0);//盒子清空\n\t\t\t\n\t\t\t/*用来把每个数的 <个十百千万...> 分开，并且使相对应号数的桶的个数增加1*/\n\t\t\tfor (int j = 0; j < length; j++) {\n\t\t\t\t//divide：1 10 100\n\t\t\t\t//radix： 基数 10\n\t\t\t\t//取出每一个数的位。例如123：divide:1时，取出 3。divide:10时，取出2\n\t\t\t\tint tempKey = (temp[j]/divide) % radix;\n\t\t\t\tcount[tempKey]++; //盒子中的<个 十 百...>的个数\n\t\t\t}\n\t\t\t\n\t\t\t/*对所有计数累加*/\n\t\t\t//radix： 基数 10\n\t\t\tfor (int j = 1; j < radix; j++) {\n\t\t\t\tcount[j] += count[j-1];\n\t\t\t}\n\t\t\tfor (int j = length-1; j>=0; j--) {//逆向遍历源数组（保证稳定性），根据计数数组中对应的值填充到先的数组中\n\t\t\t\tint tempKey = (temp[j]/divide) % radix;\n\t\t\t\tcount[tempKey]--;//由于下标从0开始，所以这里减1\n\t\t\t\tarrays[count[tempKey]] = temp[j];\n\t\t\t}\n\t\t\t\n\t\t\t//(temp[j]/divide) % radix\n\t\t\tdivide = divide * radix; //divide：1 10 100,通过distance控制\n\t\t}\n\t}\n\t\n\t/**\n\t * 桶排序(BucketSort)\n\t * @param arrays 待排序数组\n\t * @param max  最大的数\n\t * @param min  最小的数\n\t */\n\tpublic static void BucketSort(int[] arrays,int max, int min){\n\t\tint bucketNum = (max - min) / arrays.length + 1;//桶数，比如10个桶\n\t\t/*创建链表(桶)集合并初始化，结婚中的链表用于存放相应的元素*/\n\t\tLinkedList<LinkedList<Integer>> buckets = new LinkedList<LinkedList<Integer>>();//存桶，桶集合\n\t\tfor(int i = 0; i<bucketNum; i++){\n\t\t\tLinkedList<Integer> bucket = new LinkedList<Integer>();//存元素，桶\n\t\t\tbuckets.add(bucket);\n\t\t}\n\t\t\n\t\t/*把元素放进相对应的桶中*/\n\t\tfor(int i = 0; i<arrays.length; i++){\n\t\t\tint index = (arrays[i] - min) /arrays.length;//把元素放进相对应的桶中\n\t\t\tbuckets.get(index).add(arrays[i]);\n\t\t}\n\t\t\n\t\t/*对每个桶中的元素排序，并放进arrays[]*/\n\t\tint index = 0;//用于排序后从每个桶中依次取出,arrays的下标\n\t\tfor(LinkedList<Integer> linkedList : buckets){\n\t\t\tint size = linkedList.size(); //每个桶的长度\n\t\t\tif(size == 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint[] temp = new int[size];\n\t\t\tfor(int i = 0; i<temp.length; i++){\n\t\t\t\ttemp[i] = linkedList.get(i);//将桶的数取出放进入temp[]中\n\t\t\t}\n\t\t\tArrays.sort(temp);//对桶里面的数进行排序，选择一种排序方式，\n\n\t\t\t/*排序后从每个桶中依次取出*/\n\t\t\tfor (int i = 0; i < temp.length; i++) {\n\t\t\t\tarrays[index] = temp[i];\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\t\n\n}\n\n```","categories":["数据结构"]},{"title":"排序算法总结二","url":"/2018/03/11/数据结构-第5章/","content":"**这是排序算法总结的第二篇文章，在本文章中涉及的内容为归并排序，计数排序，基数排序，桶排\n序，其他排序内容请参看排序算法总结一**\n\n### <font color=\"#d9534f\">二路归并排序(Merge Sort)</font>\n**1.基本思想**\n归并排序属于比较类非线性时间排序，号称比较类排序中性能最佳者，在数据中应用中较广。\n归并排序是分治法(Divide and Conquer)的一个典型的应用。将已有序的子序列合并，得到完全有序的序列。\n**即先使每个子序列有序，再使子序列段间有序**。若将两个有序表合并成一个有序表，称为二路归并。\n![](/images/mergesort.png)\n**2.特点**\n稳定排序、Out-place sort\n\n**3.时间复杂度**\n最好情况：O(nlog₂n)\n最坏情况：O(nlog₂n)\n空间复杂度：O(n)\n\n**4.代码实现**\n\n```\n参考思想\n/**\n * 二路归并排序(Merge Sort)\n * 将有序数组A[]和B[]合并到C[]中\n * @param arraysA\n * @param arraysB\n * @param arraysC\n */\npublic static void MergeArray(int arraysA[], int arraysB[], int arraysC[]){\n\t/*主要思想：比较两个数组中的数，谁小就先取出谁*/\n\tint i = 0;//A[]的开始下标\n\tint j = 0;//B[]的开始下标\n\tint k = 0;//C[]的开始下标\n\twhile(i < arraysA.length && j < arraysB.length){\n\t\t/*判断谁小，然后放入，k++， i/j++ */\n\t\tif(arraysA[i] < arraysB[j]){\n\t\t\tarraysC[k] = arraysA[i];\n\t\t\tk++;\n\t\t\ti++;\n\t\t}else{\n\t\t\tarraysC[k] = arraysB[j];\n\t\t\tk++;\n\t\t\tj++;\n\t\t}\n\t}\n\t/*如果B[]已经分配完，而A[]没有分完，那剩下的就都是A直接放入到C[]中*/\n\twhile(i < arraysA.length){\n\t\tarraysC[k] = arraysA[i];\n\t\tk++;\n\t\ti++;\n\t}\n\t/*如果A[]已经分配完，而B[]没有分完，那剩下的就都是A直接放入到C[]中*/\n\twhile(j < arraysB.length){\n\t\tarraysC[k] = arraysB[j];\n\t\tk++;\n\t\tj++;\n\t}\n}\n```\n\n**二路归并排序完整代码实现如下**\n```\n/**\n * 二路归并排序(Merge Sort)——第一步\n * 将arrays[first...middle]和arrays[middle+1...end]合并\n * @param arrays\n * @param first\n * @param middle\n * @param end\n * @param temp\n */\npublic static void MergeArray(int arrays[], int first, int middle, int end, int temp[]){\n\tint i = first;//A[]开始下标\n\tint m = middle;\n\tint j = middle+1;//B[]开始下标\n\tint n = end;\n\tint k = 0;  //C[]开始下标,这里为temp[]\n\twhile(i <= m && j <= n){\n\t\t/*判断谁小，然后放入，k++， i/j++ */\n\t\tif(arrays[i] < arrays[j]){\n\t\t\ttemp[k] = arrays[i];\n\t\t\tk++;\n\t\t\ti++;\n\t\t}else{\n\t\t\ttemp[k] = arrays[j];\n\t\t\tk++;\n\t\t\tj++;\n\t\t}\n\t}\n\t/*如果B[]已经分配完，而A[]没有分完，那剩下的就都是A直接放入到C[]中*/\n\twhile(i <= m){\n\t\ttemp[k] = arrays[i];\n\t\tk++;\n\t\ti++;\n\t}\n\t/*如果A[]已经分配完，而B[]没有分完，那剩下的就都是A直接放入到C[]中*/\n\twhile(j <= n){\n\t\ttemp[k] = arrays[j];\n\t\tk++;\n\t\tj++;\n\t}\n\t\n\t/*将temp[]的值赋给arrays[]，这样arrays[]得到的就是排序好的*/\n\tfor(i=0; i<k;i++){\n\t\tarrays[first+i] = temp[i];\n\t}\n\t\n}\n\n/**\n * 二路归并排序(Merge Sort)——第二步\n * @param arrays\n * @param first\n * @param last\n * @param temp\n */\npublic static void MergeSort(int[] arrays,int first, int last, int temp[]){\n\tif(first < last){\n\t\tint middle = (first+last) >> 1;\n\t\tMergeSort(arrays, first, middle, temp);//左半部分排好序\n\t\tMergeSort(arrays, middle+1, last, temp);//右半部分排好序\n\t\tMergeArray(arrays, first, middle, last, temp);//合并左右部分\n\t}\n}\n```\n### <font color=\"#d9534f\">计数排序(CountingSort)</font>\n**1.基本思想**\n在待排序序列中，对于给定的输入序列中的**每一个元素x**，确定该序列中值**小于x的元素的个数**\n**(此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定)，**这样就知道了该元素的正确位置。\n例如，对于待排序序列{10,5,3,1,9,3}，有5个数比10小，那么10就应该放在第6个位置。\n\n计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。它的优势在于\n在对一定范围内的整数排序时，它的复杂度为Ο(n+r)其中r是整数的范围)，快于任何比较排序算法。\n当然这是一种牺牲空间换取时间的做法，而且**当O(r)>O(n*log(n))**的时候其效率反而不如基于比\n较的排序(基于比较的排序的时间复杂度在理论上的下限是O(n*log(n)), 如归并排序，堆排序)\n![](/images/countingsort.png)\n**2.特点**\n稳定排序、Out-place sort\n\n**3.时间复杂度**\n最好情况：O(n+r)\n最坏情况：O(n+r)\n其中，n为排序的数的个数，r为基数\n\n**4.代码实现**\n```\n/**\n * 计数排序(CountingSort)\n * @param arrays\n * @param max  待排序数组中最大的数\n */\npublic static void CountingSort(int[] arrays, int max){\n\t//max:待排序数组中最大的数\n\tint[] result = new int[arrays.length];//保留结果\n\tint[] temp = new int[max+1];//初始化数组，默认元素为0\n\t\n\tfor(int i=0; i<arrays.length; i++){\n\t\t//遍历待排序的数组，计算其中的每一个元素出现的次数，比如一个key为i的元素出现了3次，那么A[i]=3\n\t\tint value = arrays[i];\n\t\ttemp[value] += 1;  //temp[]初始化为0。 之后1，2...\n\t}\n\t\n\t/*对所有计数累加*/\n\tfor(int i=1; i<temp.length; i++){\n\t\ttemp[i] += temp[i-1];\n\t}\n\t\n\tfor(int i = arrays.length-1; i>=0; i--){//逆向遍历源数组（保证稳定性），根据计数数组中对应的值填充到先的数组中\n\t\tint value = arrays[i];//记录原数组的每一个数\n\t\tint position = temp[value] - 1;//由于下标从0开始，所以这里减1\n\t\tresult[position] = value;//放入适当的位置\n\t\ttemp[value] -= 1;//放了一个就减一个\n\t}\n\t\n\t/*将结果赋给arrays数组*/\n\tfor (int i = 0; i < arrays.length; i++) {\n\t\tarrays[i] = result[i];\n\t}\n}\n```\n\n### <font color=\"#d9534f\">基数排序(RadixSort)</font>\n**1.基本思想**\n1.首先根据个位数的数值，将它们分配至编号0到9的桶子中\n接下来将这些桶子中的数值按顺序重新串接起来，\n2.根据十位数的数值，将它们分配至编号0到9的桶子中\n接下来将这些桶子中的数值按顺序重新串接起来，\n以此类推...直到最高位结束。\n3.根据最高位数的数值，将它们分配至编号0到9的桶子中，得到排序。\n\n基数排序号称线性时间排序算法中性能最好，速度最快的排序算法。\n基数排序属于\"分配式排序\"(distribution sort)，是非比较类线性时间排序的一种，又称:桶子法(bucket sort)。\n顾名思义，它是通过键值的部分信息，将要排序的元素分配至某些\"桶\"中，以达到排序的作用。\n\n**MSD：最高位优先(Most Significant Digit first)法**\n先按k1排序分组，同一组中记录，关键码k1相等，再对各组按k2排序分成子组，之后，对后面的关键\n码继续这样的排序分组，直到按最次位关键码kd对各子组排序后。再将各组连接起来，便得到一个有\n序序列。MSD从高位开始排到低位，排完一位后不合并桶，相同的高位划分子桶继续分配，最后再合并\n**LSD：最低位优先(Least Significant Digit first)法**\n先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。LSD从低位\n开始排到高位，每排一位都是把各个桶合并，再按下一位排序。\n\n基数排序的方式可以采用LSD(Least significant digital)或MSD（Most significant digital)，LSD\n的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。\n![](/images/radixsort.png)\n例如：[520 350 72 383 15 442 352 86 158 352]排序过程\n![](/images/radixsort2.png)\n**2.特点**\n稳定排序、Out-place sort\n\n**3.时间复杂度**\n最好情况：O(d\\*(n+r))\n最坏情况：O(d\\*(n+r))\n空间复杂度：O(n+r)\n其中，d为多少位数，r为基数(盒子10，0~9)，n为待排序序列中有n个记录\n\n**4.代码实现**\n```\n/**\n * 基数排序(RadixSort)\n * @param arrays  待排序数组\n * @param radix  基数 10 (任何一个阿拉伯数，它的各个位数上的基数都是以0~9来表示的。所以我们不妨把0~9视为10个桶) \n * @param distance  待排序中的数最大的位数\n */\npublic static void RadixSort(int[] arrays, int radix, int distance){\n\tint length = arrays.length;\n\tint[] temp = new int[length];//临时数组，用来暂存元素\n\tint[] count = new int[radix];//radix: 10 用于计数排序 盒子 0~9\n\tint divide = 1;  //1  10 100\n\t\n\tfor(int i = 0; i<distance; i++){\n\t\tSystem.arraycopy(arrays, 0, temp, 0, length);\n\t\tArrays.fill(count, 0);//盒子清空\n\t\t\n\t\t/*用来把每个数的 <个十百千万...> 分开，并且使相对应号数的桶的个数增加1*/\n\t\tfor (int j = 0; j < length; j++) {\n\t\t\t//divide：1 10 100\n\t\t\t//radix： 基数 10\n\t\t\t//取出每一个数的位。例如123：divide:1时，取出 3。divide:10时，取出2\n\t\t\tint tempKey = (temp[j]/divide) % radix;\n\t\t\tcount[tempKey]++; //盒子中的<个 十 百...>的个数\n\t\t}\n\t\t\n\t\t/*对所有计数累加*/\n\t\t//radix： 基数 10\n\t\tfor (int j = 1; j < radix; j++) {\n\t\t\tcount[j] += count[j-1];\n\t\t}\n\t\tfor (int j = length-1; j>=0; j--) {//逆向遍历源数组（保证稳定性），根据计数数组中对应的值填充到先的数组中\n\t\t\tint tempKey = (temp[j]/divide) % radix;\n\t\t\tcount[tempKey]--;//由于下标从0开始，所以这里减1\n\t\t\tarrays[count[tempKey]] = temp[j];\n\t\t}\n\t\t\n\t\t//(temp[j]/divide) % radix\n\t\tdivide = divide * radix; //divide：1 10 100,通过distance控制\n\t}\n}\n```\n\n### <font color=\"#d9534f\">桶排序(BucketSort)</font>\n**1.基本思想**\n**桶排序，顾名思义就是运用桶的思想来将数据放到相应的桶内，再将每一个桶内的数据进行排序，\n最后把所有桶内数据按照顺序取出来，得到的就是我们需要的有序数据**\n\n桶排序是分配排序的一种，但其是基于比较排序的，它是一个分布式的排序，介于MSD基数排序和\nLSD基数排序之间。这也是与基数排序最大的区别所在。\n桶排序算法想法类似于散列表。首先要假设待排序的元素输入符合某种均匀分布，例如数据均匀分布\n在[ 0,1）区间上，则可将此区间划分为10个小区间，称为桶，对散布到同一个桶中的元素再排序。\n**要求：待排序数长度一致。**\n\n1.建立一堆buckets； \n2.遍历原始数组，并将数据放入到各自的buckets当中； \n3.对非空的buckets进行排序； \n4.按照顺序遍历这些buckets并放回到原始数组中即可构成排序后的数组。\n![](/images/bucketsort.png)\n**2.特点**\n稳定排序、Out-place sort\n\n**3.时间复杂度**\n最好情况：O(nlgn)\n最坏情况：O(n)\n\n**4.代码实现**\n```\n/**\n * 桶排序(BucketSort)\n * @param arrays 待排序数组\n * @param max  最大的数\n * @param min  最小的数\n */\npublic static void BucketSort(int[] arrays,int max, int min){\n\tint bucketNum = (max - min) / arrays.length + 1;//桶数，比如10个桶\n\t/*创建链表(桶)集合并初始化，结婚中的链表用于存放相应的元素*/\n\tLinkedList<LinkedList<Integer>> buckets = new LinkedList<LinkedList<Integer>>();//存桶，桶集合\n\tfor(int i = 0; i<bucketNum; i++){\n\t\tLinkedList<Integer> bucket = new LinkedList<Integer>();//存元素，桶\n\t\tbuckets.add(bucket);\n\t}\n\t\n\t/*把元素放进相对应的桶中*/\n\tfor(int i = 0; i<arrays.length; i++){\n\t\tint index = (arrays[i] - min) /arrays.length;//把元素放进相对应的桶中\n\t\tbuckets.get(index).add(arrays[i]);\n\t}\n\t\n\t/*对每个桶中的元素排序，并放进arrays[]*/\n\tint index = 0;//用于排序后从每个桶中依次取出,arrays的下标\n\tfor(LinkedList<Integer> linkedList : buckets){\n\t\tint size = linkedList.size(); //每个桶的长度\n\t\tif(size == 0){\n\t\t\tcontinue;\n\t\t}\n\t\tint[] temp = new int[size];\n\t\tfor(int i = 0; i<temp.length; i++){\n\t\t\ttemp[i] = linkedList.get(i);//将桶的数取出放进入temp[]中\n\t\t}\n\t\tArrays.sort(temp);//对桶里面的数进行排序，选择一种排序方式，\n\n\t\t/*排序后从每个桶中依次取出*/\n\t\tfor (int i = 0; i < temp.length; i++) {\n\t\t\tarrays[index] = temp[i];\n\t\t\tindex++;\n\t\t}\n\t}\n}\t\n```\n\n\n完！！！","categories":["数据结构"]},{"title":"排序算法总结一","url":"/2018/03/10/数据结构-第4章/","content":"排序(Sort/Sequence)，是计算机内经常进行的一种操作，其目的是将一组\"无序\"的记录序列调整为\"有序\"的记录序列。使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。\n排序的目的：便于查找！！！\n排序算法的好坏？\n答：时间复杂度、空间复杂度、稳定性\n\n### 排序分类\n#### 内部排序和外部排序\n内部排序:数据记录在内存中进行排序。\n外部排序:若参加排序的记录数量很大，整个序列的排序过程不可能在内存中完成，在排序的过程中需要访问外存，则为外部排序。\n\n#### 就地排序和非就地排序\nIn-place sort:就地排序，不占用额外内存或占用常数的内存。所需的辅助空间并不依赖于问题的规模n，即辅助空间为O(1)\nOut-place sort:需要占用额外的内存\n当需要对大量数据进行排序时，In-place sort就显示出优点，因为只需要占用常数的内存。\n\n#### 稳定排序和不稳定排序\nstable sort:稳定排序\nunstable sort:不稳定排序\n\n**算法导论习题8.3-2说：如何对于不稳定的算法进行改进，使得那些不稳定的算法也稳定？**\n其实很简单，只需要在每个输入元素**加一个index**，表示初始时的数组索引，当不稳定的算法排好序\n后，对于相同的元素对index排序即可。基于比较的排序都是遵循“决策树模型”，而在决策树模型\n中，我们能证明给予比较的排序算法最坏情况下的运行时间为Ω(nlgn)，证明的思路是因为将n个序列\n构成的决策树的叶子节点个数至少有n!，因此高度至少为nlgn。线性时间排序虽然能够理想情况下能\n在线性时间排序，但是每个排序都需要对输入数组做一些假设，比如计数排序需要输入数组数字范围\n为[0,k]等。在排序算法的正确性证明中介绍了”循环不变式“，他类似于数学归纳法，\"初始\"对应\"n=1\"，\"保持\"对应\"假设n=k成立，当n=k+1时\"。\n\n\n#### 非线性时间比较类排序 和 线性时间非比较类排序\n1.非线性时间比较类排序：交换类排序(快速排序和冒泡排序)、插入类排序(简单插入排序和希尔排\n序)、选择类排序(简单选择排序和堆排序)、归并排序(二路归并排序和多路归并排序)；\n2.线性时间非比较类排序：计数排序、基数排序和桶排序。\n\n总结： \n1.在比较类排序中，归并排序号称最快，其次是快速排序和堆排序，两者不相伯仲，但是有一点需要\n注意，数据初始排序状态对堆排序不会产生太大的影响，而快速排序却恰恰相反。\n2.线性时间非比较类排序一般要优于非线性时间比较类排序，但前者对待排序元素的要求较为严格，\n比如计数排序要求待排序数的最大值不能太大，桶排序要求元素按照hash分桶后桶内元素的数量要\n均匀。**线性时间非比较类排序的典型特点是以空间换时间。**\n\n![](/images/sort1.png)![](/images/sort2.png)![](/images/sort3.png)\n\n**说明：本篇文章下面内容会讲到插入排序、选择排序、交换排序的基本思想，特点，时间空间复杂度，以及java代码实现。\n下篇排序算法总结二将会讲到归并排序，计数排序，基数排序，桶排序。**\n\n### <font color=\"#d9534f\">一、插入排序</font>\n##### 插入排序-直接插入排序(Straight Insertion Sort)\n**1.基本思想**\n直接插入排序也称为简单插入排序。\n先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。\n![](/images/insertionsort.png)\n**2.特点**\n稳定排序、In-place sort\n\n**3.时间复杂度**\n最好情况：n比较小或者元素基本有序O(n)。\n最坏情况：如果待排序记录为逆序O(n^2)。\n空间复杂度：O(1)\n\n**4.代码实现**\n```\npublic static void StraightInsertionSort(int[] arrays){\n\t/*大循环只要排length-1次，因为默认第一个排序好了*/\n\tfor (int i = 1; i < arrays.length; i++) {\n\t\t/*从第二个记录开始和前面的逐个比较，如果大于就交换，没有就直接退出*/\n\t\tfor (int j = i; j > 0; j--) { \n\t\t\tif(arrays[j] < arrays[j-1]){\n\t\t\t\tint temp = arrays[j];\n\t\t\t\tarrays[j] = arrays[j-1];\n\t\t\t\tarrays[j-1] = temp;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;//没有交换就直接退出这次for，直接下一个记录\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n#### 插入排序-折半插入排序(Binary Insertion Sort)\n**1.基本思想**\n折半插入排序是对直接插入排序的改进，**由于前面已排序好**，我们就不用按照顺序依次**寻找插入**\n点，可以**采用折半查找的方法**加快寻找插入点的速度\n\n**2.特点**\n稳定排序、In-place sort\n\n**3.时间复杂度**\n最好情况：O(nlogn)\n最坏情况：O(n^2)\n空间复杂度：O(1)\n\n**4.代码实现**\n```\npublic static void BinaryInsertionSort(int[] arrays){\n\t/*大循环只要排length-1次，因为默认第一个排序好了*/\n\tfor (int i = 1; i < arrays.length; i++) {\n\t\tint temp = arrays[i]; //要插入的第i个记录\n\t\tint begin =0; //标记排序好的头部\n\t\tint end = i-1;//标记排序好的尾部,第i个记录位插入的数据，所以标记好的尾部为i-1\n\t\twhile(begin <= end){\n\t\t\tint mid = (begin + end) / 2;\n\t\t\tif(temp > arrays[mid]){//temp为要插入的，表明在右边\n\t\t\t\tbegin = mid + 1;\n\t\t\t}\n\t\t\tif(temp < arrays[mid]){//在左边\n\t\t\t\tend = mid - 1;\n\t\t\t}\n\t\t}\n\t\t/*当找到位置的时候，此时begin的位置就是插入点位置，begin后的数往后移动*/\n\t\tfor(int j = i; j> begin; j--){\n\t\t\tarrays[j] = arrays[j-1]; \n\t\t}\n\t\tarrays[begin] = temp;//插入i\n\t}\n}\n```\n\n#### 插入排序-希尔排序(Shell Sort)\n**1.基本思想**\nShell排序又称缩小增量排序, 由D. L. Shell在1959年提出，是对直接插入排序的改进。\n相邻指定距离(称为增量)的元素进行比较，并不断把增量缩小至1，完成排序。\n\n将需要排序的序列划分为若干个较小的序列，对这些序列进行直接插入排序，通过这样\n若干次操作可使需要排序的数据基本有序，最后再使用一次直接插入排序\n![](/images/shellsort.png)![](/images/shellsort1.png)\n**2.特点**\n不稳定排序、In-place sort\n\n**3.时间复杂度**\n实际所需的时间取决于各次排序时增量的个数和增量的取值.\n对于增量的选择，Shell 最初建议增量选择为n/2，并且对增量取半直到 1\nO(n^1.3)到O(n^2)\n空间复杂度：O(1)\n\n**4.代码实现**\n```\npublic static void ShellSort(int[] arrays){\n\tint gap = arrays.length;\n\twhile(gap > 1){ //增量如果为1就结束\n\t\tfor(gap = arrays.length/2; gap>0; gap /= 2){//增量逐次减半\n\t\t\t/*i：表示从gap开始到length的数——————gap   gap+1  ...  length-1*/\n\t\t\tfor(int i = gap; i<arrays.length; i++){\n\t\t\t\t/*j=i-gap：表示gap开始前面的数——————0     1     ...  gap-1*/\n\t\t\t\tfor(int j = i-gap; j>=0; j -= gap){\t\t\n\t\t\t\t\t/*gap前面的数 和 gap后面的数 比较大小,j为gap前面的数*/\n\t\t\t\t\tif(arrays[j]>arrays[j+gap]){\n\t\t\t\t\t\tint\ttemp = arrays[j];\n\t\t\t\t\t\tarrays[j] = arrays[j+gap];   \n\t\t\t\t\t\tarrays[j+gap] = temp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### <font color=\"#d9534f\">选择排序</font>\n#### 选择排序-直接选择排序(SelctionSort)\n**1.基本思想**\n直接选择排序也叫简单选择排序。\n从记录中找到**最小的一个数和第一个位置交换**，然后在剩下的记录中**找到最小的和第二个位置交换**，循环直到剩下最好一个数。\n![](/images/selectionsort.png)\n**2.特点**\n不稳定、In-place sort\n\n**3.时间复杂度**\n最好情况：O(n^2)\n最坏情况：O(n^2)\n简单选择排序也是常见排序算法中性能最差的排序算法。简单选择排序的比较次数与文件的初始状态没有关系，在第i趟排序中选\n出最小排序码的记录，需要做n-i次比较。\n空间复杂度：O(1)\n\n**4.代码实现**\n```\npublic static void SelectionSort(int[] arrays){\n\tfor(int i=0; i<arrays.length; i++){\n\t\tint minIndex = i;//minIndex为每次找到的最小的值\n\t\tfor(int j=i+1; j<arrays.length; j++){\n\t\t\tif(arrays[j] < arrays[minIndex]){\n\t\t\t\tminIndex = j;//找出每一次数据中最小的\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*如果minIndex和当前的第i个不是同一个数就换，这样第i个位置就是最小的*/\n\t\tif(minIndex != i){\n\t\t\tint temp = arrays[i];\n\t\t\tarrays[i] = arrays[minIndex];\n\t\t\tarrays[minIndex] = temp;\n\t\t}\n\t}\n}\n```\n\n#### 选择排序-堆排序(HeapSort)\n**1.基本思想**\n堆是一棵完全二叉树，所谓完全二叉树即叶节点只能出现在最下层和次下层，并且最下面一层的\n结点都集中在该层最左边的若干位置的二叉树。\n\n堆排序是一种树形选择排序，威洛母斯(J. Willioms)在1964年对直接选择排序的有效改进。\n堆排序是在排序过程中，将向量中存储的数据看成一颗完全二叉树，使用完成二叉树中双亲结点和孩子节点之间的内在关系来选择关键字最小的记录，即待排序记录仍采用向量数字方式存储，并非采用树的存储结构。\n\n第一个记录作为二叉树的根，每个节点表示一个记录。\n**2.特点**\n不稳定排序、In-place sort\n\n**3.时间复杂度**\n最好情况：O(nlog₂n) 注：log以2底n的对数\n最坏情况：O(nlog₂n)\n空间复杂度：O(1)\n\n**4.代码实现**\n```\n/**\n * 选择排序-堆排序(HeapSort)——第一步\n * 调整大顶堆\n * 从i节点开始调整，n为总节点数。   i的子节点为：2*i+1 和 2*i+2\n * \n * 一个父节点的子节点数的取值范围为[0,2],子节点数为零的父节点常被称为叶子节点。\n * 每一个父节点又可以看成是其子树分支的根节点。 \n * 2*i、2*i+1 、 2*i+2\n * 0 1 2 \n * @param arrays\n * @param parent\n * @param length\n */\npublic static void MinHeapFixdown(int[] arrays, int parent, int length){\n\tint child = 2*parent+1;//获得左子节点\n\tint temp = arrays[parent]; //保存当前父节点。\n\twhile(child < length){\n\t\t/*如果有右子节点，child+1为右子节点，并且右子节点大与左子节点,则选取右子节点*/\n\t\tif(child+1<length && arrays[child] < arrays[child+1]){\n\t\t\tchild++;\n\t\t}\n\t\t/*如果父节点的值 > 子节点的值， 结束*/\n\t\tif(temp >= arrays[child]){\n\t\t\tbreak;\n\t\t}\n\t\t/*把子节点的值赋给父节点*/\n\t\tarrays[parent] = arrays[child];\n\t\tparent = child;//选取左节点，继续向下筛选\n\t\tchild = 2 * child + 1;\n\t}\n\tarrays[parent] = temp;\n}\n\n/**\n * 选择排序-堆排序(HeapSort)——第二步\n * 循环建立初始堆\n * @param arrays\n */\npublic static void MakeMinHeap(int[] arrays){\n\tfor(int parent = arrays.length/2; parent>=0; parent--){\n\t\tMinHeapFixdown(arrays, parent, arrays.length-1);\n\t}\n}\n\t\n/**\n * 选择排序-堆排序(HeapSort)——第三步\n * @param arrays\n */\npublic static void HeapSort(int[] arrays){\n\tMakeMinHeap(arrays);\n\t/*进行length-1次循环，完成排序*/\n\tfor(int i = arrays.length-1; i>0; i--){\n\t\t/*最后一个元素和第一个元素交换*/\n\t\tint temp = arrays[0];\n\t\tarrays[0] = arrays[i];\n\t\tarrays[i] = temp;\n\t\t/*筛选arrays[0]节点，得到i-1个节点的堆*/\n\t\tMinHeapFixdown(arrays,0,i);\n\t}\n}\n\t\n```\n\n\n### <font color=\"#d9534f\">交换排序</font>\n#### 交换排序-冒泡排序(BubbleSort)\n**1.基本思想**\n从数组中第一个数开始，依次遍历数组中的每一个数，**通过相邻比较交换**，每一轮循环下来找出剩余未排序数的中的最大数并”冒泡”至数列的顶端。\n![](/images/bubblesort.png)\n**2.特点**\n稳定排序、In-place sort\n\n**3.时间复杂度**\n最好情况：O(n^2)\n最坏情况：O(n^2)\n(当然，也可以进行改进使得最佳运行时间为O(n))\n空间复杂度：O(1)\n\n**4.代码实现**\n```\npublic static void BubbleSort(int[] arrays){\n\tfor(int i=1; i<arrays.length; i++){ //外圈for循环表示大循环只需要比较length-1次。\n\t\tfor (int j = 0; j < arrays.length-i; j++) { //内圈for循环开始两两之间比较\n\t\t\tif(arrays[j] > arrays[j+1]){\n\t\t\t\tint temp = arrays[j];\n\t\t\t\tarrays[j] = arrays[j+1];\n\t\t\t\tarrays[j+1] = temp;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n**优化**：设置一共flag控制开关，如果发生了交换就设为true，**如果在一轮结束后没有发生交换，就说明已经排序好了。后面就不用继续比较了**。\n```\npublic static void BubbleSort(int[] arrays){\n\tboolean flag;//用于标识是否交换的开关\n\tfor(int i=1; i<arrays.length; i++){ //外圈for循环表示大循环只需要比较length-1次。\n\t\tflag = false;\n\t\tfor (int j = 0; j < arrays.length-i; j++) { //内圈for循环开始两两之间比较\n\t\t\tif(arrays[j] > arrays[j+1]){\n\t\t\t\tint temp = arrays[j];\n\t\t\t\tarrays[j] = arrays[j+1];\n\t\t\t\tarrays[j+1] = temp;\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\tif(!flag){//如果没有交换就直接退出了，说明没有可以换了。\n\t\t\tbreak;\n\t\t} \n\t}\n}\n```\n\n#### 交换排序-快速排序(Quicksort)\n**1.基本思想**\n先从数列中取出一个数作为**key值(通常选择第一个元素或者最后一个元素)**，将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边，对左右两个小数列重复第二步，直至各区间只有1个数。\n![](/images/quicksort.png)\n![](/images/quicksort2.png)\n**2.特点**\n不稳定排序、In-place sort\n\n**3.时间复杂度**\n最好情况：O(nlog₂n)\n最坏情况：O(n^2)\n空间复杂度：O(log₂n)\n\n**4.代码实现**\n```\npublic static void QuickSort(int[] arrays,int low, int high){\n\tif(low >= high){//如果最低位的下标>=最高位的下标\n\t\treturn;\n\t}\n\tint left = low;//i\n\tint right = high;//j\n\tint key = arrays[left];//选取第一个key，或者你可以选最后一个\n\twhile(left < right){\n\t\twhile(left < right && arrays[right] >= key){\n\t\t\tright--;//从右边向左，找第一个值小于key的。  左边\n\t\t}\n\t\tarrays[left] = arrays[right];//找到arrays[left]后和arrays[right]交换\n\t\t\n\t\twhile(left < right && arrays[left] <= key){\n\t\t\tleft++;//从左边向右，找第一个大于key的值。 右边\n\t\t}\n\t\tarrays[right] = arrays[left];//找到arrays[right]后和arrays[left]交换\n\t}\n\tarrays[left] = key;//当在当组内找完一边以后就把中间数key回归，就是说此时中间的值为key\n\tQuickSort(arrays, low, left-1);//对key左边的元素进行递归排序\n\tQuickSort(arrays, left+1, high);//对key右边的元素进行递归排序\n}\n```","categories":["数据结构"]},{"title":"继电器与深入了解二进制","url":"/2017/09/05/linux从入门到放弃12/","content":"大家好，这里是Hanae Yuuma的博客，欢迎大家来阅读我的文章。\n声明部分内容来自[软件那些事儿](http://www.ximalaya.com/46905980/sound/28154721/)，这是我很喜欢的一个电台，里面讲述了IT界的历史，我觉得在如今去了解过去的历史是一件很有趣的事情，这样对我们理解一些东西可能会有帮助吧。我对历史了解甚少，很感谢栋哥给我带来这些过去的历史故事，对我来说我读这些故事更能去思考一些东西， 比看书的时候全是知识点会好玩很多。因此我也尽量去了解更多的历史并写在文章里。这里我主要是想说二进制，但是继电器应该也说一下，所以就引用了栋哥的这篇文章[83. 电脑原理01-从继电器开始](http://www.ximalaya.com/46905980/sound/28154721/),建立大家去读一下原文写的真都很好很有趣。好了，那么我们来说一下。\n\n我们都知道计算机只识别二进制，从我们的理解里二进制是0或者1，我听过另一个说法是有电和没电。那么这个二进制在计算机中又是如何表示的呢？从物理上来说，这里的话就是继电器，不过现在都用晶体管了，在我们的CPU上就拥有很多这些晶体管。（晶体管（transistor）是一种固体半导体器件，具有检波、整流、放大、开关、稳压、信号调制等多种功能。晶体管作为一种可变电流开关，能够基于输入电压控制输出电流。与普通机械开关（如Relay、switch）不同，晶体管利用电讯号来控制自身的开合，而且开关速度可以非常快，实验室中的切换速度可达100GHz以上。严格意义上讲，晶体管泛指一切以半导体材料为基础的单一元件，包括各种半导体材料制成的二极管、三极管、场效应管、可控硅等。晶体管有时多指晶体三极管。）\n\n### 继电器\n[转]如果大家对计算机的历史有理解的话，第一台计算机再1930年代被制造出来，里面的设备就是继电器，这台计算机的名字叫机械式继电器计算机，这台计算机通过继电器里面的弹簧片的接通和断开来表示二进制的0和1，后来由于继电器的性能不能保障，因为里面有弹簧片，弹簧片这种东西，弹多了，就失效了，而且使用的能量也太多了。继电器中有弹簧，我们知道，弹簧的速度是不够快的，最快的弹簧片，需要1/100秒改变一下状态，而且，弹簧片不可靠，因此，并没有大规模的应用。但是德国的科学家朱塞就是使用继电器制造出了一台全自动的计算机，速度肯定不快，但是已经具有现在计算机的一些特征了，能够计算浮点数，二进制计算等等。后来才使用电子管代替了继电器，后来又用晶体管代替了电子管，但是，基本的原理并没有发生翻天覆地的变化。\n\n今天我们使用的晶体管计算机，速度更快，能耗更低，也更便宜。但是，里面的工作原理和继电器的计算机并没有任何区别，今天的一个8位的加法器需要144个晶体管，同样，当年构造一个8位的加法器，需要144个继电器。只是现在科技发达了，由于集成电路的突飞猛进，144个晶体管，尤其是现在intel有10纳米的工艺，144个晶体管可能需要用电子显微镜才能看清楚。但是继电器的话，144个继电器，可能得一大坨。但是，我们要知道，里面的原理是一模一样的。\n\n继电器。为什么需要继电器呢？电线有个特征，电阻。就是随着距离的增加，电压会越来越小。在电线上传递的信号逐渐的就没有了。比如说，从北京发信号到上海，可能电线到了济南，就没电了，这时候怎么办呢？有一个办法，在济南的荒郊野外盖一个小屋子，丢一个人进去，他负责两件事情，把信号记录下来，然后再从济南发一份到徐州，然后徐州再发一份到上海。沿途有2个倒霉蛋在荒郊野外，负责把信号增强，这个工作应该挺无聊。继电器的工作就是代替这两个倒霉蛋的工作的，通过电磁铁的原理，从北京传来的信号，到达济南的电流，驱动一个电磁铁，然后这个电磁铁在拉动金属杆，然后这个被拉动的金属杆，恰好是济南到徐州的一个电路的开关，这样，北京过来的，比较虚弱的电流，在济南经过继电器电路，一个加强的信号又被放大，然后到了徐州，徐州也有一个相同的继电器，然后信号又被放大，然后到了上海。这就是继电器在电报中的工作原理。不过呢，还是得看图，说不清楚。电路图在下面。\n![](/images/继电器.png)\n可能有些同学觉得，这个继电器太简单了，因为他只能做一件事情啊，就是传递信号。是的，他确实非常简单，就是一个弹簧片，外加一根铁棍，还有一个线圈，实现的功能看起来也没什么大不了的。但是，毫无疑问的是，在任何博物馆里，尤其是电学的博物馆里，一定有一个地方是给继电器这个小东西留着的，因为他看起来不算什么神奇的东西，但是，把几个继电器按照不同的方法连接起来，就可以完成更加神器的东西。\n\n### 二进制\n上面引用说的就是在我们的计算机中0和1在物理上是怎么表示的，我一直觉得软硬件都懂得是一件很好的事情。那我们开始说二进制，作为一个程序员的话对于二进制肯定要了解的。在之前我们先来看一个东西\n<img src=\"/images/算盘.jpg\" width=\"50%\"/>\n没错，这就是我们古代时候用的算盘，分为上珠和下珠，上面一个代表五，下面一个代表一。那当我想表示十一的时候怎么办，这个时候就在左边新增一个代表十，右边放一个。那一百零一呢？同样在右数第三个下珠一个代表100。这里就有一个进制的概念，就是满十进一，而二进制同样我们知道是满二进一，但只是我们平常对二进制的理解，其实二进制是很有规律的。首先我们看十进制。\n![](/images/十进制01.jpg)\n十进制第一位就是10^0，那我们得出结论就是十进制就是以10为底，那我们同理可以画出二进制的，画的丑见谅。\n![](/images/二进制01.jpg)\n思考一下，那十进制的50对应的二进制是什么？\n好，我来公布一下：首先二进制从右边开始往左，1代表十进制分别为：1-2-4-8 16-32-64-128（2^n这个就是我们说的权，2就是基数）\n那50对应的按权展开就是0011 0010。（0+0+32+16+0+0+2+0）\n这个时候你会看到，为什么我在前面会多加了两个零。可能有一些比较了解的朋友知道，在二进制中，高位如果是1代表负数，而0代表正数。而在计算机中以位（bit）为单位，但是位太小了，于是用字节表示（一个字节byte=8位）。所以这样50就转换成你上面看到的那样了。我们老师说的可能是下面这种：\n![](/images/二进制02.png)\n当我们用除二取余法的时候，每次除2，就是找到对应的权值，比如说这里的89，我们知道2^6=32，2^7=64,所以说非符号位最大权值是2^7，那89就是01\\*\\* \\*\\*\\*\\*。基于这个思想，那我们就不用每次都用除二取余法了， 我们记住最简单的几个权值：1-2-4-8 16-32-64-128。那89就是0101 1001 (0+64+0+16 8+0+0+1=89)。\n\n如果是二进制转换十进制那更简单了。比如0000 1010就是(8+2=10)。\n\n### 负数与补码由来\n十进制中可以表示负数，同样二进制也可以，这里我以四位来说。我们不废话，先看图。\n![](/images/二进制02.jpg)\n我们可以把二进制画成一个时钟，因为用4位表示的个数正负是一样的都是8个，所以右边的给了正数，左边的分一半给负数。于是规定了0开头代表正数，而1代表负数，这个称为符号位。这个时候你就有疑问了，**那这-1对应的不应该是1001**，你不是告诉我说是权值吗，难道错了。并没有，首先我告诉你一个规律：-**1对应的反码就是0000，而这个0000加1对应的就是-1的相反数1**。是不是感觉其他的数都是一样。在数学中：-1+1=0,-10+10=0。我们称两个数互为相反数，互补。二进制中就称之为补码，记住上面的规律。**补码=反码+1，而反码就是原码中的0<->1互换啦**。在运行程序的时候，我们都是以补码的形式。\n\n所以你知道-1怎么表示了吧。\n首先-1的补码是1（0001），然后（补码-1）得到-1的反码是0000，那原码就是1111啦。真棒是吧。\n\n当有人问你的时候，在四位中，二进制正数最大最小是多少？负数最大最小是多少？\n你就可以回答是：0000和01111， 1111和1000。\n\n\n我们还发现，如果是-1减去1的话，那就是-2了。\n1111-0001=1110。\n那这样我们很快就知道-6的是什么了，就是-1-5=-6。还记得权值吗？\n没错，1111-0101=1010。\n这样我们就不用通过补码-1取反码得到负数对应的表示了。\n\n**请记住，负数最大的都是每一个上都是1。\n而正数是符号位0，其他都是1。**\n我在网上找了一个好的二进制循环编码盘，大家可以看看，比我画的好很多。黑色代表1\n<img src=\"/images/二进制03.jpg\" width=\"30%\"/>\n\n### 十六进制\n首先做个测试，请问这个代表十进制的多少：10101100 01011001？\n是不是感觉眼睛都看花了，这就是我们要介绍十六进制的原因。十六的进制很显然也是满16进一，16为基数。但是这不是我们学习的目的，十六进制的用途就是用来简化二进制。\n十六进制数字与二进制数字的对应关系如下：\n0000 -> 0 0100 -> 4 1000 -> 8 1100 -> C\n0001 -> 1 0101 -> 5 1001 -> 9 1101 -> D\n0010 -> 2 0110 -> 6 1010 -> A 1110 -> E\n0011 -> 3 0111 -> 7 1011 -> B 1111 -> F\n从第十位1010开始就用字母表示了。F对应的就是15。0-9对应0-9，A-F对应10-15\n那上面的问题我们可以简化成:首先十六进制表示为AE59。如果换算成十进制就是：9\\*16^0+5\\*16^1+E\\*16^2+A\\*16^3=?\n当然我这里就不算了，因为十六进制的设计就是用来简化二进制就达到目的。他也有上面那种转成为二进制，十进制的方法。但我们这里不去追究。\n如果学过ps的同学可能有了解过三颜色下面有关#号的代表的就是十六进制了。\n\n### (移)位运算符\n最后补充一个，位运算符，不是我们物理那个位移。移位运算符在程序设计中，是位操作运算符的一种，就是我们上面说的几位的位。移位运算符可以在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种：\n* <<（左移位运算）\n* \\>\\>（数学右移位）\n* \\>\\>\\>（逻辑位右移）\n用途：文字的编码\n我们在学的小数中就有这个位移的思想，比如3.14小数点右移动一位就是31.4(3.14\\*10^1),向左移动一位就是0.314(3.14\\*10^-1)。\n同理，移位运算符也有类似的规则。\\>\\>\\>有些也称为无符号右移，之所以会说逻辑位右移，是因为它符号我们的逻辑。\n我们来看一下下面的伪代码\n\n#### 区别\n```\n数学右移位 >> \n\n\tn =      00000000 00000000 00000000 00110010  50\n\tm = n>>1 000000000 00000000 00000000 0011001  25\n\tk = n>>2 0000000000 00000000 00000000 001100  12\n\n\tn =      11111111 11111111 11111111 11001110  -50 \n\tm = n>>1 111111111 11111111 11111111 1100111  -25\n\tk = n>>2 1111111111 11111111 11111111 110011  -13 \n\n逻辑右移位 >>>\n\n\tn =       00000000 00000000 00000000 00110010  50\n\tm = n>>>1 000000000 00000000 00000000 0011001  25\n\tk = n>>>2 0000000000 00000000 00000000 001100  12\n\n\tn =       11111111 11111111 11111111 11001110  -50 \n\tm = n>>>1 011111111 11111111 11111111 1100111  \n\tk = n>>>2 0011111111 11111111 11111111 110011   \n\n左移位运算\t\nn  =      00000000 00000000 00000000 00110010  50\n\tm = n<<1  0000000 00000000 00000000 001100100  100   \n\tk = n<<2  000000 00000000 00000000 0011001000  200\n```\n总结：\n* 数学右移位\\>\\>: 其结果满足数学规律, 整除向小方向取整，负数移位，高位补1 结果还是负数。\n* 逻辑右移位\\>\\>\\>: 无论正负高位都补0。\n* 左移位运算: 溢出位补0。\n二进制的移位有时候可以做优化运算，因为\nn<< 3 比起 n\\*8会快。\n这次写的太长了。就到这里先吧。在二进制运算符中，还有三个重要的运算符留着下一次讲：取反~,与&，或|。\n结合移位运算符，我们就可以进行文字的编码。就是我们通常说的GBK，UTF-8，我们在出现乱码的时候就是编码和解码不一致导致的，让我们走进文字的编码世界去探个究竟吧。这一期先到这里，下一次我们说一下文字的编码，Unicode和UTF-8。\n","categories":["Linux"]},{"title":"linux从入门到放弃——10UNIX系统编程","url":"/2017/08/25/linux从入门到放弃10/","content":"\n### 一、gcc编译源代码的四个步骤：\n    1) gcc  -E预处理，编译器将程序的头文件编译进来，还有宏替换。\n    2) gcc -S编译，这里主要是检查语法是否错误，无错误则将代码翻译成汇编语言。\n    3) gcc -c汇编,把编译阶段成的文件转换成二进制目标代码。\n    4) gcc -o链接，把汇编生产的文件链接为可执行文件。\n进行验证：\n1.1首先这里是源代码\n![](/images/gcc1.png)\n1.2执行过程\n预处理过程——>编译过程——>汇编过程——>链接成可执行文件\nPre-Processing——>compiling——>Assemblin——>Linking\n![](/images/gcc2.png)\n\n1.3我们可以看到在预处理生成的add.i文件中，添加了头文件还有宏替换\n![](/images/gcc3.png)\n![](/images/gcc4.png)\n1.4再来看看编译生成的文件内容，可以看到就是汇编语言\n![](/images/gcc5.png)\n\n\n### 二、gdb调试\n要使程序被编译后包含调试信息,只需在编译时用-g选项打开调试信息选项即可.\n```\ngdb - h\ngdb常用调试命令:\nfile\nkill\nlist\nnext\nstep\nrun\nquit\nwatch\nbreak\nmake\nshell\n```\n![](/images/gcc6.png)\n\n### 三、make程序\n在系统开发期间项目中包含多个程序模块,如果其中一个或多个模块被修改过,就必须要\n保证**编译、链接**的结果是由最新的模块构成.这时就需要一个make功能的程序,完成\n编译、链接的管理.\n\nUNIX系统中make程序是作为一个命令来执行的,它会对已经修改的模块进行编译,形成最新\n的**可执行程序代码**.\n\nmake程序工作原理:\n首先make程序会根据一个名为makefile的文件描述的内容进行工作.因此先编写好makefile\n之后在使用make命令.\n\nmakefile的内容:\n**makefile文件中描述的是该项目中所包含的各个程序,以及各程序之间的相互以来关系和用\n这些程序产生目标文件时所需要执行的命令**\n![](/images/gcc7.png)","categories":["Linux"]},{"title":"linux从入门到放弃——09Shell编程","url":"/2017/08/25/linux从入门到放弃09/","content":"### 一、B-shell常用预定义变量及环境变量定义表\n```\nUSER    用户名\nHOME    用户注册目录\nPATH    命令访问路径\nCDPATH  Cd命令路径\nPS1     系统提示符\nPS2     辅助提示符\nTERM    终端类型\nSHELL   内定运行的shell\n```\n### 二、shell中常用特殊变量的定义\n\n\n```\n$#  位置参数的个数\n$?  前一命令返回的状态值(0为正常),常用\n$$  当前shell进程的pid值\n$!  最近访问的后台进程的pid值\n$*  用单字符串显示传递参数\n```\n\n![](/images/shell.png)\n\n### 三、变量替换\n```\n${Var:-word} \n${Var:=word}\n${Var:+word}\n用命令做变量替换\nnow = `date`\necho $now\n```\n### test命令\ntest命令返回真值为0,否则返回假值非0.\n1.test对文件特性的测试\n```\ntest -[dfrwxs] file\n-d file 文件file存在且为目录\n-f 文件存在且为普通目录\n-r 文件存在且可读\n-w 文件存在且可写\n-x 文件存在且可执行\n-s 文件存在且长度非0\n例如:\ntest -d /home/HanaeYuuma/test\n```\n2.test对字符串内容的测试\n```\ntest s 当前字符串s非空,为真\ntest-zs 当前字符串s为空,为真\ntest s1 = s2 当字符串相等为真\ntest s1 != s2 不等时为真\n注意: 后面两个语句中在= 和!= 两边要加上空格,否则可能出现提示错误.\n```\n3.test对整数n的测试\n```\ntest n1 -eq n2  相等为真\n同理: \n-ne (not equal)\n-lt (less than)\n-le (less than or equal)\n-gt (greate than)\n-ge (greate than or equal)\n```\n### 四、条件控制语句\n#### if\n```\n1.if-then-fi\nif  [condition]\nthen\n    commands\nfi\n\n2.if-then-else-fi\nif  [condition]\nthen\n    commands\nelse\n    commands\nfi\n\n3.if-then-elif-then-fi\nif  [condition]\nthen\n    commands\nelif  [condition]\nthen\n    commands\nelse\n    commands\nfi\n```\n#### for\n```\nfor-in-do-done\nfor variable    in  list-of-values\ndo\n    commands\ndone\n```\n\n#### while\n```\nwhile-do-done\nwhile[condition]\ndo\n    commands\ndone\n```\n\n#### until\n```\nuntil-do-done\nuntil[condition]\ndo\n    commands\ndone\n```\n\n### 五、shell程序的调试方法\n```\nsh -[vx] shell.sh\n-v 完成详细跟踪,执行时首先逐行读入命令,在标准输出上显示该命令执行的实际内容.\n然后执行语句,直到有语法错误停止执行\n\n-x实际命令运行的跟踪.在命令执行前,首先显示经过变量替换后的命令行内容,然后再执行.\n```\n","categories":["Linux"]},{"title":"linux从入门到放弃——08ubuntu17.10Can't login","url":"/2017/08/25/linux从入门到放弃08/","content":"Today is 2018-4-16, yesterday I uninstalled my windows10 and installed the ubuntu17.10.\nYou can use the command 'lsb release -a' to see the current version of your linux.\nWhen I installed my linux, then I configured my development enviroment , I 'vim /etc/profile' to change something.\n\nIt's saddened for me,when reboot I attempt to login but failed. I'm sure my password is right.it's seem to login, but it still stays window for logining.\n\nThen I use 'Ctrl+Alt+F1~F6' to terminal(tty:Teletype) to modify /etc/profile.\nBut it shows  like that\"command 'xxx' is available in bin.\". So what? what should you do to modify.\n\nIn linux, when we input a command in terminal, it will do something. what something doing when we press 'Enter'.\nFactly, system actually launch a program. for example, like'cd pwd ls'. In system, use the 'PATH' appoint command's directory.\nwhen we use command then system first will search corresponding command from 'PATH'.\n\nso \"command 'xxx' is available\", we should use the absolutely path.\n```\n/usr/bin/sudo /usr/bin/vim /etc/profile\n```\nthen modify something wrong of setting, use'Ctrl+Alt+F7' return graphical interfaces to login.\n\n载转[Ubuntu Linux 环境变量PATH设置](https://blog.csdn.net/witsmakemen/article/details/7831631)\nnux系统环境变量配置文件：\n/etc/profile : 在登录时,操作系统定制用户环境时使用的第一个文件 ,此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行。\n\n/etc /environment : 在登录时操作系统使用的第二个文件, 系统在读取你自己的profile前,设置环境文件的环境变量。\n\n~/.profile :  在登录时用到的第三个文件 是.profile文件,每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件。\n\n/etc/bashrc : 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.\n\n~/.bashrc : 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。\n\n\n\nPASH环境变量的设置方法：\n\n方法一：用户主目录下的.profile或.bashrc文件（推荐）\n\n登录到你的用户（非root），在终端输入：\n$ sudo gedit ~/.profile(or .bashrc)\n可以在此文件末尾加入PATH的设置如下：\nexport PATH=”$PATH:your path1:your path2 ...”\n保存文件，注销再登录，变量生效。\n该方式添加的变量只对当前用户有效。\n\n方法二：系统目录下的profile文件（谨慎）\n\n在系统的etc目录下，有一个profile文件，编辑该文件：\n$ sudo gedit /etc/profile\n在最后加入PATH的设置如下：\nexport PATH=”$PATH:your path1:your path2 ...”\n该文件编辑保存后，重启系统，变量生效。\n该方式添加的变量对所有的用户都有效。\n\n方法三：系统目录下的 environment 文件（谨慎）\n\n在系统的etc目录下，有一个environment文件，编辑该文件：\n$ sudo gedit /etc/environment\n找到以下的 PATH 变量：\nPATH=\"<......>\"\n修改该 PATH 变量，在其中加入自己的path即可，例如：\nPATH=\"<......>:your path1:your path2 …\"\n各个path之间用冒号分割。该文件也是重启生效，影响所有用户。\n注意这里不是添加export PATH=… 。\n\n方法四：直接在终端下输入\n\n$ sudo export PATH=\"$PATH:your path1:your path2 …\"\n这种方式变量立即生效，但用户注销或系统重启后设置变成无效，适合临时变量的设置。\n\n\n注 意：方法二和三的修改需要谨慎，尤其是通过root用户修改，如果修改错误，将可能导致一些严重的系统错误。因此笔者推荐使用第一种方法。另外嵌入式 Linux的开发最好不要在root下进行（除非你对Linux已经非常熟悉了！！），以免因为操作不当导致系统严重错误。\n\n下面是一个对environment文件错误修改导致的问题以及解决方法示例：\n\n问题：因为不小心在 etc/environment里设在环境变量导致无法登录\n提示：不要在 etc/environment里设置 export PATH这样会导致重启后登录不了系统\n解决方法：\n在登录界面 alt +ctrl+f1进入命令模式，如果不是root用户需要键入（root用户就不许这么罗嗦，gedit编辑会不可显示）\n/usr/bin/sudo /usr/bin/vi /etc/environment then dd export PATH\n\n","categories":["Linux"]},{"title":"linux从入门到放弃——07Shell程序设计","url":"/2017/08/25/linux从入门到放弃07/","content":"### 什么是shell\n对于所有登录到unix系统的用户，系统都要为其开一个程序来管理用户与unix系统的交互工作，这个程序就是shell。\n常见的有Bourne shell(B-shell)及Korn shell(K-shell)，C shell。我們用的話就是B-shell\nshell作为一种用户与操作系统交互的工具与平台，shell的基本功能：\n1. 命令的解释执行\n2. 系统环境变量的设置\n3. 输入/输出的重定向管理\n4. shell程序的设置\n5. 连通通道建立\n\n\n#### Shell常见的语法规则：\n在shell命令解釋時，可按照正則表達式識別文件名或者目錄名\n\n```\ncmd& :表示在后台执行该命令　　　常用\ncmd1；cmd2 :表示在同一行中输入多个命令，shell将按顺序执行\n(cmd1;cmd2) :表示创建一个子shell完成命令，这里酱cmd1和cmd2视为一个命令组加以执行　　\ncmd1 | cmd2 :管道，表示用cmd1的输出作为cmd2的输入完成命令操作　　常用\ncmd1 `cmd2`: 这里cmd2命令用一个（上/反引号）命令括起来，表示一种命令结果替换功能。\n用cmd2的输出作为cmd1的输入完成命令操作。\n\ncmd1 && cmd2 :逻辑与\ncmd || cmd2 ：逻辑或\n\n```\n\n#### 标准流重定向与管道线控制：\n像如果我們直接在終端將命令輸入'cd pwd'，這樣稱爲標準流重定向．\n```\ncmd > file　將輸出重定向到文件\ncmd < file　將輸入重定向到文件\ncmd >> file　將輸出追加方式重定向到文件\n\n$ls -l > dir1\n$pwd > dir1    用>则覆盖文件内容\ndate >> dir1   用>>不覆盖\n\nprog < infile >outfile 執行效果：prog程序從infile中讀取參數，然後將結果送入到outfile中．順序執行\n\n管道线控制\n$ls -l >file\n$wc -l >file\n$rm file\n等价于:\n$ls -l | wc -l\n```\n\n#### 錯誤流重定向\n```\n首先我們可以通過命令查詢\nhanaeyuuma@suzuki:~$ ls /dev/std* -l\nlrwxrwxrwx 1 root root 15 Apr 16 22:22 /dev/stderr -> /proc/self/fd/2\nlrwxrwxrwx 1 root root 15 Apr 16 22:22 /dev/stdin -> /proc/self/fd/0\nlrwxrwxrwx 1 root root 15 Apr 16 22:22 /dev/stdout -> /proc/self/fd/1\n\ncc fsfas > log　當我們如果輸錯了命令，錯誤信息流就會被默認重定向爲顯示器\ncc fsfas 2>& log 將錯誤信息流重定向到log文件\ncmd >file 2>&1 將輸出流和錯誤流同時重定向到log文件\n注: &沒有固定意思，放在>後面表示file目標不是一個文件，而是一個文件描述符．\n\n```\n\n#### 運行shell\n方法１：輸入輸出重定向　sh < hello.sh\n方法２：作爲解釋器參數　sh hello.sh　大多數是用這種\n方法３：作爲可執行程序　./hello.sh 首先要給可執行的權限\n\n\n### shell程序编写格式\nshell程序不需要进行编译，它是按行解释执行的，习惯上脚本文件的第一行总是以类似下面形式开头\n```\n#!/bin/sh\n指明该shell程序使用系统中的B-shell解释器来解释执行\n```\n\n#### Shell的环境变量：\n在主目錄下，運行命令'ls -l .bash*',可以看到一些關於bash的文件\n```\n.bash_history　\n.bash_logout\n.bash_profile\n.bashrc　每次打開一個新的shell，需要執行的命令序列\n.inputrc 用戶的鍵盤設定，以及針對用戶終端的鍵盤位置配置信息．\n```\n\n**shell的变量的定义：**\n```\n局部变量\nUNIX=\"systemV\" 變量名和等號之間不能有空格\n$echo ${UNIX}  引用shell的变量:  ${变量名}\n\n全局变量\nUNIX=systemV\nexport $UNIX  将UNIX变量转换为shell的全局变量\n$echo ${UNIX} \n\n\nenv | grep myvar\nset -a myvar 或者unset\ndeclare myvar=\"dfa\"\n查看set/env/printenv\n\n所以我們就可以使用變量做一些事情了，比如：/home/PS1\nps1=[\\u@\\h\\w]\\$\n通過這樣的方式訪問路徑\n```\n\n**不同引号对shell变量产生的不同效果：**\n1. 单引号'':shell解释程序将单引号中的内容看成纯粹的字符串信息。\n```\n$ file=report\n$ echo 'The time is 'date',the file is $file'\n结果：The time is 'date',the file is $file\n```\n2. 双引号\"\":shell解释程序将引号内的shell解释执行\n```\n$ file=report\n$ echo \"The time is 'date',the file is $file\"\n结果：The time is 'date',the file is report\n```\n3. 反引号``:表示变量中存放的是执行命令的结果\n```\n$ TT=`date`\n$ echo $TT\n结果：Mon Apr  9 20:38:24 DST 2018\n```\n\n到這裏先吧，下次說一下環境變量的配置，作爲一名開發者，環境變量配置是必不可少的．\n\n","categories":["Linux"]},{"title":"linux从入门到放弃——06解压缩原理与使用","url":"/2017/08/25/linux从入门到放弃06/","content":"\n在我们用qq的时候就会意识到一点，我们的文件只有压缩之后才能使用。之前我有一个同学曾经问我，为什么我的文件传不了啊，我看了一下。他想传过去的东西是一个文件夹，而qq传输是不能这样的，只能传压缩文件或者文件。这个时候我突然在想，为什么不能直接以文件夹的形式传输过去。文件夹不是文件，它没有文件信息。而是一个存放文件的东西。可是当我们把文件夹压缩成一个压缩包之后，它就变成一个文件了，有了文件的特性，可以正常发送。 所以，想要发送文件夹，先把它打包。这跟我们生活中也是一个道理，我们一堆东西如果要带走，首先就用东西把他绑起来。而在linux中这个绑的东西就叫tar,使用tar程序打出来的包我们称为tar包。tar包文件的命令通常都是以.tar结尾的。**生成tar包后，就可以用其他的程序进行压缩。**\n\n下面来说一下tar这个命令的几个参数：\n```\n-c: 压缩\n-x：解压\n-t：查看内容\n注意：上面三个参数同时只能有一个，你不可能说压缩的同时还能解压吧。\n-r：向压缩归档文件末尾追加文件\n-u：更新原压缩包中的文件\n-v：显示所有过程\n-O：将文件解开到标准输出\n-f: 切记，这个参数是最后一个参数，后面只能接档案名。\n```\n在linux中现在主要分几种解压缩方式：\\*.Z(compress，这是很久以前在unix上用的了)，\\*.gzip，\\*.bz2(bzip2)，\\*.xz(xz)。就是有点类似于我们windows上的zip，rar，7z。\n所以在用tar命令的时候会结合解压缩的方式选择不同的命令。\n```\n-z：gzip\n-j：bz2\n-J: xz\n-Z：compress\n```\n其实这个命令很多，那我们要不要记呢，不用，用命令\"man tar\"就可以查询手册，而且我们可能用的参数也不多，就是基本的解压缩。那我们光说不行得来试一下。\n```\n压缩：\ntar [option] 生成的压缩包名字 文件\ntar -zcvf test.tar.gz test.txt\ntar -jcvf test.tar.bz2 test.txt\ntar -Jcvf test.tar.xz test.txt\n\n解压：\ntar [option] 压缩文件名字\ntar -zcvf test.tar.gz \ntar -jcvf test.tar.bz2 \ntar -Jcvf test.tar.xz \n要是想打包一堆的话，就需要用到通配符了。比如*.jpg,就是说所有.jpg结尾的。\n\n```\n我们如果想要zip或者rar这种方式解压缩就得去下载相应的软件了。在这里的压缩效率，理论上来说，xz>bz2>gzip。这个你用哪个都可以，为什么理论上来说呢，首先不同文件可能是不同的，因为压缩是有一个前提就是可以前提，比如一个文件你压缩成百分之十，那如果还可以压缩，又压缩百分之十，这样最后都没有了，这是不可能的事情。事实上，压缩的原理就是把一些重复的通过一个字符表示，比如100000000，这里是1亿，这样就很浪费资源了，用10^8其实表示的是同一个。这个压缩其实是有一个公式：\n![](/images/linux/yasuo.png)\n然后解压缩其实讲到这里就差不多，其他的无非就是参数了。下面列一些我从网上找来的，因为网上的教程很多都比我的好，如果我再详细说每一个参数就不够时间了。我这里就是说一下解压缩的原理和使用，知道了这些你就能够知道怎么去使用,遇到不会的时候怎么查了，但是如果你要自己做一个解压缩软件，这里面还有很多算法知识。\n\n## 总结 \n1、\\*.tar 用 tar –xvf 解压 \n2、\\*.gz 用 gzip -d或者gunzip 解压 \n3、\\*.tar.gz和\\*.tgz 用 tar –xzf 解压 \n4、\\*.bz2 用 bzip2 -d或者用bunzip2 解压 \n5、\\*.tar.bz2用tar –xjf 解压 \n6、\\*.Z 用 uncompress 解压 \n7、\\*.tar.Z 用tar –xZf 解压 \n8、\\*.rar 用 unrar e解压 \n9、\\*.zip 用 unzip 解压\n\n## 范例：\n\nzip命令可以用来将文件压缩成为常用的zip格式。unzip命令则用来解压缩zip文件。\n\n1. 我想把一个文件abc.txt和一个目录dir1压缩成为yasuo.zip：\n```\nzip -r yasuo.zip abc.txt dir1\n```\n2.我下载了一个yasuo.zip文件，想解压缩：\n```\nunzip yasuo.zip\n```\n3.我当前目录下有abc1.zip，abc2.zip和abc3.zip，我想一起解压缩它们：\n```\nunzip abc\\?.zip\n```\n注释：?表示一个字符，如果用*表示任意多个字符。\n\n4.我有一个很大的压缩文件large.zip，我不想解压缩，只想看看它里面有什么：\n```\nunzip -v large.zip\n```\n5.我下载了一个压缩文件large.zip，想验证一下这个压缩文件是否下载完全了\n```\nunzip -t large.zip\n```\n6.我用-v选项发现music.zip压缩文件里面有很多目录和子目录，并且子目录中其实都是歌曲mp3文件，我想把这些文件都下载到第一级目录，而不是一层一层建目录：\n```\nunzip -j music.zip\n```\n\n## tar命令\n格式：tar [主选项+辅选项] 文件或目录\n主选项：它们不可能同时出现，告诉tar要做什么事，是必须要有的\n-c：创建新的压缩文件，相当与打包\n-x：从压缩文件中释放文件，相当于拆包\n-t：列出压缩文件中的内容\n辅选项：可选\n-C：切换到指定目录\n-z：是否同时具有gzip的属性？亦即是否需要用gzip压缩或解压？一般格式为tar.gz或xx.tgz\n-j：是否同时具有bzip2的属性？亦即是否需要用bzip2压缩或解压？一般格式为tar.bz2\n-v：压缩过程中显示文件\n-f：指定压缩文件，注意，在f之后要立即接档名（自己取的），不要再加其他参数\n-p：使用原文件的原来属性\n-exclude FILE：在压缩过程中，不要将FILE打包\n\n可以参考这篇文章[Linux下文件的压缩与解压缩](https://www.biaodianfu.com/linux-yasuo.html)\n\n补充：今天是2018/4/9，离这篇文章已经过了很久了。回头看的时候，我感觉这写的并不好。没有好好记录我学习linux的一个心得过程。说实话，要写这个东西挺多的根本写不完，我也没有那么多精力。都是用到什么就去查，只要懂得linux的设计思想，遇到什么你都可以随便去查自己去解决。这里介绍的都是基本的思想，比如linux的目录，软件安装，vim的基本使用，shell命令，这些我们肯定是记不住的，但是要学会怎么查。因为现在也开设了一门unix的课程，所以又是想到什么写什么。大部分是写的我能够看的懂，其次是有精力写就通俗一点给初学者看。\n","categories":["Linux"]},{"title":"linux从入门到放弃——05隐私安全和群组功能","url":"/2017/08/10/linux从入门到放弃05/","content":"\n这一次讲一下权限的问题，还有群组的功能。无论是在linux还是在windows中，我们都有以个叫做权限的东西，比如说你如果是管理员，就拥有管理员的权限，那么这个管理员的权限又是有什么呢？在linux中，对于任何一个文件，最多被定义为几种权限，r（可读）、w（可写）、x（可执行）、-（无权限），当然你也可以说它还拥有不可读的权限，这个其实就是无权限。我们都知道当我们在windows下查看文件的属性时候，可以设置属性为只读或者隐藏，甚至有高级选项。这是在图形界面下操作，那么在linux中又是如何更改权限的呢。首先我们要知道在linux使用八进制数字4、2、1、0分别表示r（可读）、w（可写）、x（可执行）、-（无权限），这样我们就可以表示任何一个用户所拥有的权限了，比如说：只可读（4），只可写（1），可读可写（5）。你可能知道规律了，就是进行数字的加法表示。因为每一种权限都有自己独立的八进制数字。\n然后我们现在在终端下，输入\"ls -l\"命令。这个时候你显然看到了前面出现了类似的详细显示\n\n```\nlrwxrwxrwx 1 SnowHotarubi 197609      65 Aug 19 01:06  Templates -> /home/Templates/\ndrwxr-xr-x 1 SnowHotarubi 197609       0 Aug 19 01:06  Videos/\ndrwxr-xr-x 1 SnowHotarubi 197609       0 Aug 23 23:31  WebstormProjects/\ndrwxr-xr-x 1 SnowHotarubi 197609       0 Aug 22 20:33  Workspaces/\n-rw-r--r-- 1 SnowHotarubi 197609     826 Aug 19 07:13  _viminfo\ndrwxr-xr-x 1 SnowHotarubi 197609       0 Aug 23 19:39  eclipse/\n```\n首先我们来分析一下，看第一个\"lrwxrwxrwx\",欸，怎么会出现这么多个？第一个l其实表示的link链接的意思，你可以看到后面有个箭头的东西，这个就相当于我们windows下的快捷方式。然后你会看到有\"-\"和\"d\"开头的，这里的d就是direcroty目录文件的意思，而-代表的是文件。后面的符号我们数一下可以发现是正好9个。在linux中有一个群组的概念，分为User，Group，Other。这里的UGO分别表示用户、所在组、和其他组用户对该文件的访问权限。所以就不难理解为什么是9个符号。rwx三个符号就可以表示一个用户拥有了所有权限。比如我们读一下\"drwxr-xr-x\",这一句就是说：创建的用户对其用于可读可写可执行的权限，而所在组，即创建用户属于的那个组，就好比小明在一班，而这个一班对该文件用于的权限是\"r-x\"，可读和可执行。而其他组，其他班级，对该文件也是拥有可读和可执行的权限。后面我们还可以看到文件的创建者，文件大小，修改日期这些。在这里如果是绿色的一般就是可执行文件，蓝色为目录，白色的是一般文件。上面看到了用显示的时候是通过\"drwxr-xr-x\"这种展示给我们，如果我们修改权限的时候也这样就太麻烦，所以在linux直接用数字代替表示了。ch就是change的意思，chgrp命令就是修改文件所在的组，而chonw就是更改所属者，chmod命令就是用来修改文件的权限。例如下面：\n```\nchgrp: change group /etc/group\nchonw: change owner /etc/passwd\nchmod : r(read) 2^2 = 4\n\t   W(write) 2^1 = 2\n\t   x(excure)2^0 = 1\n\t   -  0\nrwx = 7\nrw- = 6\nr-x = 5\nr-- = 4\n例如：\nchgrp root testGroup\nchonw root test\nchmod 755 test\nchmod go-w test   \nchmod +x test  \n```\n通过上面的方法，我们就可以修改一些文件权限了，而不用压缩加密。我们接着说群组功能，我们说过，在linux中有组这个概念，分别会有不同的权限。比如root组就是最大佬级别的，这个时候如果别人想用我们电脑，但是一些东西我们不想给ta看，我们通常会再建立一个普通用户给ta用。不过在windows中我们大多是建立一个管理员或者本地用户登陆，如果创建了一个普通用户，但是其实当登陆之后我们其实可以随便操作，文件也随便看，这很不安全。而linux不会这样，你如果是普通用户，你就悲催了，你很多东西用不了，修改一个基本的设置甚至都不可以，在终端里，如果没有root权限你都不能使用关机命令（shutdown），想想，如果开机的时候没有图形界面，只有一个黑框框终端，而你只有普通用户身份登陆，你都不能关机，就只能这看看那看看。说到这里，在linux有个命令级别，在/etc/inittab文件中，我们可以看到当启动的时候分为七个命令级别，通常我们用的是3、5，而5是带图形界面的，而3不带图形界面。因为图形界面很消耗内存和CPU，所以如果你是做服务器就没有必要用图形界面了。有个系统密码破解的方法，我之前试了一下并不理想。\n步骤：\n1、重启Linux，鼠标单击启动界面，按键盘上下键使启动界面暂停\n2、按键盘E键，光标往下选中kernel这行，再次按E键\n3、按空格键，然后在后面添加数字1，回车\n4、按B键启动系统\n5、在命令行输入 #passwd,回车，输入两遍新密码\n6、在命令行输入 #init 5\n就是这样，不会要求你输入原密码。所以从上面我们知道了linux是真的安全。而且linux是支持多用户多线程的，这意味着什么，在远处的一台服务器，好几个人(目前6个左右）可以通过账号远程登陆到服务器，然后同时进行操作。一般windows上我们就只能一个人使用，下一个人想用就只有等着。说起这个，linux有个叫做inode的概念，当你使用\"stat 文件\"命令就可以看到有个叫做inode的，linux中其实分为两个区，一个inode区，一个数据区。每一个文件都会对应一个inode，而且是不会改变的。所以当我们正在编辑一个文件的时候，其实还可以修改文件的名称，因为这个inode是不会变的吗，而在windows下就会报错。而如果linux下的inode用完的话，这时候如果即使你的数据区还有空间你也存不了东西，但是事实上好像并不会说inode用完的情况。当我们用stat查看文件信息的时候，还能看到其他信息，例如:文件创建者，文件所在组，大小，最后修改日期等。\n补充：linux中inode是唯一的标识符，而不是文件。所以这里有软链接和硬链接的说法。如果是硬链接就是共享同一个inode。当我们访问文件的过程其实是这样的：\n```\nfilename——>inode——>data blocks\n```\n嗯，先写这么多。感谢大家的阅读！下一次讲一下解压缩，这个还是蛮重要的，因为如果我们传一个东西，如果你压缩之后再传，可能就会小很多。好了，下期见。\n\n\n\n\n","categories":["Linux"]},{"title":"linux从入门到放弃——04入土篇之常用命令","url":"/2017/08/08/linux从入门到放弃04/","content":"\n这一次我不先打算说点什么，就是放一篇常用的命令，我会在后面的文章说以下常用的命令。当然linux的命令很多不可能全部说完，也不可能花很多时间记住全部，说多了也不会看。我觉得这个是慢慢积累的，就像背单词我们老是天天被没意思，但是如果我们在看视频或者文章中慢慢积累就没有那么累了，当然我不是在说我英语好，我的英语其实烂的不行。但是遇到不会的单词就是马上查，然后读懂句子。大家在后面学习的时候如果不记得了就可以回头看看这篇文章。有的人就说了人的记忆是有限的，鱼的记忆只有七秒。这个记忆就有点类似我们的硬盘，存储的东西是有限的，虽然我们很想把老师的视频存在硬盘里，想学习知识的时候就拿出来欣赏一下，但是空间却是已经限制的东西。那么怎么办，只要我们记得在哪里下载就可以了，然后把下载地址存在硬盘比把视频放在硬盘能够节约很多空间，在如今硬盘也成了一种消费品，还是要好好珍惜空间，备份一下。有人说你看我这脑子还要记点什么女主播啊，出装顺序啊，根本记不住那么多。因为就是说嘛linux下的命令真的很多，我们不可能就算全都记得，那不记得怎么办，能快速查到不就可以了，我们知道哪里能够快速找不就得了，干嘛非得像英文那样背下来，常用的命令记不住怎么办。多用几次就不会忘记了，就像我们每次晚上都不会忘记打开直播平台看直播，打开手机开qq那样，就是用了习惯了就不会忘记了。然后很多命令参数，我们可以通过\"man\"来查看帮助文档，在外面遇到问题找警察，在linux遇到找男人，老哥稳。\n\n### 一、通用命令\n```\nwho：\nwhereis：\nwhich  cd:可能查看某一个命令在什么位置\ncd： 改变目录（change directory）\npwd：显示当前工作目录（print working directory）\nls ： (ls -l显示长列表格式） \nls -i：显示目录下文件，并显示inode信息\nls -a： 显示隐藏文件   ls -la\n\t\t.. ：上级目录\n\t\t.  ：当前目录\nclear：清空，但是往上滑动还是会看到之前的信息。\necho \nfile：查看文件类型\ncat ：查看文件内容（不是猫\ntac ： 反向查看\nnl ：查看的时候显示行数（跟cat -n差不多）\nwc : word count ,单词计算\ntouch /vim：新建空文件\nmkdir：建立目录\nrmdir：删除空目录\nrm：删除文件和目录   然后 ： y\nrm -rf：删除所有内容（包括目录和文件）r递归 f强制   （return、force）\nmv：移动（如果是：mv  test  t，就是修改名字了。）\ncp ：复制命令\ncp -r dir1 dir2递归复制命令（复制子目录信息）\nln ：建立符号连接。使用inode产生心的名字，共享inode。\nln -s：源目标，有点类似。软链接，有点类型windows的快捷键。不共享inode。\nln -s /etc/inittab inittab：inittab指向实际文件/etc/inittab\nmore：显示文件内容，带分页\n\t\tmore, less, head tail: 显示或部分显示文件内容\n\t\tspace下一页\n\t\tshift + pageup/pagedown （相当于右边栏的上下滑动）\nless：显示文件内容带分页\ncut:按列或按域截取输入行中所指出的内容\nmail:\ntelnet:\nid:\nps:\nftp:\nssh:\ntalk:\nfile:\ndf:\nfind:\nping:\nhostname:\nlearn：\n<br/>\ngrep：在文本中查询内容\ngrep “内容” 哪个文件\ngrep -n“admin”admin.txt\n\t\t-n表示在哪一行\n\t| ：管道命令\n\t\t在linux和unix系统中， 就是把上一个命令的结果交给 |的后面的命令处理\nman（manual）命令相当于dos下的help\n\t在现实生活中，有问题找警察，在linux世界中，有问题问男人。老哥稳，这个对于我们非常重要，不懂的通过帮助稳定来解决。\n查找命令\nfind 目录 -name 文件名\nfind / -atime -10 :十小时\nfind . -cmin -10:十分钟内更改过的文件或目录\nfind . -ctime -10:十小时\nfind /root -size +10k: 目录下大小为10k以上的文件\nfind /home -amin -10:十分钟内存取的文件或目录\n\t重定向命令\nls -l > a.txt :列表的内容写入文件a.txt中（覆盖写\nls -al >> a.txt: 列表的内容追加到文件a.txt的末尾\n例如： grep -n \"admiin\"  a.txt > a.txt\n\t\tls >> a.txt\n\t\ta.txt < ls\n<br/>\n时间/日期\ndate\ntime\ncal  （cal 2017）\n用户管理\nsu / su root（切换到root）/sudo -s（logout尝试失败）\nlogout, login: 登录shell的登录和注销命令\n添加用户：useradd 用户名\n修改密码：passwd 用户名 p(用passwd -h查看)\nuserdel 用户名：删除用户\nuserdel -r 用户名：删除用户以及用户主目录\n切换用户： su 用户名\n<br/>\n其他\nnetstat -an\nifconfig(ipconfig)\nping 127.0.0.1\nstty -a: 可以查看或者打印控制字符(Ctrl-C, Ctrl-D, Ctrl-Z等)\nlp/lpstat/cancel, lpr/lpq/lprm: 打印文件.\n更改文件权限： chmod u+x...\nfg jobid :可以将一个后台进程放到前台。\nCtrl-z 可以将前台进程挂起(suspend), 然后可以用bg jobid 让其到后台运行。\njob & 可以直接让job直接在后台运行。\nkill : send a signal to a process. eg: kill -9 发送的是SIG_KILL信号。。。 具体发送什么信号 可以通过 man kill 查看。\nps: ps -e 或 ps -o pid,ppid,session,tpgid, comm (其中session显示的sessionid, tpgid显示前台进程组id, comm显示命令名称。)\n<br/>\n命令：init[0123456]——运行级别\n0：关机\n1：单用户\n2：多用户状态没有网络服务\n3：多用户状态网络服务\n4：系统未使用保留给用户\n5：图形界面\n6：系统重启\n常用运行级别是3和5，要修改默认的运行级别可改文件/etc/inittab的id：5：initdefault：这一行中的数字\n```\n　　\n### 二 、ubuntu常用命令\n\n1. dpkg: package manager for Debian\n安装： dpkg -i package\n卸载： dpkg -r package\n卸载并删除配置文件: dpkg -P |--purge package\n如果安装一个包时。说依赖某些库。 可以先 apt-get install somelib...\n查看软件包安装内容 :dpkg -L package\n查看文件由哪个软件包提供: dpkg -S filename\n另外 dpkg还有 dselect和aptitude 两个frontend.\n\n2. apt\n安装: apt-get install packs\napt-get update : 更新源\napt-get upgrade: 升级系统。\napt-get dist-upgrade: 智能升级。安装新软件包,删除废弃的软件包\napt-get -f install ： -f == --fix broken 修复依赖\napt-get autoremove: 自动删除无用的软件\napt-get remove packages :删除软件\napt-get remove package --purge 删除包并清除配置文件\n清除所以删除包的残余配置文件: dpkg -l |grep ^rc|awk '{print $2}' |tr [\"/n\"] [\" \"]|sudo xargs dpkg -P\n安装软件时候包的临时存放目录 : /var/cache/apt/archives\n清除该目录: apt-get clean\n清除该目录的旧版本的软件缓存: apt-get autoclean\n查询软件some的依赖包： apt-cache depends some\n查询软件some被哪些包依赖: apt-get rdepends some\n搜索软件: apt-cache search name|regexp\n查看软件包的作用：apt-cache show package\n查看一个软件的编译依赖库: apt-cache showsrc packagename|grep Build-Depends\n下载软件的源代码 : apt-get source packagename (注: sources.list 中应该有 deb-src 源)\n安装软件包源码的同时, 安装其编译环境 :apt-get build-dep packagename (有deb-src源)\n如何将本地光盘加入安装源列表: apt-cdrom add\n\n3. 系统命令:\n查看内核版本： uname -a\n查看ubuntu 版本: cat /etc/issue\n查看网卡状态 : ethtool eth0\n查看内存,cpu的信息： cat /proc/meminfo ; cat /proc/cpuinfo(/proc下面的有很多系统信息)\n打印文件系统空间使用情况: df -h\n查看硬盘分区情况: fdisk -l\n产看文件大小: du -h filename;(du:disk user)\n查看目录大小： du -hs dirname ; du -h dirname是查看目录下所有文件的大小\n查看内存的使用： free -m|-g|-k\n查看进程： ps -e 或ps -aux -->显示用户\n杀掉进程: kill pid\n强制杀掉： killall -9 processname\n\n4. 网络相关：\n配置 ADSL: sudo pppoeconf\nADSL手工拨号: sudo pon dsl-provider\n激活 ADSL : sudo /etc/ppp/pppoe_on_boot\n断开 ADSL: sudo poff\n根据IP查网卡地址: arping IP地址\n产看本地网络信息（包括ip等）: ifconfig | ifconfig eth0\n查看路由信息: netstat -r\n关闭网卡： sudo ifconfig eth0 down\n启用网卡： sudo ifconfig eth0 up\n添加一个服务: sudo update-rc.d 服务名 defaults 99\n删除一个服务: sudo update-rc.d 服务名 remove\n临时重启一个服务: /etc/init.d/服务名 restart\n临时关闭一个服务: /etc/init.d/服务名 stop\n临时启动一个服务: /etc/init.d/服务名 start\n控制台下显示中文: sudo apt-get install zhcon\n查找某个文件: whereis filename 或 find 目录 -name 文件名\n通过ssh传输文件\nscp -rp /path/filename username@remoteIP:/path #将本地文件拷贝到服务器上\nscp -rp username@remoteIP:/path/filename /path #将远程文件从服务器下载到本地\n\n5. 压缩:\n解压缩 a.tar.gz: tar zxvf a.tar.gz\n解压缩 a.tar.bz2: tar jxvf a.tar.bz2\n压缩aaa bbb目录为xxx.tar.gz: tar zcvf xxx.tar.gz aaa bbb\n压缩aaa bbb目录为xxx.tar.bz2: tar jcvf xxx.tar.bz2 aaa bbb[6] \n6. Nautilus：\n　　特殊 URI 地址\ncomputer:/// - 全部挂载的设备和网络\nnetwork:/// - 浏览可用的网络\nburn:/// - 一个刻录 CDs/DVDs 的数据虚拟目录\nsmb:/// - 可用的 windows/samba 网络资源\nx-nautilus-desktop:/// - 桌面项目和图标\nfile:/// - 本地文件\ntrash:/// - 本地回收站目录\nftp:// - FTP 文件夹\nssh:// - SSH 文件夹\nfonts:/// - 字体文件夹，可将字体文件拖到此处以完成安装\nthemes:/// - 系统主题文件夹\n显示隐藏文件: Ctrl+h\n显示地址栏: Ctrl+l\n查看已安装字体: 在nautilus的地址栏里输入”fonts:///“，就可以查看本机所有的fonts[6] \n\n7.补充部分：\n查看本地所有的tpc,udp监听端口: netstat -tupln (t=tcp, u=udp, p=program, l=listen, n=numric)\n通过man搜说相关命令: man -k keyword . eg: man -k user\n或者用 apropos\n统计文件所占用的实际磁盘空间： du (du - estimate file space usage)\n统计文件中的字符，字节数: wc -c/-l/-w (wc - print the number of newlines, words, and bytes in files)\n查看文件的内容： od -x/-c/.... (od - dump files in octal and other formats)\n　　我认为od最有用的就是文件的字节流了: od -t x1 filename\n　　查看文件的 Ascii 码形式: od -t c filename (其中统计信息最左边的是： 字节数)\n查找命令所在文件的位置： which od 输出： /usr/bin/od\n　　查看该文件由哪个包提供： dpkg -S /usr/bin/od 输出: coreutils: /usr/bin/od\n　　再查看coreutils包的全部内容就知道了linux的核心命令: dpkg -L coreutils\n　　然后 info coreutils 哈哈，认真学吧， 满世界都是命令!\n　可以用man 命令产看某个命令的所有section 的解释: man -a tty\n　　然后用q,和next 转换到下一个section的解释\nbash 的好用的快捷键:\n　　ctrl+a:光标移到行首。\n　　ctrl+b:光标左移一个字母\n　　ctrl+c:杀死当前进程。\n　　ctrl+d:退出当前 Shell。\n　　ctrl+e:光标移到行尾。\n　　ctrl+h:删除光标前一个字符，同 backspace 键相同。\n　　ctrl+k:清除光标后至行尾的内容。\n　　ctrl+l:清屏，相当于clear。\n　　ctrl+r:搜索之前打过的命令。会有一个提示，根据你输入的关键字进行搜索bash的history\n　　ctrl+u: 清除光标前至行首间的所有内容。\n　　ctrl+w: 移除光标前的一个单词\n　　ctrl+t: 交换光标位置前的两个字符\n　　ctrl+y: 粘贴或者恢复上次的删除\n　　ctrl+d: 删除光标所在字母;注意和backspace以及ctrl+h的区别，这2个是删除光标前的字符\n　　ctrl+f: 光标右移\n　　ctrl+z : 把当前进程转到后台运行，使用’ fg ‘命令恢复。比如top -d1 然后ctrl+z ，到后台，然后fg,重新恢复\n快速粘贴：先在一个地方选中文字，在欲粘贴的地方按鼠标 中键 即可。\n等效中键：a 、按下滑轮等效于中键。b、同时按下鼠标 左右键，等效于中键。\n快速重启X服务： 同时按下： Alt + Ctrl + Backspace 三个键。\n打开\"运行\"窗口： 同时按下 Alt + F2 键。\n戴屏： a、全屏：直接按下 PrtScr 键。\n　　b、当前窗口：同时按下 Alt + PrtScr 键。\n　　c、延时戴屏：在 终端 或 \"运行\"窗口中输入命令： gnome-screenshot --delay 3 ，将延时 3 秒后戴屏。\n　　* 直接将 文件管理器 中的文件拖到 GNOME终端 中就可以在终端中得到完整的路径名。[6]  8.ulimit\n　　ulimit：显示（或设置）用户可以使用的资源的限制（limit），这限制分为软限制（当前限制）和硬限制（上限），其中硬限制是软限制的上限值，应用程序在运行过程中使用的系统资源不超过相应的软限制，任何的超越都导致进程的终止。\n　　ulimited 不限制用户可以使用的资源，但本设置对可打开的最大文件数（max open files）\n　　和可同时运行的最大进程数（max user processes）无效\n　　-a 列出所有当前资源极限\n　　-c 设置core文件的最大值.单位:blocks\n　　-d 设置一个进程的数据段的最大值.单位:kbytes\n　　-f Shell 创建文件的文件大小的最大值，单位：blocks\n　　-h 指定设置某个给定资源的硬极限。如果用户拥有 root 用户权限，可以增大硬极限。任何用户均可减少硬极限\n　　-l 可以锁住的物理内存的最大值\n　　-m 可以使用的常驻内存的最大值,单位：kbytes\n　　-n 每个进程可以同时打开的最大文件数\n　　-p 设置管道的最大值，单位为block，1block=512bytes\n　　-s 指定堆栈的最大值：单位：kbytes\n　　-S 指定为给定的资源设置软极限。软极限可增大到硬极限的值。如果 -H 和 -S 标志均未指定，极限适用于以上二者\n　　-t 指定每个进程所使用的秒数,单位：seconds\n　　-u 可以运行的最大并发进程数\n　　-v Shell可使用的最大的虚拟内存，单位：kbytes\n　　eg: ulimit -c 1000(可以先通过ulimit -c 查看原来的值)[6]\n<br>\nQ:用户不在sudoers文件中，此事将被报告。\nA:su root ———> visudo ———> root ALL... ————> add youruser。\n\nQ:解决修改错误配置的方法，用户级别如果是6.（如何找到丢失的密码）\nA：在进入grub引导界面的时候，输入'e'\n在选中第二行。。。。。。。。输入e\n在最后输入1 [单用户级别]\n(其他模式的话就不行了,写成其他没有意思，这个就需要明白linux启动的顺序，只有单用户级别不会读取etc/inittab这个文件）\n<br><br>\n好了，这一期就到这里，谢谢你的阅读！\n\n","categories":["Linux"]},{"title":"linux从入门到放弃——03细说软件安装与vim大法","url":"/2017/08/08/linux从入门到放弃03/","content":"\n上一次我们说到了如何安装linux以及了解linux的设计思想，这对我们学习linux都是非常重要的。如果在安装软件遇到问题而卸载的同学想必是不会看到这篇文章了。我们先来说点，怎么学习linux，首先要有信心，不要遇到问题就退缩放弃了，遇到问题得学会思考和动手解决，其次是要选择合适的教程，找本书和视频学习，书本入门推荐是《鸟哥的私房菜》。最后是坚持下去，多去看社区和官方文档。其实学习没什么途径，如果说途径也只是说有老司机带，可是对于很多老司机来说不可能说一点一点的告诉你，一般都是告诉你一个方向，很多人都是自己慢慢摸索来着。所以没什么捷径，就是自己多研究，这也是我写下linux系列的目的，一个是便于我自己思考，另一个就是把我学习过程的一个经历写下分享给大家，希望有点帮助吧。恩，下面说说怎么安装软件吧。\n\n<br>\n### 阅读说明\n阅读说明部分开始没看懂没关系，随便看看，然后看完安装方式回头再看看。这些命令可能你还不了解，我下一篇将会介绍，我们一步一步来。首先了解linux安装软件的原理。\nLinux系统中,软件通常以**源代码**或者**预编译包**的形式提供。\n1. 软件源代码需要编译为二进制的机器代码才能够使用,安装比较耗时,不过您可以自行调节编译选项,决定需要的功能或组件,或者针对硬件平台作一些优化。\n2. 预编译的软件包,通常是由软件的发布者进行编译,您只要将软件拷贝到系统中就可以了。考虑到预编译软件包的适用性,预编译软件包通常不会针对某种硬件平台优化。它所包含的功能和组件也是通用的组合。\n\n一般来说，当我们装了linux之后，第一步不是安装中文输入法，或者配置环境这些，不是做别的，就是选择合适的源，按照下面顺序打开。\n```\nSystem Settings——Software&Updates——Ubuntu Software——Download from——Select Best Server——Choose Server\n```\n我这里选择的是“http：//mirrors.ustc.edu.cn/ubuntu”\n\n<img src=\"/images/linux/updates.png\" width=\"500px\" align=\"center\"/>\n然后打开我们的终端（Ctrl+Alt+T）更新源。\n```\n$ sudo apt-get update\n$ sudo apt-get upgrade  \n```\n如果你不更新的话，在你用apt-get方式安装的时候很可能就会出现下面的安装错误提示：\n```\nE: Unmet dependencies. Try 'apt-get -f install' with no packages (or specify a solution)\n\n```\n原因：列软件包具有未满足的依赖关系，非正常停止apt-get install。\n解决方法：\n```\n$ sudo apt-get -f（sudo apt --fix-broken install修复受损安装包）\n$ sudo apt-get update\n$ sudo apt-get upgrade  \n```\n说明：f参数为--fix-broken的简写形式，可以在man apt-get 中搜索-f参数查询到其帮助信息。-f参数的主要作用是修复依赖关系（depends），假如用户的系统上有某个package不满足依赖条件，这个命令就会自动修复，安装程序包所依赖的包。（然后在linux中有一句话，出门遇到问题找警察，linux遇到问题找男人man，但是这个其实是manual单词的缩写，说明书，手册的意思）。\nsudo apt-get update：获得最近的软件包的列表，然后列表中包含一些包的信息，比如这个包是否更新过。\nsudo apt-get upgrade ：如果这个包没有发布更新，就不管它；如果发布了更新，就把包下载到电脑上，并安装。\napt-get upgrade 与apt-get upgrade的关系：\n由于包与包之间存在各种依赖关系。upgrade只是简单的更新包，不管这些依赖，它不添加包，或是删除包。而upgrade可以根据依赖关系的变化，添加包，删除包。\n\n### 安装方式\n下面介绍在ubuntu中安装软件的六种方式：apt-get、dpkg安装deb、make install安装源码包、二进制包的安装方式、rpm包的安装方式  、其他方式。\n（sudo这个我们暂时不解释，你可以理解为提升权限的意思，预设为root，root就是我们的最高权限因为之前也说了普通用户不能做所有的事情）\n#### 1.apt-get\nUbuntu有许多软件源，使用**apt-get install 软件名**是比较常见的一种方法。apt-get：apt-get命令是Debian Linux发行版中的**APT软件包管理工具**。\n比如安装build-essential\n我们打开终端，输入：\n```\n$sudo apt-get install build-essential\n```\n执行后问你\n```\nDo you want to continue [Y/n]? y\n```\n我们当然是选择安装了。\n然后我们说说apt-get的的各种参数：\napt-get install xxx ：安装xxx（如果带有参数，那么-d 表示仅下载 ，-f 表示强制安装 ）\napt-get remove xxx  ：卸载xxx  \napt-get update      ：更新软件信息数据库  \napt-get upgrade     ：进行系统升级  \napt-cache search    ：搜索软件包  \n提示：建议您经常使用“apt-get update”命令来更新您的软件信息数据库 \n\n#### 2.ubuntu软件包格式为deb\ndeb是debian系Linux的包管理方式,ubuntu是属于debian系的Linux发行版,所以默认支持这种软件安装方式。\n```\n$sudo  dpkg  -i  package.deb\n```\n或者直接双击安装，不建议。\n这里的pkg是package的意思。\n下面简单列了几个dpkg命令：\ndpkg -i package.deb \t安装包\ndpkg -r package \t\t删除包\ndpkg -P package \t\t删除包（包括配置文件）\ndpkg -L package \t\t列出与该包关联的文件\ndpkg -l package \t\t显示该包的版本\ndpkg –unpack package.deb解开 deb 包的内容\ndpkg -S keyword \t\t搜索所属的包内容\ndpkg -l \t\t\t列出当前已安装的包\ndpkg -c package.deb \t列出 deb 包的内容\ndpkg –configure package 配置包\n\n根据Ubuntu中文论坛上介绍，使用apt-get方法安装的软件，所有下载的deb包都缓存到了/var/cache/apt/archives目录下了，所以可以把常用的deb包备份出来，甚至做成ISO工具包、刻盘，以后安装Ubuntu时就可以在没有网络环境的情况下进行了。\n\n#### 3.make install源代码安装\n如果用源代码编译安装前,需要先建立编译环境,($sudo apt-get install build-essential )。在linux中很多软件只提供了源代码给你,需要你自己进行编译安装,一般开源的软件都会使用tar.gz压缩档来进行发布,当然也有其他的形式。ubuntu支持ZIP,TAR.GZ为后缀的压缩文档，对于RAR文件，一般通过默认安装的ubuntu是不能解压rar文件的，只有在安装了rar解压工具之后，才可以解压。\n然后解压到/tmp目录下,在解压的目录内打开Terminal（终端），使用命令”ls“看看有没有configure这个文件。\n然后源码安装大致可以分为三步骤：\n```\n配置（$sudo ./configure）–＞ 编译（$sudo make） –＞ 安装（$sudo make install）。\n```\n\n配置：这是编译源代码的第一步，通过 ./configure 命令完成。执行此步以便为编译源代码作准备。常用的选项有 --prefix=PREFIX，用以指定程序的安装位置。例如：./configure --prefix=/usr/local/nagios \n编译：一旦配置通过，就可以用 make 指令来执行源代码的编译过程。不用软件编译所需的时间也各有差异，我们所要做的就是耐心等候和静观其变。这里虽然仅下简单的指令，但有时候所遇到的问题却十分复杂。\n安装：如果编译没有问题，那么执行 sudo make install 就可以将程序安装到系统中了。\n\n#### 4. 二进制包的安装方式\n有不少不开源的商业软件都会采用这种方式发布Linux软件,例如google earth,拿到二进制软件后,把它放到/tmp目录,在终端下进入安装目录,在安装目录下执行:\n```\n./软件名\n```\n\n然后按照一步步提示,就能安装该软件。例如安装realplayer播放器:你直接到官网 http://www.real.com/linux 下载 RealPlayer 的安装包,安装包是 .bin 格式,用如下命令安装:\n\nchmod +x RealPlayer11GOLD.bin\n\n./RealPlayer11GOLD.bin    \n#### 5.rpm包的安装方式    \nrpm包是deb包外最常见的一种包管理方式,但ubuntu同样可以使用rpm的软件资源。首先我们需要安装一个rpm转deb的软件\n```\nsudo apt-get install alien\n```\n然后就可以对rpm格式的软件转换成deb格式了:\n```\nsudo alien -d package.rpm\n```\n然后就可以用deb的安装方式进行软件安装。也可以不需转换而直接对rpm包进行安装:\n```\nalien -i *.rpm\n```\n更多的alien使用方法可以用-h参数查看相应说明文档。\n#### 6.其他方式\n其他安装方式一般还有脚本安装方式。**这类软件你会在软件安装目录下发现类似后缀名的文件,如: .sh .py .run等等,有的甚至连后缀名都没有,直接只有一个INSTALL文件。**对于这种软件,可尝试以下几种方式安装:最简单的就是直接在软件目录下输入: ./软件名* (注意有一个*号,那是一般可以通配所有后缀名)或者 : sh 软件名.sh或者: python 软件名.py)\n\n### 总结\n一般来说，我们一般是用apt-get这种方式，如果其他方式，你下载解压后要看看是上面哪一种形式，就用哪一种方式，如果不行的话，通常里面会有个readme的文件，查看里面的说明教程就可以了。  \n<br>\n好了，上面几种方法其实已经够你用了，那么你可以到官网上下载安装中文输入法了。在这之前你还需要安装一个叫做fcitx的东西，具体就不做解释，这个就相当于你安装这个东西需要先安装另一个东西作为环境。比如说在windows下你要安装eclipse，首先就要有JDK，因为这个eclipse是java写的，要想进行编译和解释的话就要有这个开发环境。我觉得现在你已经会安装了，那么你就可以把你在windows下的一些必备的软件安装在上面了。安装完后是不是觉得linux顺手了一点。但是有一点的是QQ是Linux中文用户面对的问题之一，一般情况下不推荐使用独立软件版本登录QQ，最合适的方式是使用[WebQQ](http://web.qq.com)\n<br>\n***********************\n好了，如果说linux就这样的话当然还不如windows好用，你看在windows还可以玩各种游戏多舒服，操作简单又方便。那这个linux肯定是有自己的特点，首先来说，linux是完全免费开源的，就是说你可以随便修改源代码，像windows就不是开源的，我们不能修改，只能通过他的接口去调用一些东西。其次linux是非常安全的系统，之前也说了linux是以文件的形式，这样就可以对其设置权限，你不能随便查看和修改一些文件。再有就是linux支持多用户，多任务。各个用户对于自己的文件设备有自己特殊的权利，保证之间互不影响。多任务则使得linux多个程序同时并独立地运行。linux其他特点，例如完全兼容POSIX1.0标准，良好的桌面环境等，支持多种硬件平台。其中比较主流的是的GNOME桌面环境，即GNU网络对象模型环境 (The GNU Network Object Model Environment)，GNU计划是开放源码运动的一个重要组成部分。目标是基于自由软件，为Unix或者类Unix操作系统构造一个功能完善、操作简单以及界面友好的桌面环境，他是GNU计划的正式桌面。linux主要操作其实是以命令的形式，所以如果不懂linux的命令其实不算是了解linux。\n<br>\n我们就以用C语言编写运行一个“hello world”来介绍认识一些命令。首先介绍几个简单的命令，我们先打开终端（Terminal）\n\n<img src=\"/images/linux/terminal.png\" align=\"center\" width=“400px”/>\n\nsnowhotarubi@linux:~$ \n那我们来做点什么呢，首先呢，我们来看看我们在哪里，就可以用**pwd**这个命令，英文就是“print work directory”。我的英文不好，但是记这些命令我还是用理解缩写的意思去记，命令真的很多，我也没有什么好的方法，我觉得就是多用养成习惯就不会忘记了，有好方法的话我还是愿意听一下。然后一些命令其实我们不用非要记住，用到的时候能够马上找到就可以了。\n<img src=\"/images/linux/show1.png\" align=\"center\"/>\n好了，接下来我们可以看看这个目录下有什么，就用**ls**的命令。如果我们想看详细的信息就可以用**ls -l**。接下来，我们如果想要查看上一级目录就可以用**cd ..**，这个cd就是改变目录的意思，而“..\"表示上一级，”.“表示当前目录，那下一级怎么办呢？ 比如我要进入home，这个时候就可以用 ”cd home/“(输入前面部分，可以用tab键补全）。\n\n我们发现$符号前面的字符变了，就是我们的/，说明前面就是表示我们当前的路径，相对于/home/snowhotarubi，这里有个绝对路径和相对路径的概念，简单来说，像cd /home/snowhotarubi/Desktop这种就是以绝对路径方式进入，而cd Desktop就是相对路径的形式。如果我们在这时候cd Desktop是会显示No such file or directory，这里因为相对路径是相对于当前目录，而绝对路径是绝对于根目录”/“。\n\n这个时候我们来创建一个hello.c文件吧，**mkdir:建立空目录  touch:新建空文件**\n例如：snowhotarubi@linux:~$touch hello.c\n那么问题又来了，我们怎么用命令进行修改或者编辑文件，我们都知道双击一个编辑器我们就可以编辑东西，进行保存和修改，删除这些基本操作。虽然在linux中也有文本编辑器，但是在终端里人们认可的通用的基本就是vim编辑器，我安装的第一个软件也是vim。前面我们已经说过了安装方法了**sudo apt-get install vim**。安装完后，\nsnowhotarubi@linux:~$vim helloc.c\n (你会发现你进入了一个神奇的世界，但是什么都不能做，你怎么敲打好像都没有输入的反应)\n这时候，你如果在英文状态下按下键盘上的a/i（add/insert）就发现可以进行编辑了，你会发现下面出现了一个--INSERT--(或是--插入--)，这就是插入模式，接着我们熟练的写下了:\n```\n#include<stdio.h>\nint main()\n{\n    printf(\"Hello World!\\n\");\n    return 0;\n}\n```\n<img src=\"/images/linux/show2.png\" align=\"center\"/>\n然后就是怎么退出保存的问题了，通常我们在学编程的时候直接用IDE，直接在里面新建一个项目，新建源文件编写就可以直接点击运行。在这里，vim编辑器有几种退出方式，首先要按一下ESC退出命令，进入命令模式，通常我们把vim分为三种模式：命令模式，输入模式（编辑/插入模式），末行模式。，接着我们输入\":\"这个分号，我们就发现光标移到了下面，并且出现一个\":\"等待我们输入，这就是我们说的末行模式。我这里因为没有权限所以会显示只读，不能编辑，这个权限问题我们后面会说到，退出方式：\n1. :q  （退出不保存，通过会出现警告，“q！”则表示强制推出）\n2. :wq(退出并保存）\n3. ：x (退出保存）\n其实vim进入输入模式有几种方式：i（insert）、a（add）、o（open）、c（change）、r（取代命令）、s（替换命令）\n接着我们用gcc编译一下，这时候用ls命令我们就可以看到当前目录下有个a.out的文件，运行它，用名“./a.out”,我们之前说过了“.”表示当前路径，如果只是“a.out”的话就会commad not found.你也可以使用'gcc -o hello hello.c'指定输出名.\n\n### vim(visual interpreter IMproved )編輯器\nvim是linux下的常用一種編輯器，在vim中有三種模式，常用的幾個快捷鍵．\n```\nhjkl　上下左右\na: add 將文本添加在光標之後\ni: insert將文本插入在光標之前\nG　光標移至文件最後一行\nnG　光標移至文件第ｎ行．　　１G,nG\n0　光標移至首行\n$　光標移至行尾\nw　光標右移一個字符 \nnw光標右移ｎ個字符\n複製粘貼撤銷刪除：　ｙ(copy),p(paste),u(undo),d(delete)\nd0\ndG\ndw, ndw 刪除ｎ個單詞\ndd, ndd  4dd 刪除ｎ行\n```\n\n末行命令模式：\n```\n進入，打一個冒號:\n或者,打一個／\n\n/exp從光標處向前尋找字符串exp\n?exp從光標處向後尋找字符串exp\nn重複前一搜索命令\nN在光標處向方向重複前一搜索命令\n:w　寫盤\n:w >> file　寫盤到文件file中\n:w! file　強行進行寫盤文件file的動作\n:q　退出編輯程序\n:q!　強行退出編輯程序，同事放棄編輯緩衝區中的內容\n:wq　保存並退出\n:set nu　設置編輯時顯示行號\n:set nonu　設置編輯時不顯示行號\n```\n好了，vim的话就不介绍太多了，我们可以在终端下直接输入vim查看，这个东西如果你度过了前期痛苦的阶段，也不失为一个很爽的编辑器。前提当然是你花时间去学习，这个软件设计的定位本来就不是针对大众，是对有一些基础的人，帮助提高效率的。你可能会说我用其他编辑器效率比这高百倍，仁者见仁吧，用的好效率当然会提高，也有一些vim的高手，当然像我们这种就不是高手了。但是不管是高手还是我们，如果要用linxu必须学会vim编辑器的基本操作。我们继续说，这时候如果你切换到末行模式输入help的话它有可能跳出来的是英文版本的帮助，在这里可能会有中文翻译，在终端下直接输入：snowhotarubi@linux:~$vimtutor\n，（这个tutor就是教程，教导的意思）可能刚开始使用确实很麻烦，比如我们想点到这里编辑发现不行，你会觉得很痛苦，不要觉得设计出来的人很傻，我们应该是想想别人是怎么样的，为什么会这样设计，而不是按照我们的想法是断定别人的想法。当你认真了解使用它后，我觉得你应该会喜欢上它。\n\n可能这几个命令你会觉得无聊，下面列出几个命令，你自己可以尝试敲一下。\n```\nshutdonw -h now:立刻关机\nshutdonw -r now:关机重启\nreboot:重启\nbc:计算器   （quit：退出）\ndate:时间\ncal:日历\ncal 2017\ncal 8 2017\nexit:退出\ncat:查看文件内容\ncd:改变目录\npwd:显示当前工作目录\nls:显示目录内容\nstat:显示文件信息\nls -l:显示长列表格式\nls -a:显示隐藏文件\n.. ：上级目录（如配合cd使用：cd ..这样你就会进入到上一级目录了）\n. ：当前目录\nclear:清除\nmkdir:建立空目录\ntouch:新建空文件\nvim 文件名：新建一个文件并用vim打开。\nrmdir：删除空目录（注意是空的)\nrm:删除文件和目录\nrm -rf：删除所有内容（包括目录和文件）（r：递归，f：强制，就是英文单词force）\n```\n\n好了，这一期就介绍到这里，下一次应该会说群组功能，文件的权限和安全。恩，感谢你的阅读！\n\n\n","categories":["Linux"]},{"title":"linux从入门到放弃——02linux安装说明书","url":"/2017/08/07/linux从入门到放弃02/","content":"\n如果阅读过我上一篇linux的前世今生的朋友就应该对linux有了一定的了解。这一章讲点什么呢，我打算讲一下linux的安装和使用。我这里选择的是Debian系列中的ubuntu。上一篇我也说了linux有很多发行版，这个我们新手不用去纠结选择哪个，我们只是用来学习，这一会又说这个桌面环境好看，又说那个桌面很丑，结果搞了半天都在引战争，我觉得每一个存在即是合理，即有存在的理由，如果你非要搞懂这些区别应该是先深入了解一个，然后再学其他进行对比，就是那句话嘛我不懂所以就不做评论，不然懂的人一眼就看出来你个外行，然后还在那装逼肯定是要被打脸了，我这里也说了我写这个系列首先是整理一下我的东西，记录我的学习过程，然后是想给大家分享这么一个过程。我看书比较喜欢看人物传记和历史类的书，因为我觉得了解别人的历史和故事，即使我们没有经历或者不会经历，也会给我们一些经验，然后我就会想我遇到了将会怎么办。然后其实桌面环境很消耗CPU和内存，如果你以后在公司中用的话在大多数情况下给你的就只是一个黑框框。ubuntu是一款广受欢迎的开源Linux发行版，和其他Linux操作系统相比，ubuntu非常易用，和Windows相容性很好，非常适合Windows用户的迁移，目前全世界桌面操作系统市场约有5%由Linux家族所占据，而根据多项调查结果显示，其中约有一半为ubuntu（Windows则占84%左右）。\n\n如果我们要了解linux，首先就应该了解linux的基本思想，分为两点：第一，一切都是文件；第二，每个软件都有确定的用途。这里就是说linux系统中的所有都归结为一个文件，包括命令、硬件和软件设备、操作系统、进程等等对于操作系统内核而言，都被视为拥有各自特性或类型的文件。至于说Linux是基于Unix的，很大程度上也是因为这两者的基本思想十分相近。在Windows操作系统下不用分区即可安装使用，就如同安装一个应用软件那么容易，整个ubuntu操作系统在Windows下就如同一个大文件一样，很容易卸载掉。像如何是在windows中我们就会叫做盘符，而linux中我们叫做目录或者说文件，当你插上一个u盘的时候，显示的也是一个挂载点而不是像windows上的盘符。后面我们会说到虚拟机。其次需要知道管理员（root），这个拥有最高的权限，就是可以对系统做所有操作，像我们在windos上也是那个以管理员身份登录。跟windows不同的是，linux当我们添加了多个用户的时候，可以对文件属于自己的管理，但是在windows的话其他用户登录你的系统，你只有加密文件或者其他的才能限制别人不修改或查看你的文件，这样的话就非常麻烦。而在linux上，如果是做服务器管理的话，可能你的主机会在一个离你很远的地方，这个时候不可能给你说提供图形界面，这样的话听消耗CPU和内存的，然后这个时候你如果是普通用户甚至都不能关机。而在linux中又有一个概念，就是用户不能单独存在，它是以组的形式存在，比如管理员组，普通用户组。在linux中分为文件所有者（Owner）、所在组（Group）、其他组（Other），而一个用户可以属于多个组，比如小明可以是踢足球这个组，也可以同时属于音乐社这个组，这个是合理的，但不能说小明什么都不是，即使它没参加什么，那么这个没参加什么就叫平民组呗。\n\n<img src=\"/images/linux/ubuntu.jpeg\" align=\"center\"/>\n\n说的差不多，那我们来看看怎么安装。首先一般是分为3种方案：\n1.如果是windows用户，想尝鲜的同学其实没有必要搞那么多花里胡哨的东西，说不定过几天你就从入门到卸载了，但是这也有个好处，就是想学习的同学在虚拟机下先了解一下，觉得不错的话再选择考虑后面两个方案。前面不是说了linux的第一个思想就是文件，那么我们就可以在windows下安装，这里我们就用到了虚拟机，虚拟机是什么呢，可以理解为虚拟一个环境，或者理解为一个软件。这个用vmware就可以了。\n\n<img src=\"/images/linux/index.jpeg\" align=\"center\"/>\n\n我这里就不说具体的安装了，傻瓜式的安装就行了，其中你可能会遇到虚拟机服务器没有打开问题或者权限不足的问题，简单说下解决方法：进入服务打开一个叫做vmware server...选择启动就可以了，另一个就是以管理员身份运行vmware软件。\n2.就是windows+ubuntu（linux）装双系统，这样你想用linux的时候就换到linux，用windows就换到windows下。网上有很多不错的教程比我说的好，怎么安装双系统一搜就出来了，但是不懂的朋友建议还是小心点不要把windows搞坏，我们的男同学经常去宿舍帮女同学装系统，然后装完就回去了，但是这个装linux系统还是有些不同，建议是先做好备份重要东西的准备。为什么会要用双系统呢?我觉得原因大概是在windows下用虚拟机速度会比较慢一点，而且有一个缺点就是当遇到问题的时候，诶又换到windows下找解决方案，用句话就是说：喔控制不住喔自己。\n3.最后的进阶，就是你只装linux系统，如果你做出这样的选择，那你一定是想学好linux或者你很喜欢linux。因为在我们生活中多多少少会离不开windows系统，虽然大家都在吐嘲微软家的win10，但是还是照样嘴上说着手上却还继续用着，平时的话不做什么我也觉得用windows比较舒服，因为上面有很多我想玩的游戏，而且有一些就是自己常用的软件linux平台没有。不过软件很多都能够在linux找到代替的，而且随着linux的流行，越来越多公司开始支持linux，很多软件也开始在linux上出现。好了，废话不多说，还是简单说一下安装的过程。\n\n#### 1、下载ubuntu\n[官方的下载地址](http://www.ubuntu.com/download/desktop)\n[国内的镜像下载地址](http://mirrors.163.com/ubuntu-releases/)\n需要注意的是：下载时需要根据你的电脑情况选择下载32位的还是64位的。\n#### 2、做个U盘启动\n一般的话都是刻录到U盘，通过U盘启动进去安装。刻录软件一般是用UltraIOS\n#### 3、安装\n插入U盘，重新启动电脑，然后进入安装界面，一般是按F12或Delete，根据你电脑的型号会有所不同，然后我们选择U盘启动，这样就会看到进入到安装界面了。一步一步下去，我这里选择的是英文版，看你喜欢用哪个吧，没有成文的规定。出现联网的部分我们选择不连接，因为我曾遇到过在我安装ubutnu的时候，到设置地区的时候，突然就卡住了，选择不了地区，然后也点不了continue。困扰了我一段时间我还以为是镜像损坏了，后面我找到了原因：原来是因为联网了，然后网络不稳定而导致的。把网络禁止掉了之后，就安装成功了。当问我们安装的分区方式的时候，会出现四个选项，中文版的同学应该看得懂意思，这里我们选择**最后一个**，我们自己来分配大小。那这个怎么分配呢，如果知道每个划分的作用，我们就可以根据自己的机器来做不同的分配。那么就要了解一下linux下的文件结构。作为一名合格的linux用户，肯定是要知道linux的基本文件目录结构，这对于理解和使用linux都有很大的帮助。\n\n```text\n/ :根目录，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者。\n/root：存放root用户的相关文件。\n/home：存放普通用户的相关文件。\n/bin：bin 就是二进制（binary）英文缩写，用来存放常用命令的目录。\n/sbin：存放具有权限才使用的命令目录。大多是涉及系统管理的命令的存放，是超级权限用户root的可执行命令存放地，普通用户无权限执行这个目录下的命令，这个目录和/usr/sbin; /usr/X11R6/sbin或/usr/local/sbin目录是相似的，凡是目录sbin中包含的都是root权限才能执行的。\n/boot：存放系统引导的相关文件。Linux的内核及引导系统程序所需要的文件目录，比如 vmlinuz initrd.img 文件都位于这个目录中。在一般情况下，GRUB或LILO系统引导管理器也位于这个目录。\n/etc：etc这个目录是linux系统中最重要的目录之一。在存放配置相关的文件（etcetera），比如jdk，tomcat，mysql的环境配置。\n\n/usr:这是linux系统中占用硬盘空间最大的目录。类似于windows的program，默认安装程序的位置\n/usr/local：这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本（scripts)放到/usr/local目录下面、。\n/usr/share ：系统共用的东西存放地，比如 /usr/share/fonts 是字体目录，/usr/share/doc和/usr/share/man帮助文件。\n```\n\n/tmp：临时文件目录，用来存放不同程序执行时产生的临时文件。有时用户运行程序的时候，会产生临时文件。\n/var：存放经常变化的文件。可以理解为vary的缩写，/var下有/var/log 这是用来存放系统日志的目录。/var/ www目录是定义Apache服务器站点存放目录；/var/lib 用来存放一些库文件，比如MySQL的，以及MySQL数据库的的存放地。\n\n**一般来说知道这几个先就可以了，后面的随便看看**\n\n/dev：dev 是设备（device)的英文缩写。这个目录对所有的用户都十分重要。因为在这个目录中包含了所有linux系统中使用的外部设备。但是这里并不是放的外部设备的驱动程序。这一点和常用的windows,dos操作系统不一样。它实际上是一个访问这些外部设备的端口。可以非常方便地去访问这些外部设备，和访问一个文件，一个目录没有任何区别。\n/cdrom：这个目录在刚刚安装系统的时候是空的。可以将光驱文件系统挂在这个目录下。例如：mount /dev/cdrom /cdrom\n/mnt：这个目录一般是用于存放挂载储存设备的挂载目录的，比如有cdrom等目录。可以参看/etc/fstab的定义。\n/media：有些linux的发行版使用这个目录来挂载那些usb接口的移动硬盘（包括U盘）、CD/DVD驱动器等等。\n\n/lib：lib是库（library）英文缩写。这个目录是用来存放系统动态连接共享库的。几乎所有的应用程序都会用到这个目录下的共享库。因此，千万不要轻易对这个目录进行什么操作，一旦发生问题，系统就不能工作了。\n/lost+found：在ext2或ext3文件系统中，当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。有时系统发生问题，有很多的文件被移到这个目录中，可能会用手工的方式来修复，或移到文件到原来的位置上。\n/opt：这里主要存放那些可选的程序。\n/proc：可以在这个目录下获取系统信息。这些信息是在内存中，由系统自己产生的。\n/selinux ：对SElinux的一些配置文件目录，SElinux可以让linux更加安全。\n/srv 服务启动后，所需访问的数据目录，举个例子来说，www服务启动读取的网页数据就可以放在/srv/www中\n\n上面说了一堆，不会要分配那么多个文件目录吧，当然不是，其实简单来说，分配的方案：\nboot： 200M。\nswap：就是虚内存（Virtual Memory），当物理内存无法提供足的处理空间，其余的数据就会被写入到swap分区中，等物理内存有可理空间再从swap中将数据移入。不成文的规定是说一般是物理内存的两倍，这应该是通过类似于一个函数，达到最大值的时候继续就没有效益了。\n/： 10G/15g/20G\nhome：剩下的给它就行了。\n\n比如我的是分配方案就如下，因为我的是128G固态+500G硬盘，所以我的硬盘除了一部分用来保存了之前windows下的资源，剩下的就作为home了，还有一部分空余的固态留着备用以后可能会再装windows。其实上面也说了，windows在我们身边还是经常用到的，不过如果你学会了linux你将收获更多的知识，学习linux并不是炫耀自己而应该是充实自己的知识和能力。\n```\nsystem: ubuntu16.04LTS\nGNOME version:3.14.2\n/ :20G\nboot:200M\nSwap:8192M\n/home \n```\n#### 4、安装完毕\n好了，上面说了怎么分配方案，你知道了这是用来干什么的所以你选择了这样分配。后面的步骤按照引导很快就会进入安装了，剩下的就是等待了。\n**总结一下：需要注意一点，不要联网。还有一点就是了解分配的原理。最后就是安装完成重新启动。**\n\n我们接着说，当你重新启动的时候，可能会出现引导顺序的问题，这样可能就不会直接进入到ubuntu系统。这里我觉得再说BIOS和UEFI引导的话又得说很长，所以这里有问题的同学可以问度娘或者谷哥这俩兄妹。我们这里主要是讲linux而不是教重装系统。下面的话我就默认大家是用虚拟机装好了，双系统的也没问题了，裸linux的也OK了。\n<img src=\"/images/linux/myubuntu.png\" align=\"center\"/>\n当进入的时候，需要我们输入密码，这个密码就是你在安装的时候的密码。进去的时候，我们可以看到这个系统是怎么样的，有自己的界面，英文不好的同学可以选择装中文版或者自己查字典，那么这个时候装完了我们就到处先点点看看呗。ubuntu预装了大量常用软件，中文版的功能也较全，支持拼音输入法，预装了Firefox、Libre Office、多媒体播放、图像处理等大多数常用软件，一般会自动安装网卡、音效卡等设备的驱动。对于不打游戏不用网银的朋友来说，基本上能用的功能都有了。可以看到这个系统也是有文本编辑器，浏览器这些供我们平时追剧消遣什么的。那这个怎么联网呢，没有网的话对普通人来说什么也干不了，那么我们就先来联网干点事情呗。\n\n如果是使用ADSL拨号上网的，Ubuntu 里面已经自带了网络配置向导，在顶部菜单中单击连接图标，选择“Edit Connections”。在弹出的对话框中，点击“DSL”标签，再点击“Add”按钮。依次填写用户名，服务以及密码。连接建立后，在桌面顶部菜单中左键单击网络连接的图标，会列出所有的连接，其中在“有线网络”下就有刚才建立的ADSL连接，单击即可拨号上网。\n这样我们就可以通过Firefox浏览器来上网了，如果是选择英文的同学可能就遇到麻烦了，我这怎么安装中文输入法啊。眼睛厉害的同学可能已经发现了旁边有个ubuntu的应用市场，进去下载不就行了嘛。然而你会发现我怎么搜索不了什么搜狗输入法啊，谷歌输入法，百度输入法，讯飞输入法这些。有些同学就想了竟然这里下载不了那我还有个办法，我去官网下载不就得了，windows我下windows版，那这个linux我就下linux不就得了。可是下载了之后发现并不像在windows下直接双击666，不是双击运行就可以一步一步安装了，好吧，傻眼了。\n\n这个安装方式有很几种，感兴趣的同学我会在下一期介绍。好了，今天就到这里，感谢你阅读我的文章！\n\n\n\n","categories":["Linux"]},{"title":"linux从入门到放弃——01linux家族的过去","url":"/2017/08/06/linux从入门到放弃01/","content":"\n我又开了一个坑，这一次我打算做一系列有关于linux的栏目，不能说是教程，只是写下我学习ubuntu的一个过程和心得，大概的内容我想好了，我会把我怎么学ubuntu的过程一点点写下了，遇到了哪些问题，然后为什么要学linux，以及linux有什么用，我有点喜欢IT历史，所以文章的内容可能会讲一下历史。大家都用过微软家的windows操作系统吧，还有没用过也听过的苹果家的OS系统，那么问题来了，这个linux系统是什么？很多人可能没有听说过，所以也就不会想着去学习，毕竟windows用的挺好的人不会去折腾这些东西。恩，在这里说一下，如果你是想要成为一个程序员的话，就可以来看看这些教程，了解一下linux。如果你是想尝鲜用用其他系统也可以来看看，说不定看了几篇后你就决定放弃然后卸载了。然后我们先来说说linux是什么，不是说ubuntu吗？不，还是得先介绍一下linux历史，了解了linux有利于后面的学习。\n\n<img src=\"/images/linux/qi.jpeg\" width=\"300px\" align=\"center\"/>\n\nLinux是一套免费、开源的类Unix的做服务器的操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统，它的特点就是：稳定、安全、处理多并发。相比起windows的话会安全很多，可能有人会说了，我装个360或者电脑管家也很安全啊，这个正是因为linux的安全其实很少黑客会去入侵linux系统，反而因为windows没有那么安全，所以导致了被大量黑客入侵，这个为什么说安全后面再介绍。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。那这个unix又是什么，可能对历史有点了解的人都知道其实以前的计算机是非常巨大的，而最先开始的就是unix系统，不像我们现在身边的设备那么小，在那个时候很少有人能够用得起计算机，一般都是一些大型的公司或者研究所，像我们现在的普通人真的是想都不敢想。而在1973的时候出现了以后改变时间的好消息，就是unix源代码开源了。这时候就有很多公司觉得以后unix绝对是未来，所以都跑去研究了起来。像著名的伯克利分校搞了BSD，这个伯克利分校里面也是有很多牛逼的人物。IBM公司的AIX系统，sun公司的solaris系统，hp的hp unix。到后面出现了一个叫minix的操作系统，这些都是基于unix开源而来的。那么这linux到现在都没讲到，又是怎么来着呢？\n\n<img src=\"/images/linux/linus.jpeg\" width=\"300px\" align=\"center\"/>\n\n1991年的时候，在当时有个在芬兰读书的小伙子，叫做linus Torvalds（林纳斯·托瓦兹，瑞典籍芬兰人，瑞典发音有点类似[林new克思]，但是英语有点类似[利尼克思]）开始在一台386sx兼容微机上学习minix操作系统，这个人的故事也特别牛逼，他从小就开始接触计算机了，那时候他跟他外公学到了很多的东西当时他的外公是有名的教数学的教授。当时在1991年4月linus就开始动手想编制自己的操作系统。说牛人就是牛人，在1991 年4 月13 日的时候他就在comp.os.minix 上发布说自己已经成功地将bash移植到了minix 上，而且已经爱不释手、不能离开这个shell软件了，这个时候论坛上就炸了，他的学长学姐什么的还有很多人都觉得很好所以就开始动手加各种功能，其遵守的是GPL协议，linus就把他开源了。\n\n<img src=\"/images/linux/lin.png\" align=\"center\">\n\n然后1991年7月3日，第一个与Linux有关的消息是在comp.os.minix上发布的（但是那时候还不叫Llinux，当时linus的脑子里想的可能是FREAX（怪诞的、怪物、异想天开的意思）。说起来linux这个名字也由很多由来，说法不一，比较有名的几个说法是，大家觉得这东西实在太好了，所以就由你的名字来命名吧，但是这个牛人就比较低调说，说不行不行。其实也是情有可原，因为linux是由linus发起的，准确的来说其实linux不是由他一个人做出来的。那这个时候怎么办，就换一个。要不叫linux，大家一看觉得行，就这样定了。其中这个x有混合的意思。也有说是指：linux is not unix。就是说linux不是unix，它有自己的特点，在当时还有一些大佬特定写了《Unix痛恨者手册》就是用来专门批评unix的，我觉得如果有时间的话我想买一本来看看。\n\n然后1991年的10月5日，林纳斯·托瓦兹在comp.os.minix新闻组上发布消息，正式向外宣布Linux内核的诞生（Freeminix-like kernel sources for 386-AT）。1993年，大约有100余名程序员参与了Linux内核代码编写/修改工作，其中核心组由5人组成，此时Linux 0.99的代码大约有十万行，用户大约有10万左右。1994年3月，Linux1.0发布，代码量17万行，当时是按照完全自由免费的协议发布，随后正式采用GPL协议。然后有一些公司就觉得linux是未来的趋势，于是又纷纷来研究linux。可能有人就说了，我听过什么Ubuntu、openSUSE、Fedora、centOS、redhat、debian，怎么没有这个叫LINUX的，但是因为严格来讲，Linux这个词本身只表示Linux内核，就是其实人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU工程各种工具和数据库的操作系统。在1995年1月，Bob Young创办了RedHat公司（小红帽），对linux做了个桌面，以GNU/Linux为核心，搞出了一种冠以品牌的Linux，即RedHat Linux,称为Linux\"发行版\"，在市场上出售。这在经营模式上是一种创举。\n\nlinux主要作为linux发行版（称为“distro”）的一部分使用，从桌面系统上开看，主要是分为redhat和debian两大分支，姑且在这里把linux称为一颗树根（root），在1993年中，linux这根开始了两个分支：Debian和Slackware，在1994年Slackware又分支了SUSE，年底的时候在两个分支基础上出现了我们说的redhat（红帽），此后在1996年在红帽分支上出现了Conectiva，98年红帽上又出现了Mandrake。在1999年，红帽分支上有了我国的红旗linux。然后在2003-2005年这期间发生了巨大变化。14年下半年的时候，Debian上出现了ubuntu分支，而且发展的很强大。我们后面所看到的Xubuntu、Kubuntu这些都是基于ubuntu的。\n\n<img src=\"/images/linux/linux祖谱.gif\" width=\"400px\" align=\"center\"/>\n\n这里说一下ubuntu（译为吾帮托或乌班图），意思是”人性“、“我的存在是因为大家的存在”，是非洲传统的一种价值观，类似华人社会的“仁爱”思想。ubuntu基于Debian发行版和unity桌面环境，与Debian的不同在于它每6个月会发布一个新版本,ubuntu在次版本号中如果是偶数就说明是长期支持版本，做服务器当然是选择稳定的了。Ubuntu的目标在于为一般用户提供一个最新的、同时又相当稳定的主要由自由软件构建而成的操作系统。而且ubuntu社区资源非常丰富，可以方便从社区获得帮助。如果我们要想学习linux的话，其实选择Ubuntu就好了。很多人都在纠结我到底是在用哪个比较好，这个问题适合问知乎大神。其实哪一个都可以用来学习，如果想学习的话就选择一个然后一直学。有人折腾了很久结果就只是在linux各版本间不断的重装。我这里用的ubuntu，如果按照流行的说法是说比较适合新手，对新手比较友好，而且论坛，社区这些比较活跃，资源也很丰富，当你遇到一些问题的时候可能很快就能找到答案了。\n\n在今天来说，linux受到了越来越多的人喜欢。\n\n然后这些这么多的版本还是开源的，那么主要编写的人是哪些？在这里所有的发行版本其实都是基于linux写kernel，主要是有个人、松散组织的团队、以及商业机构和志愿者组织编写。一个Linux发行版包括：linux内核，一些GNU程序库和工具，命令行shell，图形界面的XWindow系统和相应的桌面环境，如KDE和GNOME，并包含数千种从办公套件，编译器，文本编辑器到科学工具的应用软件。Linux存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如我们的手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。操作系统其实可以简单的分为四个类：PC、智能设备、服务器、嵌入式系统。。而linux主要就是用来服务器开发的。linux的主要方向就分为两个，一个是linux系统管理员，这个需要非常熟悉linux操作系统。还有一个就是linux程序员，这个需要你会C/C++/Java/PHP这些的一种或者多种，或者做linux软件工程师（PC），linux嵌入式开发（单片机芯片）。\n\n恩，今天就到这里先吧，这一篇没讲到什么内容，就是说一下linux的历史，起码你知道了什么是linux，linux怎么来的，然后linux主要是用来做服务器的。下一篇的话我打算开始介绍linux的安装和使用。感谢你的喜欢和支持。我们下期再见！\n\n","categories":["Linux"]},{"title":"linux从入门到放弃——00与linux的爱恨情仇","url":"/2017/08/05/linux从入门到放弃00/","content":"\n貌似怠惰很久了，如果你看我现在的博客的话会发现我从4月开始就没有再更新过文章，知道今天这只懒猫终于想起来写博客。说起来之前写的不止这些，但是越到后面我发现内容写的太烂了，而且文章很零碎，所以我就把以前写的一些文章给删除了，打算推翻重新写，做了几个系列的栏目。\n\n上个学期的时候琐碎的东西挺多了，而且也在折腾Java，其实我并不怎么喜欢Java，正如人们形容的一样，Java所自带的库太多了，很多东西直接封装好了，你可以直接调用接口或者继承类就可以使用里面的方面，但是这有个不好的地方，就是什么东西你都用现成的话你就很难理解里面的原理。这说起来挺可笑的，因为在现在我们很多东西也是别人做好给我们的，我们也不知道里面的原理但是我们会用就行了。比如我们的手机，我们也不知道怎么做的，但是我们还是能够玩的66的。所以我就在想，未来的时候，是不是东西智能话之后，人人都可以学编程，比如直接调用一个库里（不是骑士里打篮球的那个库里）的函数就可以生成一个小软件，然后我们随便修改一下UI部分的一些显示信息，修改一下里面的数据那这个软件就是我们做成的了。我觉得这也是不错的，因为这样就更方便我们的生活嘛，让很多事情做起来简单我觉得就是好事，我们总是喜欢简单容易的事情。所以说这没什么谁比谁好，我觉得你去研究这些和不去研究这些都可以，毕竟在信息爆炸的时代，我们的时间不可能是把所有东西都弄明白。但是我还是希望如果有时间我能够去了解这些东西，虽然我不可能说自己做一个手机出来，但是知道这些我觉得我心里会开心一点。\n\n我虽然写Java比较多，但是我还是比较喜欢C和C++，这听起来是不是很可笑很矛盾。因为现在Java就是比较热门，而且做开发的话会比较方便，但是如果你折腾C和C++这些就是会比较难，比如指针这一点对于没有老司机带的同学肯定就是一个坎的。因为我们很多人接触编程也都是在大学的时候，应该是有一门课叫做“C程序设计”，用的书应该是红色那本谭浩强的书。这本书感觉是挺害人的，里面还有一些错误。然后很多书是这样，就是说完了语法就不告诉你接下来干什么，我那时就停留了很久都不知道学完了这个继续学什么，在网上找了一些答案也看不懂，就是当时知识太少人家说了我也不懂。然后接触了Java之后我知道了可以用来做web和android，我觉得自己喜欢就决定学习了，其实当你接触时间多的时候你也会慢慢知道学什么。当然有一些同学就是在高中或者初中的时候就已经知道编程了，甚至有些小学生都不玩游戏人家就学习编程。但是大部分人并不是这样，就像我小时候就没有电脑，我都是瞎玩度过的，我的第一台笔记本也是在高考毕业那一年买的。我就开始慢慢摸索，但是没有人带我我也傻乎乎的不知道玩什么，平时打开就是这点点那点点玩玩游戏，那时候还不是我一个人用，所以不能随便玩，要是我装一些软件来玩把系统搞卡卡的肯定是会被骂的。\n\n但是后面上了大学这台笔记本就属于我一个人了，我可以用来做任何我想做的事情，然后开始知道了C语言，那时候就觉得这是我喜欢的，就打算以后是从事这方面的工作，因为其他的工作我感觉我也干不来而且没有兴趣。那时候我还不知道python，C++，C#，java，php，ruby，lua等这些，我就照着书用C语言敲了好几遍。心里成就感还是蛮好的。但是一个学期下来，回头看的时候发现自己学的东西并不多，很多也没学明白，大一的时候就是瞎忙活。其实不管你从什么时候开始学编程，我觉得如果有兴趣都可以去学，随着慢慢的了解多了就知道了大体的一个方向，所以说我们并不是不可以学编程，不管有没有人带，我们最重要的就是靠自己，多思考，多敲代码，遇到不懂的就查，我觉得并不能因为我们条件不行或者没有人带为借口，然后剥夺我们对喜欢东西的追求。不否认确实是有天赋和条件差异的存在，但是我还是相信只要我们努力的话还是能够得到不错的收获。当然前提也是你有兴趣。\n\n后面接触编程方面的东西多了，慢慢的，开始知道了java，知道了linux（唉，终于给回到我们的主题了)。但是那时候我还不知道这用来干什么，不知道怎么玩，甚至刚开始连安装都不会，因为那时候我是想装双系统，结果就是把我的windows搞炸了嘛，不过还好安装之前备份了重要的文件，在这里我也说一下想玩linux的读者最好有个备份的准备，其实不管什么时候我们都要有个备份的好习惯。就像我有个朋友叫我传一个东西给他，但是过了一段时间后他所玩蹦了想重新安装问我要安装包，我就很郁闷他自己竟然没有备份。但是没有办法，因为是朋友还是给他，就是说一下备份——备份——备份，重要的事情说三遍。因为windows炸了嘛，所以我就心态蹦了，但是我并没有放弃。\n\n虽然标题我们写着linux从入门到放弃，但是我都没安装，都不算入门怎么就能放弃了，起码让我安装一下看一下吧。那时候我还不会分配大小和挂载这些，所以就索性安装的时候选择自己分配，然后windows我也不要了，但是进去之后我就后悔了，这用的一点都不习惯，索性还能上网，那几天我就对着教程学了一些基本的命令，但是发生日常用的一些软件还是在windows，这个时候我又重新装了系统。不过这时候我还没有放弃，知道了在windows下有个叫做虚拟机的东西，这个东西很傻瓜式，很快我就安装好了ubutnu系统，这个ubuntu就是基于linux内核的。\n\n这个具体的我们下一期再讲。我继续唠叨一下我与linux的爱恨情仇。恩，这个时候，windows也能用，然后也能学linux，但是我发现这样的话平时我是不怎么想学linux，因为每次开机我都懒得开虚拟机直接就开始看东西打游戏这些。时间间隔了一段，算是入门了，但是就只是入门了，就是只会虚拟机下安装。后面我又想折腾，于是装了双系统，这样如果我进入linux系统的话我就不会想着直接打开游戏了。但是我发现因为有windows的存在我每次就手贱选择进入的是windows系统，然后打开游戏。这个时候我想，其实我对linux没多少兴趣，索性就这样过了一段时间。再后来，我觉得我需要用到linux，对网站和服务器这些产生了兴趣，我买了本《鸟哥的私房菜》，当我看了几章后，我开始了一个决定。这个时候因为需要我对linux才算是产生了兴趣，开始打算认真学。于是我最后只裸了ubuntu系统。现在我还是蛮喜欢linux，虽然在有时候ubuntu出现的问题让我困扰不已，但是我在linux下也接触和学到了更多东西，所以说我和linux真的算上去爱恨情仇。那最后总结一下，我与linux大概分为几个过程：安装失败，windows爆炸——裸ubuntu系统——虚拟机下的ubuntu——ubuntu+windows双系统——裸ubuntu系统。所以最后的爱恨情仇又回到了原点。\n\n不管怎么样，最后到现在我都还没有放弃，所以希望大家也不要轻易放弃，我们先看看，要是觉得不合适再放弃也不迟。好了，这一期就到这里，下一期让我们来先入个门吧。\n\n\n\n","categories":["Linux"]}]