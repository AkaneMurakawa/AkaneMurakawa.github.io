[{"title":"从零开始设计模式第5章-其他模式(1种)","url":"/2020/03/21/从零开始设计模式第5章/","content":"## 1.其他模式(1种)\n* 空对象模式(Null Object Pattern)\n\n\n### 1.1 空对象模式(Null Object Pattern)\n介绍：一个空对象取代 NULL 对象实例的检查。提供默认值，默认不做任何事情。\n使用场景：\n1. 有多个子类共有的方法，且逻辑相同。 \n2. 重要的、复杂的方法，可以考虑作为模板方法。\n\n#### 1.1.1示例\n```C#\n/**\n * 命令\n */\npublic interface Command {\n\n    /**\n     * 执行\n     */\n    void execute();\n\n    /**\n     * 撤销\n     */\n    void undo();\n}\n\npublic class LightOffCommand implements Command {\n\n    @Override\n    public void execute() {\n        System.out.println(\"light off\");\n    }\n\n    @Override\n    public void undo() {\n        System.out.println(\"light on\");\n    }\n}\n\npublic class LightOnCommand implements Command {\n\n    @Override\n    public void execute() {\n        System.out.println(\"light on\");\n    }\n\n    @Override\n    public void undo() {\n        System.out.println(\"light off\");\n    }\n}\n\n/**\n * 没有任何命令，空执行，用于初始化。\n * 可以省略对空的判断\n */\npublic class NullObjectCommand implements Command {\n\n    @Override\n    public void execute() {\n    }\n\n    @Override\n    public void undo() {\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n\n        Command[] commands = new Command[2];\n        for (int i = 0; i < commands.length; i++) {\n            // 默认值，减少了空的判断\n            commands[i] = new NullObjectCommand();\n        }\n\n    }\n}\n\n```\n![nullobject](/images/common/nullobject.png)\n解读：NullObjectCommand没有任何命令，空执行，用于初始化，可以省略对空的判断。\n\n\n","categories":["从零开始","从零开始设计模式"]},{"title":"从零开始设计模式第4章-行为型模式(十一种)","url":"/2020/03/15/从零开始设计模式第4章/","content":"## 1.行为型模式(11种)\n* 模板模式(Template Pattern)\n* 命令模式(Command Pattern)\n* 访问者模式(Visitor Pattern)\n* 迭代器模式(Iterator Pattern) \n* 观察者模式(Observer Pattern)\n* 中介者模式(Mediator Pattern)\n* 备忘录模式(Memento Pattern)\n* 解释器模式(Interpreter Pattern)\n* 状态模式(State Pattern)\n* 策略模式(Strategy Pattern)\n* 职责链模式(Chain of Responsibility Pattern)\n\n### 1.1 模板模式(Template Method Pattern)\n介绍：也叫模板方法模式。定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。一般模板方法都加上final关键字，防止子类重写模板方法。\n使用场景：\n1. 有多个子类共有的方法，且逻辑相同。 \n2. 重要的、复杂的方法，可以考虑作为模板方法。\n\n**模板模式的钩子方法**\n在抽象类中，可以定义一个方法，它默认不做任何事情，子类可以视情况覆盖它，该方法称为\"钩子\"。\n\n#### 1.1.1示例\n```C#\npublic abstract class AbstractHandler<T> {\n\n    /**\n     * 模板方法\n     */\n    public final String process(T type, String message){\n        if (match(type)){\n            process(message);\n            return \"Y\";\n        }else if (match()){\n            process(message);\n            return \"Y\";\n        }else {\n            System.out.println(\"unknow type\");\n\n        }\n        return \"N\";\n    }\n\n    protected abstract String process(String message);\n\n    protected abstract boolean match(T type);\n\n    /**\n     * 钩子方法\n     * @return\n     */\n    public boolean match(){\n        return false;\n    }\n}\n\npublic enum MessageTypeEnum {\n\n    ORDER(\"order\", \"订单\"),\n\n    WAREHOUSE(\"warehouse\", \"仓库\");\n\n    private String type;\n\n    private String desc;\n\n    MessageTypeEnum(){}\n\n    MessageTypeEnum(String type, String desc) {\n        this.type = type;\n        this.desc = desc;\n    }\n}\n\npublic class OrderHandler extends AbstractHandler<MessageTypeEnum> {\n\n    @Override\n    protected String process(String message) {\n        System.out.println(message);\n        return \"Y\";\n    }\n\n    @Override\n    protected boolean match(MessageTypeEnum type) {\n        return MessageTypeEnum.ORDER == type;\n    }\n}\n\npublic class WareHouseHandler extends AbstractHandler<MessageTypeEnum> {\n\n    @Override\n    protected String process(String message) {\n        System.out.println(message);\n        return \"Y\";\n    }\n\n    @Override\n    protected boolean match(MessageTypeEnum type) {\n        return MessageTypeEnum.WAREHOUSE == type;\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        AbstractHandler<MessageTypeEnum> order = new OrderHandler();\n        order.process(MessageTypeEnum.ORDER, \"order\");\n\n        AbstractHandler<MessageTypeEnum> warehousse = new WareHouseHandler();\n        warehousse.process(MessageTypeEnum.WAREHOUSE, \"warehousse\");\n    }\n}\n```\n![template](/images/common/template.png)\n解读： \n#### 1.1.2 模板模式使用\nSpring IOC容器初始化\n\n### 1.2 命令模式(Command Pattern)\n介绍：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。\n使用场景：\n1. GUI 中每一个按钮都是一条命令。 \n2. 模拟 CMD。\n3. 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。\n#### 1.2.1示例\n```C#\n/**\n * 接收者\n */\npublic class LightReceiver {\n\n    public void on(){\n        System.out.println(\"light on\");\n    }\n\n    public void off(){\n        System.out.println(\"light off\");\n    }\n}\n\n/**\n * 命令\n */\npublic interface Command {\n\n    /**\n     * 执行\n     */\n    void execute();\n\n    /**\n     * 撤销\n     */\n    void undo();\n}\n\npublic class LightOffCommand implements Command{\n\n    private LightReceiver receiver;\n\n    public LightOffCommand(LightReceiver receiver){\n        this.receiver = receiver;\n    }\n\n    @Override\n    public void execute() {\n        receiver.off();\n    }\n\n    @Override\n    public void undo() {\n        receiver.on();\n    }\n}\n\npublic class LightOnCommand implements Command{\n\n    private LightReceiver receiver;\n\n    public LightOnCommand(LightReceiver receiver){\n        this.receiver = receiver;\n    }\n\n    @Override\n    public void execute() {\n        receiver.on();\n    }\n\n    @Override\n    public void undo() {\n        receiver.off();\n    }\n}\n\n/**\n * 没有任何命令，空执行，用于初始化。\n * 可以省略对空的判断\n */\npublic class NoCommand implements Command{\n\n    @Override\n    public void execute() {\n    }\n\n    @Override\n    public void undo() {\n    }\n}\n\n/**\n * 调用者\n */\npublic class Invoker {\n\n    private Command[] onCommands;\n    private Command[] offCommands;\n\n    // 撤销命令\n    private Command undoCommand;\n\n    private static final int SIZE = 5;\n\n    public Invoker() {\n        onCommands = new Command[SIZE];\n        offCommands = new Command[SIZE];\n        for (int i = 0; i < SIZE; i++) {\n            onCommands[i] = new NoCommand();\n            offCommands[i] = new NoCommand();\n        }\n    }\n\n    public void setCommand(int index, Command onCommand, Command offCommand){\n        onCommands[index] = onCommand;\n        offCommands[index] = offCommand;\n    }\n\n    public void on(int index){\n        onCommands[index].execute();\n        // 记录上次命令\n        undoCommand = onCommands[index];\n    }\n\n    public void off(int index){\n        offCommands[index].execute();\n        // 记录上次命令\n        undoCommand = offCommands[index];\n    }\n\n    // revert\n    public void undo(){\n        undoCommand.undo();\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n\n        LightReceiver receiver = new LightReceiver();\n        Command lightOnCommand = new LightOnCommand(receiver);\n        Command lightOffCommand = new LightOffCommand(receiver);\n\n        Invoker invoker = new Invoker();\n        invoker.setCommand(0, lightOnCommand, lightOffCommand);\n        invoker.on(0);\n        invoker.off(0);\n        invoker.undo();\n    }\n}\n```\n![command](/images/common/command.png)\n解读：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令\n#### 1.2.2 命令模式使用\nJdbc Template\n\n### 1.3 访问者模式(Visitor Pattern)\n介绍：将数据结构与数据操作分离。\n使用场景：\n1. 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 \n2. 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，也不希望在增加新操作时修改这些类。\n#### 1.3.1示例\n```C#\n/**\n * 访问者\n */\npublic abstract class Action {\n\n    public abstract void getResultMan(Person person);\n\n    public abstract void getResultWomen(Person person);\n}\n\npublic class Success extends Action{\n    @Override\n    public void getResultMan(Person person) {\n        System.out.println(person.getName() + \"success\");\n    }\n\n    @Override\n    public void getResultWomen(Person person) {\n        System.out.println(person.getName() + \"success\");\n    }\n}\n\npublic class Fail extends Action{\n    @Override\n    public void getResultMan(Person person) {\n        System.out.println(person.getName() + \"fail\");\n    }\n\n    @Override\n    public void getResultWomen(Person person) {\n        System.out.println(person.getName() + \"fail\");\n    }\n}\n\npublic abstract class Person {\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Person(String name) {\n        this.name = name;\n    }\n\n    public abstract void accept(Action action);\n}\n\npublic class Man extends Person {\n\n    public Man(String name) {\n        super(name);\n    }\n\n    /**\n     * 双分派\n     * Man在Action中作为参数传递(第一次分派)\n     * Man在方法中调用Action，同时将自己(this)作为参数传入(第二次分派)\n     */\n    @Override\n    public void accept(Action action) {\n        action.getResultMan(this);\n    }\n}\n\npublic class Women extends Person {\n\n    public Women(String name) {\n        super(name);\n    }\n\n    @Override\n    public void accept(Action action) {\n        action.getResultWomen(this);\n    }\n}\n\npublic class ObjectStructure {\n\n    private List<Person> people = new LinkedList<>();\n\n    public void attach(Person person){\n        people.add(person);\n    }\n\n    public void detach(Person person){\n        people.remove(person);\n    }\n\n    public void disPlay(Action action){\n        people.forEach( person -> {\n            person.accept(action);\n        });\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        ObjectStructure client = new ObjectStructure();\n        client.attach(new Man(\"Ming\"));\n        client.attach(new Women(\"Hong\"));\n\n        Success success = new Success();\n        client.disPlay(success);\n\n        Fail fail = new Fail();\n        client.disPlay(fail);\n    }\n}\n```\n![visitor](/images/common/visitor.png)\n解读：在被访问的类Person里面加一个对外提供接待访问者的接口accept()。\n#### 1.3.2 访问者模式使用\n\n\n### 1.4 迭代器模式(Iterator Pattern)\n介绍：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。\n使用场景：\n 1. 访问一个聚合对象的内容而无须暴露它的内部表示。 \n 2. 需要为聚合对象提供多种遍历方式。\n 3. 为遍历不同的聚合结构提供一个统一的接口。\n #### 1.4.1示例\n```C#\n/**\n * 专业\n */\npublic class Department {\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Department(String name) {\n        this.name = name;\n    }\n}\n\n/**\n * 学院\n */\npublic interface College {\n\n    String getName();\n\n    void addDepartment(String name);\n\n    Iterator iterator();\n}\n\npublic class ComputerCollege implements College {\n\n    Department[] departments = new Department[5];\n    // 当前数组的对象个数\n    int num = 0;\n\n    @Override\n    public String getName() {\n        return \"计算机学院\";\n    }\n\n    // 初始化数据\n    public ComputerCollege() {\n        addDepartment(\"Java\");\n        addDepartment(\"Spring\");\n        addDepartment(\"数据结构\");\n    }\n\n    @Override\n    public void addDepartment(String name) {\n        Department department = new Department(name);\n        departments[num] = department;\n        num += 1;\n    }\n\n    @Override\n    public Iterator iterator() {\n        return new ComputerCollegeIterator(departments);\n    }\n}\n\npublic class InfoCollege implements College {\n\n    List<Department> departments = new ArrayList<>();\n\n    @Override\n    public String getName() {\n        return \"信息工程学院\";\n    }\n\n    public InfoCollege() {\n        addDepartment(\"信息安全\");\n        addDepartment(\"网络安全\");\n        addDepartment(\"服务器安全\");\n    }\n\n    @Override\n    public void addDepartment(String name) {\n        Department department = new Department(name);\n        departments.add(department);\n    }\n\n    @Override\n    public Iterator iterator() {\n        return new InfoCollegeIterator(departments);\n    }\n}\n\npublic class ComputerCollegeIterator implements Iterator{\n\n    // 需要知道存放的形式 Arrays[]\n    Department[] departments;\n    // 遍历的位置\n    int position = 0;\n\n    public ComputerCollegeIterator(Department[] departments) {\n        this.departments = departments;\n    }\n\n    @Override\n    public boolean hasNext() {\n        if (position >= departments.length || departments[position] == null){\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public Object next() {\n        Department department = departments[position];\n        position += 1;\n        return department;\n    }\n\n    @Override\n    public void remove() {\n\n    }\n}\n\npublic class InfoCollegeIterator implements Iterator{\n\n    // 需要知道存放的形式 List\n    List<Department> departments;\n    // 遍历的位置\n    int position = -1;\n\n    public InfoCollegeIterator(List<Department> departments) {\n        this.departments = departments;\n    }\n\n    @Override\n    public boolean hasNext() {\n        if (position >= departments.size() - 1){\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public Object next() {\n        position += 1;\n        return  departments.get(position);\n    }\n\n    @Override\n    public void remove() {\n\n    }\n}\n\npublic class OutPut {\n\n    // 学院\n    List<College> collegeList;\n\n    public OutPut(List<College> collegeList) {\n        this.collegeList = collegeList;\n    }\n\n    public void printCollege(){\n        Iterator<College> iterator = collegeList.iterator();\n        while (iterator.hasNext()){\n            College next = iterator.next();\n            System.out.println(next.getName());\n            printDepartment(next.iterator());\n        }\n    }\n\n    /**\n     * 通过迭代器进行输出\n     * @param iterator\n     */\n    public void printDepartment(Iterator iterator){\n        while (iterator.hasNext()){\n            Department next = (Department)iterator.next();\n            System.out.println(next.getName());\n        }\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        List<College> colleges = new ArrayList<>();\n        ComputerCollege computerCollege = new ComputerCollege();\n        InfoCollege infoCollege = new InfoCollege();\n        colleges.add(computerCollege);\n        colleges.add(infoCollege);\n\n        OutPut outPut = new OutPut(colleges);\n        outPut.printCollege();\n    }\n}\n```\n![iterator](/images/common/iterator.png)\n解读：InfoCollegeIterator和ComputerCollegeIterator通过实现Iterator，来完成用统一的迭代器进行输出打印。\n\nCollege和University通过聚合的方式组合起来，可以很方便的增加和删除，而叶子节点是最小的节点，不需要增加和删除。需要注意的是这里的College和University继承了同一个抽象类，需具有相同的部分。\n#### 1.4.2 迭代器模式使用\nJDK的ArrayList\n\n### 1.5 观察者模式(Observer Pattern)\n介绍：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n使用场景：\n1. 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。\n2. 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。\n3. 一个对象必须通知其他对象，而并不知道这些对象是谁。\n4. 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。\n#### 1.5.1示例\n```C#\n/**\n * 观察者\n */\npublic interface Observer {\n\n    void update(Wether wether);\n}\n\npublic class SinaObserver implements Observer {\n\n    private Wether wether;\n\n    @Override\n    public void update(Wether wether) {\n        this.wether = wether;\n        display();\n    }\n\n    public void display(){\n        System.out.println(wether.toString());\n    }\n}\n\npublic class Wether {\n\n    private float temperature;\n\n    private float pressure;\n\n    private float humidity;\n\n    public Wether(float temperature, float pressure, float humidity) {\n        this.temperature = temperature;\n        this.pressure = pressure;\n        this.humidity = humidity;\n    }\n\n    @Override\n    public String toString() {\n        return \"Wether{\" +\n                \"temperature=\" + temperature +\n                \", pressure=\" + pressure +\n                \", humidity=\" + humidity +\n                '}';\n    }\n}\n\npublic interface Subject {\n\n    /**\n     * 订阅\n     */\n    void registerObservers(Observer observer);\n\n    /**\n     * 取消\n     */\n    void removeObservers(Observer observer);\n\n    /**\n     * 通知\n     */\n    void notifyObservers();\n}\n\npublic class WetherData implements Subject{\n\n    private Wether wether;\n\n    private List<Observer> observers = new ArrayList<>();\n\n    public WetherData(Wether wether) {\n        this.wether = wether;\n    }\n\n    /**\n     * 更新时通知\n     * @param wether\n     */\n    public void update(Wether wether){\n        this.wether = wether;\n        notifyObservers();\n    }\n\n    @Override\n    public void registerObservers(Observer observer) {\n        observers.add(observer);\n    }\n\n    @Override\n    public void removeObservers(Observer observer) {\n        if (observers.contains(observer)){\n            observers.remove(observer);\n        }\n    }\n\n    @Override\n    public void notifyObservers() {\n        observers.forEach(observer -> {\n            observer.update(wether);\n        });\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        WetherData wetherData = new WetherData(new Wether(3.2F, 4.4F, 5.6F));\n\n        // 观察者\n        SinaObserver sinaObserver = new SinaObserver();\n        wetherData.registerObservers(sinaObserver);\n\n        // 推送\n        wetherData.notifyObservers();\n        // 更新\n        wetherData.update(new Wether(3F, 4F, 5F));\n    }\n}\n```\n![observer](/images/common/observer.png)\n解读：Observe作为观察者，WetherData用集合管理观察者，可以进行订阅、取消、通知。\n\n#### 1.5.2 观察者模式使用\nJDK中的Observable\n\n### 1.6 中介者模式(Mediator Pattern)\n介绍：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n使用场景：\n1. 系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。\n2. 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。\n#### 1.6.1示例\n```C#\n/**\n * 中介者\n */\npublic abstract class Mediator {\n\n    // 将中介者对象，加入到集合中\n    public abstract void Register(User user);\n\n\n    public abstract void getMessage(User user, String message);\n\n    public abstract void sendMessage();\n}\n\npublic class ConcreateMediator extends Mediator {\n\n    // 用户集合\n    private HashMap<String, User> userMap = new HashMap<>();\n    // 消息集合\n    private HashMap<String, String> messageMap = new HashMap<>();\n\n    @Override\n    public void Register(User user) {\n        userMap.put(user.getName(), user);\n    }\n\n    @Override\n    public void getMessage(User user, String message) {\n        messageMap.put(user.getName(), message);\n        System.out.println(LocalDate.now().format(DateTimeFormatter.ISO_DATE) + \": \" + message);\n    }\n\n    @Override\n    public void sendMessage() {\n        messageMap.forEach((k, v) -> {System.out.println(v);});\n    }\n}\n\n\npublic abstract class User {\n\n    private Mediator mediator;\n    private String name;\n\n    public User(Mediator mediator, String name) {\n        this.mediator = mediator;\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public Mediator getMediator() {\n        return mediator;\n    }\n\n    public abstract void sendMessage(String message);\n}\n\npublic class XiaoHong extends User {\n\n    public XiaoHong(Mediator mediator, String name) {\n        super(mediator, name);\n        mediator.Register(this);\n    }\n\n    @Override\n    public void sendMessage(String message) {\n        this.getMediator().getMessage(this, message);\n    }\n}\n\npublic class XiaoMing extends User {\n\n    public XiaoMing(Mediator mediator, String name) {\n        super(mediator, name);\n        mediator.Register(this);\n    }\n\n    @Override\n    public void sendMessage(String message) {\n        this.getMediator().getMessage(this, message);\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        Mediator mediator = new ConcreateMediator();\n\n        User xiaoming = new XiaoMing(mediator, \"xiaoming\");\n        User xiaohong = new XiaoHong(mediator, \"xiaohong\");\n\n        xiaoming.sendMessage(\"Hi, I am xiaoming!\");\n        xiaohong.sendMessage(\"Hi, I am xiaohong!\");\n    }\n}\n\n```\n![mediator](/images/common/mediator.png)\n解读：Mediator作为中介者负责消息的接收和转发\n\n#### 1.6.2 中介者模式使用\n\n\n### 1.7 备忘录模式(Memento Pattern)\n介绍：在不破坏封装性的前提下，捕获一个对象的内部状态，**并在该对象之外保存这个状态。**\n使用场景：\n1. 需要保存/恢复数据的相关状态场景。\n2. 提供一个可回滚的操作。\n3. 为了节约内存，可使用原型模式+备忘录模式。\n\n#### 1.7.1示例\n```C#\n/**\n * 需要保存状态的对象\n */\npublic class Originator {\n    // 状态信息\n    private String state;\n\n    // 保存一个状态对象\n    public Memento saveStateMemento(){\n        return new Memento(state);\n    }\n\n    // 通过备忘录对象，恢复状态\n    public void getStateFromMemento(Memento memento){\n        state = memento.getState();\n    }\n\n    public String getState() {\n        return state;\n    }\n\n    public void setState(String state) {\n        this.state = state;\n    }\n}\n\n\n/**\n * 备忘录对象，负责保存状态\n */\npublic class Memento {\n\n    private String state;\n\n    public String getState() {\n        return state;\n    }\n\n    public Memento(String state) {\n        this.state = state;\n    }\n}\n\n/**\n * 守护者对象，负责保存多个备忘录对象\n */\npublic class Caretaker {\n\n    private List<Memento> mementoList = new ArrayList<>();\n\n    public void add (Memento memento){\n        mementoList.add(memento);\n    }\n\n    public Memento get(int index){\n        return mementoList.get(index);\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        Originator originator = new Originator();\n        Caretaker caretaker = new Caretaker();\n\n        originator.setState(\"状态#1 攻击力 100\");\n        caretaker.add(originator.saveStateMemento());\n\n        originator.setState(\"状态#2 攻击力 80\");\n        caretaker.add(originator.saveStateMemento());\n\n        originator.setState(\"状态#3 攻击力 50\");\n        caretaker.add(originator.saveStateMemento());\n\n        System.out.println(\"当前状态：\" + originator.getState());\n        originator.getStateFromMemento(caretaker.get(0));\n        System.out.println(\"恢复状态：\" + originator.getState());\n    }\n}\n\n\n```\n![memento](/images/common/memento.png)\n解读：\n\n#### 1.7.2 备忘录模式使用\n\n### 1.8 解释器模式(Interpreter Pattern)\n介绍：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。\n使用场景：\n1. 以将一个需要解释执行的语言中的句子表示为一个抽象语法树。\n2. 一些重复出现的问题可以用一种简单的语言来进行表达。 \n3. 一个简单语法需要解释的场景。\n4. 可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。\n\n#### 1.8.1示例\n```C#\n/**\n * 抽象表达式\n */\npublic interface Expression {\n\n    int getValue();\n}\n\npublic abstract class OperatorExpression implements Expression{\n\n    // 左值\n    protected Expression left;\n    // 右值\n    protected Expression right;\n\n    public OperatorExpression(Expression left, Expression right) {\n        this.left = left;\n        this.right = right;\n    }\n\n    public abstract int getValue();\n}\n\npublic class SubExpression extends OperatorExpression {\n\n    public SubExpression(Expression left, Expression right) {\n        super(left, right);\n    }\n\n    @Override\n    public int getValue() {\n        return left.getValue() - right.getValue();\n    }\n}\n\npublic class AddExpression extends OperatorExpression {\n\n    public AddExpression(Expression left, Expression right) {\n        super(left, right);\n    }\n\n    @Override\n    public int getValue() {\n        return left.getValue() + right.getValue();\n    }\n}\n\npublic class VarExpression implements Expression {\n\n    private String value;\n\n    public VarExpression(String value) {\n        this.value = value;\n    }\n\n    @Override\n    public int getValue() {\n        return Integer.valueOf(this.value);\n    }\n}\n\n/**\n * 常量\n */\npublic interface OperatorConstant {\n\n    char ADD = '+';\n\n    char SUB = '-';\n}\n\npublic class ExpressionParser {\n\n    private Expression expression;\n\n    public Expression parseExpression(String expStr){\n        Stack<Expression> stack = new Stack<>();\n        // 拆分表达式\n        char[] charArray = expStr.toCharArray();\n\n        Expression left = null;\n        Expression right = null;\n\n        // 1+3-2\n        for (int i = 0; i < charArray.length; i++){\n            switch (charArray[i]){\n                case OperatorConstant.ADD :\n                    // 先取出左边\n                    left = stack.pop();\n                    // 取出右边\n                    right = new VarExpression(String.valueOf(charArray[++i]));\n                    // 运算后push\n                    stack.push(new AddExpression(left, right));\n                    break;\n                case OperatorConstant.SUB :\n                    left = stack.pop();\n                    right = new VarExpression(String.valueOf(charArray[++i]));\n                    stack.push(new SubExpression(left, right));\n                    break;\n                default :\n                    // 如果是变量，就创建VarExpression对象，并push\n                    stack.push(new VarExpression(String.valueOf(charArray[i])));\n                    break;\n            }\n        }\n        // 当遍历完整个charArray后，stack最后得到的Expression\n        this.expression = stack.pop();\n        return expression;\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) throws IOException {\n        String context = getExpStr();\n        ExpressionParser expressionParser = new ExpressionParser();\n        Expression result = expressionParser.parseExpression(context);\n        println(result.getValue());\n\n    }\n\n    public static String getExpStr() throws IOException{\n        System.out.println(\"interpreter version 0.0.1\");\n        System.out.print(\">>\");\n        InputStreamReader inputStreamReader = new InputStreamReader(System.in);\n        return new BufferedReader(inputStreamReader).readLine();\n    }\n\n    public static void println(int result){\n        System.out.print(\">>\");\n        System.out.println(result);\n    }\n}\n```\n![interpreter](/images/common/interpreter.png)\n解读：Expression为抽象的表达式，其子类根据不同字符进行不同解释。ExpressionParser作为表达式解释器的入口工具，最终返回一个表达式。\n\n#### 1.8.2 解释器模式使用\nSpring中的SpelExpressionParser\n\n\n### 1.9 状态模式(State Pattern)\n介绍：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。\n使用场景：\n1. 行为随状态改变而改变的场景。\n2. 条件、分支语句的代替者。\n\n#### 1.9.1示例\n```C#\npublic enum ThreadStatusEnum {\n\n    START(\"新建状态\", 0),\n    RUNNABLE(\"就绪状态\", 1),\n    RUNNING(\"运行状态\", 2),\n    BLOCKED(\"阻塞状态\", 3),\n    DEAD(\"死亡状态\", 4);\n\n    private String name;\n    private int status;\n\n    public String getName() {\n        return name;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    ThreadStatusEnum(String name, int status) {\n        this.name = name;\n        this.status = status;\n    }\n}\n\npublic interface ThreadState {\n\n    void start(ThreadContext context);\n    void getCPU(ThreadContext context);\n    void suspend(ThreadContext context);\n    void resume(ThreadContext context);\n    void stop(ThreadContext context);\n}\n\npublic abstract class AbstractThreadState implements ThreadState{\n\n    protected int threadStatus = 0;\n\n    public int getThreadStatus() {\n        return threadStatus;\n    }\n\n    private static final RuntimeException EXCEPTION = new RuntimeException(\"cannot do it\");\n\n    /**\n     * 抽象类默认实现\n     */\n\n    @Override\n    public void start(ThreadContext context) { throw EXCEPTION; }\n\n    @Override\n    public void getCPU(ThreadContext context) { throw EXCEPTION; }\n\n    @Override\n    public void suspend(ThreadContext context) { throw EXCEPTION; }\n\n    @Override\n    public void resume(ThreadContext context) { throw EXCEPTION; }\n\n    @Override\n    public void stop(ThreadContext context) { throw EXCEPTION; }\n}\n\npublic class NewState extends AbstractThreadState{\n\n    public NewState() {\n        this.threadStatus = ThreadStatusEnum.START.getStatus();\n        System.out.println(\"当前线程处于：\" + ThreadStatusEnum.START.getName());\n    }\n\n    /**\n     * 开始\n     */\n    @Override\n    public void start(ThreadContext context) {\n        if (ThreadStatusEnum.START.getStatus() == context.getThreadStatus()){\n            System.out.println(\"start() ->\" + ThreadStatusEnum.RUNNABLE.getName());\n            context.setState(new RunnableState());\n        }else {\n            System.out.println(\"cannot start\");\n        }\n    }\n}\n\npublic class RunnableState extends AbstractThreadState{\n\n    public RunnableState() {\n        this.threadStatus = ThreadStatusEnum.RUNNABLE.getStatus();\n        System.out.println(\"当前线程处于：\" + ThreadStatusEnum.RUNNABLE.getName());\n    }\n\n    /**\n     * 获取CPU分配\n     */\n    public void getCPU(ThreadContext context) {\n        if (ThreadStatusEnum.RUNNABLE.getStatus() == context.getThreadStatus()){\n            System.out.println(\"getCPU() ->\" + ThreadStatusEnum.RUNNING.getName());\n            context.setState(new RunningState());\n        }else {\n            System.out.println(\"cannot getCPU\");\n        }\n    }\n\n}\n\npublic class RunningState extends AbstractThreadState{\n\n    public RunningState() {\n        this.threadStatus = ThreadStatusEnum.RUNNING.getStatus();\n        System.out.println(\"当前线程处于：\" + ThreadStatusEnum.RUNNING.getName());\n    }\n\n    /**\n     * 暂停\n     */\n    public void suspend(ThreadContext context) {\n        if (ThreadStatusEnum.RUNNING.getStatus() == context.getThreadStatus()){\n            System.out.println(\"suspend() ->\" + ThreadStatusEnum.BLOCKED.getName());\n            context.setState(new BlockedState());\n        }else {\n            System.out.println(\"cannot suspend\");\n        }\n    }\n\n    /**\n     * 停止\n     */\n    public void stop(ThreadContext context) {\n        if (ThreadStatusEnum.RUNNING.getStatus() == context.getThreadStatus()){\n            System.out.println(\"stop() ->\" + ThreadStatusEnum.DEAD.getName());\n            context.setState(new DeadState());\n        }else {\n            System.out.println(\"cannot stop\");\n        }\n    }\n}\n\npublic class BlockedState extends AbstractThreadState{\n\n    public BlockedState() {\n        this.threadStatus = ThreadStatusEnum.BLOCKED.getStatus();\n        System.out.println(\"当前线程处于：\" + ThreadStatusEnum.BLOCKED.getName());\n    }\n\n    /**\n     * 恢复\n     */\n    public void resume(ThreadContext context) {\n        if (ThreadStatusEnum.BLOCKED.getStatus() == context.getThreadStatus()){\n            System.out.println(\"resume() ->\" + ThreadStatusEnum.BLOCKED.getName());\n            context.setState(new RunningState());\n        }else {\n            System.out.println(\"cannot resume\");\n        }\n    }\n}\n\npublic class DeadState extends AbstractThreadState{\n\n    public DeadState() {\n        this.threadStatus = ThreadStatusEnum.DEAD.getStatus();\n        System.out.println(\"当前线程处于：\" + ThreadStatusEnum.DEAD.getName());\n    }\n}\n\n/**\n * 上下文 环境类\n */\npublic class ThreadContext{\n\n    private AbstractThreadState state;\n\n    // 读取状态\n    public int getThreadStatus() { return state.getThreadStatus(); }\n\n    // 设置状态\n    public void setState(AbstractThreadState state) { this.state = state; }\n\n    // 初始化状态\n    public ThreadContext() { this.state = new NewState(); }\n\n    public void start() { state.start(this); }\n\n    public void getCPU() { state.getCPU(this); }\n\n    public void suspend() { state.suspend(this); }\n\n    public void resume() { state.resume(this); }\n\n    public void stop() { state.stop(this); }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        ThreadContext thread = new ThreadContext();\n        thread.start();\n        thread.getCPU();\n        thread.suspend();\n        thread.resume();\n        thread.getCPU();\n        thread.stop();\n    }\n}\n\n```\n![state](/images/common/state.png)\n解读：ThreadContext是一个带有状态的类，当改变其状态时，其调用的方法也在发生改变。\n\n#### 1.9.2 状态模式使用\n\n\n### 2.0 策略模式(Strategy Pattern)\n介绍：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。通过组合或聚合来解决继承问题。\n说明：避免if...else语句。变化的部分则是不同的策略，但需要注意的是策略过多会导致类数目庞大。\n使用场景：\n1. 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。\n2. 一个系统需要动态地在几种算法中选择一种。\n3. 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。\n\n#### 2.0.1示例\n```C#\n/**\n * 策略类\n */\npublic interface Strategy {\n\n    void handle();\n}\n\npublic class ConcreteStrategyA implements Strategy{\n\n    @Override\n    public void handle() {\n        System.out.println(\"strategy A\");\n    }\n}\n\npublic class ConcreteStrategyB implements Strategy{\n\n    @Override\n    public void handle() {\n        System.out.println(\"strategy B\");\n    }\n}\n\npublic class Context {\n\n    private Strategy strategy;\n\n    public void setStrategy(Strategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public Context() {}\n\n    public void handle(){\n        // 也可用空对象模式\n        if (null == strategy){\n            System.out.println(\"default\");\n        }else {\n        strategy.handle();\n        }\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        Strategy strategyA = new ConcreteStrategyA();\n        Strategy strategyB = new ConcreteStrategyB();\n\n        Context context = new Context();\n        context.handle();\n\n\n        context.setStrategy(strategyA);\n        context.handle();\n\n        context.setStrategy(strategyB);\n        context.handle();\n        \n        Integer[] data = {1, 5, 2};\n        Arrays.sort(data, (v1, v2) -> {\n            // 策略\n            if(v1.compareTo(v2) > 0){\n                return -1;\n            }else {\n                return 1;\n            }\n        });\n    }\n}\n```\n![strategy](/images/common/strategy.png)\n解读：Context聚合了抽象策略类，通过传入不同的策略，改变其结果。\n\n\n#### 2.0.2 策略模式使用\nArrays的Comparator\n\n### 2.1 职责链模式(Chain of Responsibility Pattern)\n介绍：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。\n使用场景：\n1. 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。\n2. 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。\n3. 可动态指定一组对象处理请求。\n\n#### 2.1.1示例\n```C#\n/**\n * 自定义请求\n */\npublic class MyRequest {\n\n    private String host;\n\n    private int port;\n\n    private int id;\n\n    public int getPort() {\n        return port;\n    }\n\n    public MyRequest(String host, int port, int id) {\n        this.host = host;\n        this.port = port;\n        this.id = id;\n    }\n}\n\n/**\n * 处理者\n */\npublic abstract class AbstractFilter {\n\n    protected String name;\n\n    // 下一个处理者，形成链式\n    AbstractFilter filter;\n\n    public AbstractFilter(String name) {\n        this.name = name;\n    }\n\n    public void setFilter(AbstractFilter filter) {\n        this.filter = filter;\n    }\n\n    public abstract void handler(MyRequest request);\n}\n\npublic class ConcreteFilterA extends AbstractFilter{\n\n    public ConcreteFilterA(String name) {\n        super(name);\n    }\n\n    @Override\n    public void handler(MyRequest request) {\n        if (request.getPort() == 80){\n            System.out.println(\"FilterA handler\");\n        }else {\n            if (null == filter){\n                filter = new ConcreteFilterB(\"FilterB\");\n            }\n            filter.handler(request);\n        }\n    }\n}\n\npublic class ConcreteFilterB extends AbstractFilter{\n\n    public ConcreteFilterB(String name) {\n        super(name);\n    }\n\n    @Override\n    public void handler(MyRequest request) {\n        if (request.getPort() == 4000){\n            System.out.println(\"FilterB handler\");\n        }else {\n            if (null == filter){\n                filter = new ConcreteFilterB(\"FilterA\");\n            }\n            filter.handler(request);\n        }\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        MyRequest request1 = new MyRequest(\"127.0.0.1\", 80, 0);\n        MyRequest request2 = new MyRequest(\"127.0.0.1\", 4000, 1);\n\n        AbstractFilter filter = new ConcreteFilterA(\"FilterA\");\n\n        filter.handler(request1);\n        filter.handler(request2);\n\n    }\n}\n```\n![responsibilitychain](/images/common/responsibilitychain.png)\n解读：AbstractFilter是一个抽象的处理者，处理者中又聚合了下一个处理者，当自身无法处理的时候，就可以交给下一个处理者处理。\n\n#### 2.1 .2 职责链模式使用\nSpingMVC中的HandlerExecutionChain+","categories":["从零开始","从零开始设计模式"]},{"title":"从零开始设计模式第3章-结构型模式(七种)","url":"/2020/01/12/从零开始设计模式第3章/","content":"## 1.结构型模式(7种)\n* 适配器模式(Adapter Pattern)\n* 桥接模式(Bridge Pattern)\n* 装饰器模式(Decorator Pattern)\n* 组合模式(Composite Pattern)\n* 外观模式(Facade Pattern)\n* 享元模式(Flyweight Pattern)\n* 代理模式(Proxy Pattern)\n\n### 1.1 适配器模式(Adapter Pattern)\n介绍：也叫变压器模式。将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。(适配器**继承或依赖**已有的对象，**实现**想要的目标接口。)\n使用场景：\n1. 美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 \n2. JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 \n3. 在 LINUX 上运行 WINDOWS 程序。 \n4. JAVA 中的 jdbc。\n\n#### 1.1.1示例\n```C#\n/**\n * src\n */\npublic interface MediaPlayer {\n    void play(String audioType, String fileName);\n}\n\n/**\n * target\n */\npublic interface AdvancedMediaPlayer {\n    void playVlc(String fileName);\n    void playMp4(String fileName);\n}\n\npublic class Mp4Player implements AdvancedMediaPlayer {\n    @Override\n    public void playVlc(String fileName) {\n        // nothing\n    }\n\n    @Override\n    public void playMp4(String fileName) {\n        System.out.println(\"Playing mp4 file. Name: \"+ fileName);\n    }\n}\n\npublic class VlcPlayer implements AdvancedMediaPlayer {\n    @Override\n    public void playVlc(String fileName) {\n        System.out.println(\"Playing vlc file. Name: \"+ fileName);\n    }\n\n    @Override\n    public void playMp4(String fileName) {\n        // nothing\n    }\n}\n\n/**\n * adapter\n */\npublic class MediaAdapter implements MediaPlayer {\n\n    AdvancedMediaPlayer advancedMusicPlayer;\n\n    public MediaAdapter(String audioType){\n        if(audioType.equalsIgnoreCase(\"vlc\") ){\n            advancedMusicPlayer = new VlcPlayer();\n        } else if (audioType.equalsIgnoreCase(\"mp4\")){\n            advancedMusicPlayer = new Mp4Player();\n        }\n    }\n\n    /**\n     * adapte the src to target\n     * @param audioType\n     * @param fileName\n     */\n    @Override\n    public void play(String audioType, String fileName) {\n        if(audioType.equalsIgnoreCase(\"vlc\")){\n            advancedMusicPlayer.playVlc(fileName);\n        }else if(audioType.equalsIgnoreCase(\"mp4\")){\n            advancedMusicPlayer.playMp4(fileName);\n        }\n    }\n}\n\n/**\n * use the adapter\n */\npublic class AudioPlayer implements MediaPlayer {\n    MediaAdapter mediaAdapter;\n\n    @Override\n    public void play(String audioType, String fileName) {\n\n        // 播放 mp3 音乐文件的内置支持\n        if(audioType.equalsIgnoreCase(\"mp3\")){\n            System.out.println(\"Playing mp3 file. Name: \"+ fileName);\n        }\n        // mediaAdapter 提供了播放其他文件格式的支持\n        else if(audioType.equalsIgnoreCase(\"vlc\")\n                || audioType.equalsIgnoreCase(\"mp4\")){\n            mediaAdapter = new MediaAdapter(audioType);\n            mediaAdapter.play(audioType, fileName);\n        }\n        else{\n            System.out.println(\"Invalid media. \"+\n                    audioType + \" format not supported\");\n        }\n    }\n}\n\npublic class Client {\n    public static void main(String[] args) {\n        AudioPlayer audioPlayer = new AudioPlayer();\n\n        audioPlayer.play(\"mp3\", \"beyond the horizon.mp3\");\n        audioPlayer.play(\"mp4\", \"alone.mp4\");\n        audioPlayer.play(\"vlc\", \"far far away.vlc\");\n        audioPlayer.play(\"avi\", \"mind me.avi\");\n    }\n}\n\n```\n![factory](/images/common/adapter.png)\n解读：AudioPlayer通过适配器MediaAdapter将原来的MediaPlayer转换成了AdvancedMediaPlayer。 \n#### 1.1.2 适配器模式使用\nSpringMVC中的HandlerAdapter\n\n### 1.2 桥接模式(Bridge Pattern)\n介绍：将抽象部分与实现部分分离，使它们都可以独立的变化。\n使用场景：\n1. 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 \n2. 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。\n3. 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。\n#### 1.2.1示例\n```C#\npublic interface Brand {\n    void open();\n\n    void close();\n\n    void call();\n}\n\npublic class XiaoMi implements Brand {\n    @Override\n    public void open() {\n        System.out.println(\"Xiaomi open\");\n    }\n\n    @Override\n    public void close() {\n        System.out.println(\"Xiaomi close\");\n    }\n\n    @Override\n    public void call() {\n        System.out.println(\"Xiaomi call\");\n    }\n}\n\npublic class Iphone implements Brand {\n    @Override\n    public void open() {\n        System.out.println(\"Iphone open\");\n    }\n\n    @Override\n    public void close() {\n        System.out.println(\"Iphone close\");\n    }\n\n    @Override\n    public void call() {\n        System.out.println(\"Iphone call\");\n    }\n}\n\n/**\n * 桥接类\n */\npublic abstract class Phone {\n\n    // 组合品牌\n    private Brand brand;\n\n    public Phone(Brand brand){\n        super();\n        this.brand = brand;\n    }\n\n    protected void open() {\n        brand.open();\n    }\n\n    protected void close() {\n        brand.close();\n    }\n\n    protected void call() {\n        brand.call();\n    }\n}\n\npublic class FoledPhone extends Phone{\n\n    public FoledPhone(Brand brand) {\n        super(brand);\n    }\n\n    public void open() {\n        super.open();\n        System.out.println(\"折叠式手机\");\n    }\n\n    public void close() {\n        super.close();\n        System.out.println(\"折叠式手机\");\n    }\n\n    public void call() {\n        super.call();\n        System.out.println(\"折叠式手机\");\n    }\n}\n\npublic class UpRightPhone extends Phone{\n\n    public UpRightPhone(Brand brand) {\n        super(brand);\n    }\n\n    public void open() {\n        super.open();\n        System.out.println(\"直立式手机\");\n    }\n\n    public void close() {\n        super.close();\n        System.out.println(\"直立式手机\");\n    }\n\n    public void call() {\n        super.call();\n        System.out.println(\"直立式手机\");\n    }\n}\n\n\npublic class Client {\n\n    public static void main(String[] args){\n        Phone foledPhone = new FoledPhone(new Iphone());\n        foledPhone.open();\n        foledPhone.close();\n        foledPhone.call();\n\n        Phone upRightPhone = new UpRightPhone(new XiaoMi());\n        upRightPhone.open();\n        upRightPhone.close();\n        upRightPhone.call();\n    }\n}\n```\n![bridge](/images/common/bridge.png)\n解读：Phone作为桥接类，将不同的Brand通过聚合的方式组合起来。\n#### 1.2.2 桥接模式使用\nJDBC中的Driver\n\n### 1.3 装饰器模式(Decorator Pattern)\n介绍：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。\n使用场景：\n1. 扩展一个类的功能。 \n2. 动态增加功能，动态撤销。\n#### 1.3.1示例\n```C#\n/**\n * 整体抽象出来\n */\npublic abstract class Drink {\n\n    public String desc;\n\n    private float price = 0.0f;\n\n    // 重点：计算费用，由子类实现\n    public abstract float cost();\n\n    public String getDesc() {\n        return desc;\n    }\n\n    public void setDesc(String desc) {\n        this.desc = desc;\n    }\n\n    public float getPrice() {\n        return price;\n    }\n\n    public void setPrice(float price) {\n        this.price = price;\n    }\n}\n\n/**\n * 被装饰者\n */\npublic class Coffee extends Drink{\n\n    @Override\n    public float cost() {\n        return super.getPrice();\n    }\n}\n\npublic class Espresso extends Coffee {\n    public Espresso(){\n        setDesc(\"意大利咖啡\");\n        setPrice(6.0f);\n    }\n}\n\npublic class LongBlack extends Coffee{\n\n    public LongBlack(){\n        setDesc(\"美式咖啡\");\n        setPrice(5.0f);\n    }\n}\n\n/**\n * 装饰者\n */\npublic class Decorator extends Drink{\n\n    // 被装饰者\n    private Drink drink;\n\n    public Decorator(Drink drink){\n        this.drink = drink;\n    }\n\n    //组合\n    @Override\n    public float cost() {\n        return super.getPrice() + drink.getPrice();\n    }\n\n    @Override\n    public String getDesc() {\n        return super.getDesc() + \"+\" + drink.getDesc();\n    }\n}\n\npublic class Milk extends Decorator {\n\n    public Milk(Drink drink) {\n        super(drink);\n        setDesc(\"牛奶\");\n        setPrice(2.0f);\n    }\n}\n\npublic class Chocolate extends Decorator{\n\n    public Chocolate(Drink drink) {\n        super(drink);\n        setDesc(\"巧克力\");\n        setPrice(3.0f);\n    }\n}\n\n\npublic class Client {\n\n    public static void main(String[] args){\n        Drink order = new Espresso();\n        System.out.println(order.cost());\n        System.out.println(order.getDesc());\n        order = new Milk(order);\n        System.out.println(order.cost());\n        System.out.println(order.getDesc());\n    }\n}\n```\n![decorator](/images/common/decorator.png)\n解读：Decorator作为装饰者，通过组合的方式装饰Coffee，Decorator装饰者和Coffee被装饰者两者拥有共同的父类。\n#### 1.3.2 装饰器模式使用\nJDK中的IO结构\n\n### 1.4 组合模式(Composite Pattern)\n介绍：将对象组合成**树形结构**以表示\"部分-整体\"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n使用场景：\n 1. 算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 \n 2. 在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。\n\n #### 1.4.1示例\n```C#\n/**\n * 抽象类\n */\npublic abstract class OrganizationComponent {\n\n    private String name;\n    private String desc;\n\n    protected void add(OrganizationComponent organizationComponent){\n        throw new  UnsupportedOperationException();\n    }\n\n    protected void remove(OrganizationComponent organizationComponent){\n        throw new  UnsupportedOperationException();\n    }\n\n    public abstract void print();\n\n    public OrganizationComponent(String name, String desc) {\n        this.name = name;\n        this.desc = desc;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDesc() {\n        return desc;\n    }\n\n    public void setDesc(String desc) {\n        this.desc = desc;\n    }\n}\n\npublic class University extends OrganizationComponent{\n\n    // 聚合\n    List<OrganizationComponent> organizationComponents = new ArrayList<>();\n\n    public University(String name, String desc) {\n        super(name, desc);\n    }\n\n    @Override\n    protected void add(OrganizationComponent organizationComponent) {\n        organizationComponents.add(organizationComponent);\n    }\n\n    @Override\n    protected void remove(OrganizationComponent organizationComponent) {\n        organizationComponent.remove(organizationComponent);\n    }\n\n    @Override\n    public void print() {\n        System.out.println(this.getName());\n        for (OrganizationComponent organization : organizationComponents) {\n            organization.print();\n        }\n    }\n}\n\npublic class College extends OrganizationComponent{\n\n    // 聚合\n    List<OrganizationComponent> organizationComponents = new ArrayList<>();\n\n    public College(String name, String desc) {\n        super(name, desc);\n    }\n\n    @Override\n    protected void add(OrganizationComponent organizationComponent) {\n        organizationComponents.add(organizationComponent);\n    }\n\n    @Override\n    protected void remove(OrganizationComponent organizationComponent) {\n        organizationComponent.remove(organizationComponent);\n    }\n\n    @Override\n    public void print() {\n        System.out.println(this.getName());\n        for (OrganizationComponent organization : organizationComponents) {\n            organization.print();\n        }\n    }\n}\n\n/**\n * leaf叶子节点\n */\npublic class Department extends OrganizationComponent{\n\n\n    public Department(String name, String desc) {\n        super(name, desc);\n    }\n\n    @Override\n    public void print() {\n        System.out.println(this.getName());\n    }\n}\n\npublic class Client {\n\n    public static void main(String args[]){\n        OrganizationComponent university = new University(\"程序员大学\", \"万物皆明辨可惜\");\n        university.add(new College(\"计算机学院\", \"万物皆计算机\"));\n        university.add(new College(\"数学学院\", \"万物皆数学\"));\n        university.print();\n\n        System.out.println(\"----------------------\");\n        OrganizationComponent college = new College(\"物理学院\", \"万物皆物理\");\n        college.add(new Department(\"物理一班\", \"一班一班\"));\n        college.add(new Department(\"物理二班\", \"二班二班\"));\n        university.add(college);\n        university.print();\n\n    }\n}\n\n```\n![composite](/images/common/composite.png)\n解读：College和University通过聚合的方式组合起来，可以很方便的增加和删除，而叶子节点是最小的节点，不需要增加和删除。需要注意的是这里的College和University继承了同一个抽象类，需具有相同的部分。\n#### 1.4.2 组合模式使用\nJDK中的HashMap\n\n### 1.5 外观模式(Facade Pattern)\n介绍：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n使用场景：\n1. 为复杂的模块或子系统提供外界访问的模块。 \n2. 子系统相对独立。 \n3. 预防低水平人员带来的风险。\n#### 1.5.1示例\n```C#\npublic interface Shape {\n    void draw();\n}\n\npublic class Square implements Shape {\n\n    @Override\n    public void draw() {\n        System.out.println(\"Square::draw()\");\n    }\n}\n\npublic class Circle implements Shape {\n\n    @Override\n    public void draw() {\n        System.out.println(\"Circle::draw()\");\n    }\n}\n\npublic class Rectangle implements Shape {\n\n    @Override\n    public void draw() {\n        System.out.println(\"Rectangle::draw()\");\n    }\n}\n\n/**\n * 外观类\n */\npublic class ShapeMaker {\n    private Shape circle;\n    private Shape rectangle;\n    private Shape square;\n\n    public ShapeMaker() {\n        // 实例化属性，可以用单例模式实例化\n        circle = new Circle();\n        rectangle = new Rectangle();\n        square = new Square();\n    }\n\n    public void draw(){\n        circle.draw();\n        rectangle.draw();\n        square.draw();\n    }\n}\n\npublic class Client {\n    public static void main(String[] args) {\n        ShapeMaker shapeMaker = new ShapeMaker();\n        shapeMaker.draw();\n    }\n}\n```\n![facade](/images/common/facade.png)\n解读：ShapeMaker作为外观类，通过组合的形式，把内部的细节都封装了。使用者只需要通过外观类进行调用即可。\n\n#### 1.5.2 外观模式使用\nMybatis中的Configuration\n\n### 1.6 享元模式(Flyweight Pattern)\n介绍：也叫蝇量模式，运用共享技术有效地支持大量细粒度的对象。(注意划分**外部状态和内部状态**，否则可能会引起线程安全问题。这些类必须有一个工厂对象加以控制。)\n使用场景：\n1. JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 \n2. 数据库的数据池。\n#### 1.6.1示例\n```C#\npublic abstract class WebSite {\n    public abstract void used(User user);\n}\n\npublic class ConcreateWebSite extends WebSite {\n\n    private String type = \"\";\n\n    public ConcreateWebSite(String type){\n        this.type = type;\n    }\n\n    @Override\n    public void used(User user) {\n        System.out.println(\"user\" + user.getName() + \", type:\" + type);\n    }\n}\n\npublic class User {\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public User(String name) {\n        this.name = name;\n    }\n}\n\n**\n * 享元池\n */\npublic class WebSiteFactory {\n\n    private HashMap<String, ConcreateWebSite> pool = new HashMap<>();\n\n    /**\n     * 在享元池中取，如果没有则创建\n     * @param type\n     * @return\n     */\n    public WebSite getWebSiteByType(String type){\n        if (!pool.containsKey(type)){\n            pool.put(type, new ConcreateWebSite(type));\n        }\n        return pool.get(type);\n    }\n\n    public int getWebSitePoolSize(){\n        return pool.size();\n    }\n\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        WebSiteFactory webSiteFactory = new WebSiteFactory();\n        webSiteFactory.getWebSiteByType(\"news\");\n        System.out.println(webSiteFactory.getWebSitePoolSize());\n        webSiteFactory.getWebSiteByType(\"blog\");\n        System.out.println(webSiteFactory.getWebSitePoolSize());\n        webSiteFactory.getWebSiteByType(\"shop\");\n        System.out.println(webSiteFactory.getWebSitePoolSize());\n\n        WebSite news = webSiteFactory.getWebSiteByType(\"news\");\n        news.used(new User(\"A\"));\n        System.out.println(webSiteFactory.getWebSitePoolSize());\n    }\n}\n\n```\n![flyweight](/images/common/flyweight.png)\n解读：通过整理内部状态，设计享元池，进行共享，减少了对象的创建。\n\n#### 1.6.2 享元模式使用\nJava中的String常量池、Integer.valueOf()\n\n### 1.7 代理模式(Proxy Pattern)\n介绍：为其他对象提供一种代理以控制对这个对象的访问。代理模式有不同的形式，主要有三种：静态代理、动态代理(JDK代理、接口代理)、Cglib代理(可以在内存动态的创建对象，而不需要实习接口，属于动态代理)。\n使用场景：\n1. 远程代理。 \n2. 虚拟代理。 \n3. Copy-on-Write 代理。 \n4. 保护（Protect or Access）代理。\n5. Cache代理。 \n6. 防火墙（Firewall）代理。 \n7. 同步化（Synchronization）代理。 \n8. 智能引用（Smart Reference）代理。\n#### 1.7.1静态代理\n```C#\npublic interface TeacherDao {\n\n    void teach();\n}\n\npublic class TeacherDaoImpl implements TeacherDao {\n    @Override\n    public void teach() {\n        System.out.println(\"teaching\");\n    }\n}\n\n/**\n * 代理对象\n * 静态代理，需要实现目标接口，聚合目标对象\n */\npublic class TeachDaoProxy implements TeacherDao{\n\n    // 目标对象\n    private TeacherDao target;\n\n    public TeachDaoProxy(TeacherDao target){\n        this.target = target;\n    }\n\n    @Override\n    public void teach() {\n        System.out.println(\"proxy start\");\n        target.teach();\n        System.out.println(\"proxy end\");\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        TeachDaoProxy proxy = new TeachDaoProxy(new TeacherDaoImpl());\n        // 通过代理对象，调用被代理对象的方法\n        proxy.teach();\n    }\n}\n\n```\n![staticproxy](/images/common/staticproxy.png)\n解读：TeachDaoProxy代理通过实现目标接口，聚合目标对象，进行静态代理。最后通过代理对象，调用被代理对象的方法。\n\n#### 1.7.2 动态代理\n```C#\npublic interface TeacherDao {\n\n    void teach();\n}\n\npublic class TeacherDaoImpl implements TeacherDao {\n    @Override\n    public void teach() {\n        System.out.println(\"teaching\");\n    }\n}\n\n/**\n * 代理对象\n * 动态代理，利用JDK的newProxyInstance方法，动态的在内存中构建代理对象\n * java.lang.reflect.Proxy\\\n *\n * 根据传入的目标对象，利用反射机制，返回一个代理对象。然后通过代理对象，调用目标对象方法\n */\npublic class ProxyFactory {\n\n    // 目标对象\n    private Object target;\n\n    public ProxyFactory(Object target){\n        this.target = target;\n    }\n\n    public Object getProxyInstance(){\n        /**\n         * ClassLoader loader 指定当前目标对象使用的类加载器，获取加载器的方法固定\n         * Class<?>[] interfaces 目标对象实现的接口类型，使用方向方式确认类型\n         * InvocationHandler h 事情处理，执行目标对象的方法是，会触发事情处理器方法\n         */\n        ClassLoader loader = target.getClass().getClassLoader();\n        Class<?>[] interfaces = target.getClass().getInterfaces();\n        InvocationHandler h = (Object proxy, Method method, Object[] args) -> {\n                System.out.println(\"反射机制调用目标对象的方法\");\n                Object invoke = method.invoke(target, args);\n                System.out.println(\"JDK代理提交\");\n                return invoke;\n        };\n        return Proxy.newProxyInstance(loader, interfaces, h);\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        TeacherDao target = new TeacherDaoImpl();\n        TeacherDao proxy = (TeacherDao)new ProxyFactory(target).getProxyInstance();\n        // 通过代理对象，调用目标对象的方法\n        proxy.teach();\n    }\n}\n```\n![dynamicproxy](/images/common/dynamicproxy.png)\n解读：ProxyFactory动态代理，利用JDK的newProxyInstance方法，动态的在内存中构建代理对象。最后通过代理对象，调用被代理对象的方法。\n\n#### 1.7.3 Cglib代理\nCglib是一个强大的高性能的代码生成包，被许多框架使用，例如：Spring AOP。Cglib包的底层是通过字节码处理框架ASM来转换字节码并生产新的类。\n **cglib是针对类来实现代理的，原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理**\n\n```C#\npublic class TeacherDao {\n    public void teach() {\n        System.out.println(\"teaching\");\n    }\n}\n\n/**\n * MethodInterceptor 方法拦截器\n * cglib是针对类来实现代理的，原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理\n */\npublic class ProxyFactory implements MethodInterceptor {\n\n    Object target;\n\n    public ProxyFactory(Object target){\n        this.target = target;\n    }\n\n    /**\n     * 返回target目标对象的代理对象\n     * 调用代理对象的时候，会触发调用intercept()\n     * @return\n     */\n    public Object getProxyInstance(){\n        // 1.cglib增强类\n        Enhancer enhancer = new Enhancer();\n        // 2.设置父类\n        enhancer.setSuperclass(target.getClass());\n        // 3.设置回调函数\n        enhancer.setCallback(this);\n        // 4.创建子类对象，即代理对象\n        return enhancer.create();\n    }\n\n    /**\n     * 重写intercept方法，实现对被代理对象(目标对象)方法调用\n     * @param o\n     * @param method\n     * @param objects 方法参数\n     * @param methodProxy\n     * @return\n     * @throws Throwable\n     */\n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        System.out.println(\"cglib start\");\n        Object invoke = method.invoke(target, objects);\n        System.out.println(\"cglib end\");\n        return invoke;\n    }\n}\n\npublic class Client {\n\n    public static void main(String[] args) {\n        TeacherDao target = new TeacherDao();\n        TeacherDao proxy = (TeacherDao)new ProxyFactory(target).getProxyInstance();\n        // 通过代理对象，调用目标对象的方法\n        proxy.teach();\n    }\n}\n\n```\n![cglibproxy](/images/common/cglibproxy.png)\n解读：ProxyFactory利用Cglib代理，当通过代理对象，调用目标对象时候，会触发MethodInterceptor方法拦截器，通过重写intercept方法，实现对被代理对象(目标对象)方法调用。\n\n#### 1.7.4 对比\nJDK代理：目标对象实现接口\nCglib代理：目标对象不需要实现接口\n\n#### 1.7.5 代理模式使用\n\n","categories":["从零开始","从零开始设计模式"]},{"title":"从零开始设计模式第2章-创建型模式(五种)","url":"/2020/01/06/从零开始设计模式第2章/","content":"## 1.创建型模式(5种)\n* 单例模式(Singleton Pattern)\n* 工厂模式(Factory Pattern)\n* 抽象工厂模式(Abstract Factory Pattern)\n* 原型模式(Prototype Pattern)\n* 建造者模式(Builder Pattern)\n\n### 1.1 单例模式(Singleton Pattern)\n介绍：保证一个类只有一个对象实例。\n使用场景：\n1. 需频繁的创建和销毁类(重量级对象)，但又经常需要用到的。如：工具类、数据源、session工厂等。\n2. 要求生产唯一序列号。\n3. WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。\n4. 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。\n\n#### 1.1.1饿汉式(静态常量)\n```C#\npublic class SingletonDemo1 {\n\n    public static void main(String args[]){\n        Singleton1 instance1 = Singleton1.getInstance();\n        Singleton1 instance2 = Singleton1.getInstance();\n        System.out.println(instance1 == instance2);\n    }\n}\n\n// 饿汉式(静态常量)\nclass Singleton1{\n\n    // 1.私有化构造方法\n    private Singleton1(){}\n\n    // 2.静态变量\n    private static final Singleton1 instance = new Singleton1();\n\n    // 3.获取\n    public static Singleton1 getInstance(){\n        return instance;\n    }\n\n}\n```\n优点：写法简单，线程安全\n缺点：没有懒加载(lazy loading)，可能造成内存浪费\n\n#### 1.1.2饿汉式(静态块)\n```C#\npublic class SingletonDemo2 {\n\n    public static void main(String args[]){\n        Singleton2 instance1 = Singleton2.getInstance();\n        Singleton2 instance2 = Singleton2.getInstance();\n        System.out.println(instance1 == instance2);\n    }\n}\n\n// 饿汉式(静态块)\nclass Singleton2{\n\n    // 1.私有化构造方法\n    private Singleton2(){}\n\n    private static Singleton2 instance;\n\n    // 2.静态块\n    static {\n        instance = new Singleton2();\n    }\n\n    // 3.获取\n    public static Singleton2 getInstance(){\n        return instance;\n    }\n\n}\n```\n优点：写法简单，线程安全\n缺点：没有懒加载(lazy loading)，可能造成内存浪费\n\n#### 1.1.3懒汉式(同步方法)\n```C#\npublic class SingletonDemo3 {\n\n    public static void main(String args[]){\n        Singleton3 instance1 = Singleton3.getInstance();\n        Singleton3 instance3 = Singleton3.getInstance();\n        System.out.println(instance1 == instance3);\n    }\n}\n\n// 懒汉式(同步方法)\nclass Singleton3{\n\n    // 1.私有化构造方法\n    private Singleton3(){}\n\n    private static Singleton3 instance;\n\n    // 2.获取\n    public static synchronized Singleton3 getInstance(){\n        if (instance == null) {\n                instance = new Singleton3();\n        }\n        return instance;\n    }\n\n}\n```\n优点：线程安全，延迟加载\n缺点：效率较低\n\n#### 1.1.4双重检查(同步代码块)\n```C#\npublic class SingletonDemo4 {\n\n    public static void main(String args[]){\n        Singleton4 instance1 = Singleton4.getInstance();\n        Singleton4 instance4 = Singleton4.getInstance();\n        System.out.println(instance1 == instance4);\n    }\n}\n\n// 双重检查(同步代码块)\nclass Singleton4{\n\n    // 1.私有化构造方法\n    private Singleton4(){}\n\n    // volatile保证内存可见性，防止指令重排\n    private static volatile Singleton4 instance;\n\n    // 2.获取\n    public static Singleton4 getInstance(){\n        if (instance == null) {\n            synchronized (Singleton4.class){\n                if (instance == null) {\n                    instance = new Singleton4();\n                }\n            }\n        }\n        return instance;\n    }\n\n}\n```\n优点：线程安全，延迟加载，效率较高(**推荐使用**)\n缺点：\n\n#### 1.1.5静态内部类\n```C#\npublic class SingletonDemo5 {\n\n    public static void main(String args[]){\n        Singleton5 instance1 = Singleton5.getInstance();\n        Singleton5 instance5 = Singleton5.getInstance();\n        System.out.println(instance1 == instance5);\n    }\n}\n\n// 静态内部类\nclass Singleton5{\n\n    // 1.私有化构造方法\n    private Singleton5(){}\n\n    // 2.静态内部类(外部类被加载时候，静态内部类不会被加载)\n    private static class SingletonInstance{\n        private static final Singleton5 instance = new Singleton5();\n    }\n\n    // 3.获取\n    public static Singleton5 getInstance(){\n        return SingletonInstance.instance;\n    }\n\n}\n```\n优点：线程安全，延迟加载，效率较高(**推荐使用**)\n缺点：\n\n#### 1.1.6枚举\n```C#\npublic class SingletonDemo6 {\n\n    public static void main(String args[]){\n        Singleton6 instance1 = Singleton6.INSTANCE;\n        Singleton6 instance6 = Singleton6.INSTANCE;\n        System.out.println(instance1 == instance6);\n    }\n}\n\n// 枚举\nenum Singleton6{\n\n    INSTANCE\n}\n```\n优点：线程安全，防止反序列化重新创建新对象(**推荐使用**)\n缺点：\n\n#### 1.1.7单例模式应用\njava.lang.Runtime\n\n---\n\n单例模式很好理解，接下来的设计模式则比较抽象，需要好好进行思考。\n\n---\n\n### 1.2 工厂模式(Factory Pattern)\n介绍：定义一共用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。\n使用场景： \n1. 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 \n2. 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 \n3. 设计一个连接服务器的框架，需要三个协议，\"POP3\"、\"IMAP\"、\"HTTP\"，可以把这三个作为产品类，共同实现一个接口。\n\n#### 1.2.1 分类\n* 简单工厂模式，也就静态工厂模式\n* 多个工厂模式\n\n#### 1.2.2 示例\n```C#\n/**\n * 产品\n */\npublic abstract class Product {\n\n    public void method1(){}\n\n    // 业务逻辑处理\n    public abstract void method2();\n}\n\npublic class ConcreateProduct1 extends Product {\n\n    @Override\n    public void method2() {\n        // 业务逻辑处理\n    }\n}\n\npublic class ConcreateProduct2 extends Product {\n\n    @Override\n    public void method2() {\n        // 业务逻辑处理\n    }\n}\n\n/**\n * 创建者\n */\npublic abstract class Creator {\n\n    public abstract <T extends Product> T createProduct(Class<T> clazz);\n}\n\npublic class ConcreateCreator extends Creator {\n\n    @Override\n    public <T extends Product> T createProduct(Class<T> clazz) {\n        Product product = null;\n        try {\n            product = (Product)clazz.forName(clazz.getName()).newInstance();\n        }catch (ClassNotFoundException e){\n        }catch (IllegalAccessException e){\n        }catch (InstantiationException e){\n        }\n        return (T)product;\n    }\n}\n\npublic class Client {\n\n    public static void main(String args[]){\n        Creator creator = new ConcreateCreator();\n        Product product1= creator.createProduct(ConcreateProduct1.class);\n        Product product2= creator.createProduct(ConcreateProduct2.class);\n    }\n}\n```\n![factory](/images/common/factory.png)\n解读：Creator通过传入不同的产品类型来创建不同的产品。\n\n---\n\n工厂模式在项目中使用非常频繁，需好好思考如何运用。\n\n---\n\n### 1.3 抽象工厂模式(Abstract Factory Pattern)\n介绍：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类\n使用场景：\n1. QQ 换皮肤，一整套一起换。 \n2. 生成不同操作系统的程序。\n\n#### 1.3.1 示例\n\n```C#\n/**\n * 产品A\n */\npublic abstract class AbstractProductA {\n\n    public void method1(){}\n\n    // 业务逻辑处理\n    public abstract void method2();\n}\n\n/**\n * 产品B\n */\npublic abstract class AbstractProductB {\n\n    public void method1(){}\n\n    // 业务逻辑处理\n    public abstract void method2();\n}\n\npublic class ProductA1 extends AbstractProductA {\n\n    @Override\n    public void method2() {\n        // 业务逻辑处理\n    }\n}\n\npublic class ProductA2 extends AbstractProductA {\n\n    @Override\n    public void method2() {\n        // 业务逻辑处理\n    }\n}\n\npublic class ProductB1 extends AbstractProductB {\n\n    @Override\n    public void method2() {\n        // 业务逻辑处理\n    }\n}\n\npublic class ProductB2 extends AbstractProductB {\n\n    @Override\n    public void method2() {\n        // 业务逻辑处理\n    }\n}\n\n/**\n * 创建者\n */\npublic abstract class AbstractFactryCreator {\n\n    public abstract AbstractProductA createProductA();\n\n    public abstract AbstractProductB createProductB();\n}\n\npublic class FactryCreator1 extends AbstractFactryCreator {\n\n    @Override\n    public AbstractProductA createProductA() {\n        return new ProductA1();\n    }\n\n    @Override\n    public AbstractProductB createProductB() {\n        return new ProductB1();\n    }\n}\n\npublic class FactryCreator2 extends AbstractFactryCreator {\n\n    @Override\n    public AbstractProductA createProductA() {\n        return new ProductA2();\n    }\n\n    @Override\n    public AbstractProductB createProductB() {\n        return new ProductB2();\n    }\n}\n\npublic class Client {\n    public static void main(String args[]){\n        AbstractFactryCreator creator1 = new FactryCreator1();\n        AbstractProductA productA1 = creator1.createProductA();\n        AbstractProductB productB1 = creator1.createProductB();\n\n        AbstractFactryCreator creator2 = new FactryCreator2();\n        AbstractProductA productA2 = creator2.createProductA();\n        AbstractProductB productB2 = creator2.createProductB();\n    }\n}\n\n```\n![factory](/images/common/abstractfactory.png)\n解读：与工厂模式不同的是，抽象工厂模式把工厂抽象起来，通过不同的AbstractFactryCreator工厂创建不同的产品。\n\n---\n\n抽象工厂模式和工厂模式有点像，需要好好理解和区分。下面来看看原型模式\n\n---\n\n### 1.4 原型模式(Prototype Pattern)\n介绍：用于创建重复的对象，同时又能保证性能。\n使用场景：\n1. 资源优化场景。类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 \n2. 性能和安全要求的场景。通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 \n3. 一个对象多个修改者的场景。一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 \n4. 在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。\n\n#### 1.4.1 示例\n```C#\n/**\n * Mail\n * Cloneable用于标记可拷贝，无实现方法\n */\npublic class Mail implements Cloneable{\n    /**\n     * 默认是浅拷贝\n     * @return\n     */\n    @Override\n    protected Object clone(){\n        Mail mail = null;\n        try{\n            mail = (Mail)super.clone();\n        }catch (CloneNotSupportedException e){\n\n        }\n        return mail;\n    }\n}\n\npublic class Client {\n    public static void main(String args[]){\n       Mail template = new Mail();\n       Mail template0 =  (Mail)template.clone();\n       Mail template1 =  (Mail)template.clone();\n       Mail template2 =  (Mail)template.clone();\n       Mail template3 =  (Mail)template.clone();\n       Mail template4 =  (Mail)template.clone();\n       Mail template5 =  (Mail)template.clone();\n    }\n}\n```\n解读：通过实现Cloneable接口，并重写Object基类的clone()方法，实现了类的复制。\n原型模式从堆内存二进制流进行拷贝，避免了构造函数的执行，大大提高了效率。\n\n#### 1.4.2 实现深拷贝的方式\n1. 重写clone()方法\n2. 通过序列化和反序列化方式\n\n---\n\n使用原型模式一定要注意浅拷贝和深拷贝问题\n\n---\n### 1.5 建造者模式(Builder Pattern)\n介绍：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示(顺序)。\n使用场景：\n1. 方法相同，但是**组合顺序不同**\n\n#### 1.5.1 示例\n```C#\n/**\n * 产品\n */\npublic abstract class Computer {\n\n    protected String board;\n    protected String display;\n    protected String mOs;\n\n    protected Computer(){\n    }\n\n\n    public void setBoard(String board){\n        this.board=board;\n    }\n\n    public void setDisplay(String display) {\n        this.display = display;\n    }\n\n    public abstract void setOs() ;\n}\n\npublic class MacBook extends Computer{\n    @Override\n    public void setOs() {\n        System.out.println(\"Mac OS X\");\n    }\n}\n\npublic abstract class Builder {\n\n    abstract void buildBoard(String board);\n\n    abstract void buildDisplay(String display);\n\n    abstract void buildOs();\n    \n    abstract Computer build();\n}\n\npublic class MacBookBuilder extends Builder {\n\n    private Computer macBook = new MacBook();\n\n    @Override\n    void buildBoard(String board) {\n        macBook.setBoard(board);\n    }\n\n    @Override\n    void buildDisplay(String display) {\n        macBook.setDisplay(display);\n    }\n\n    @Override\n    void buildOs() {\n        macBook.setOs();\n    }\n\n    @Override\n    Computer build() {\n        return macBook;\n    }\n}\n\n/**\n * 指挥者\n */\npublic class Director {\n\n    private Builder builder = null;\n\n    public Director(Builder builder) {\n        this.builder = builder;\n    }\n\n    public void construct(String board,String display){\n        builder.buildDisplay(display);\n        builder.buildBoard(board);\n        builder.buildOs();\n    }\n}\n\npublic class Client {\n\n    public static void main(String args[]) {\n        Builder builder = new MacBookBuilder() ;\n\n        Director director = new Director(builder);\n        director.construct(\"英特尔主板\", \"Retina显示器\");\n\n        Computer macBook = builder.build();\n    }\n}\n\n```\n![factory](/images/common/builder.png)\n解读：产品Computer并不是直接通过builder就创建完毕，可以看到builder创建的产品是不完整的。在最后由Director指挥完成最后的一个设置才是真正的产品。\n\n#### 1.5.2 建造者模式使用\nStringBuilder","categories":["从零开始","从零开始设计模式"]},{"title":"从零开始设计模式第1章-UML图和设计模式七大原则","url":"/2020/01/02/从零开始设计模式第1章/","content":"前面简单介绍了设计模式中七大设计原则和23种设计模式。那么这一节，让我们用示例好好了解一下七大设计原则。你将会看到坏的示例和好的示例。\n\n在此之前，需要简单学习一下UML。\n\n## 1.UML\nUML：Unified Modeling Language(统一建模语言)，是一种用于描述软件系统分析和设计的语言工具。能用图描述的地方就不要用文字去描述。\n\n### 1.1 UML图分类\n* 用例图\n* 静态结构图：类图、对象图、包图、组件图、部署图\n* 动态行为图：交互图(时序图和协作图)、状态图、活动图\n\n### 1.2 类图\n在学习设计模式中，我们核心使用到的是类图，类图是用于描述类与类之间的关系。下面是简单的介绍。\n\n类的基本组成：类名、成员变量、成员方法\n#### 1.2.1类的可访问性\n![类的可访问性](/images/common/类的可访问性.png)\n\n| **Character** | **Icon for field**                                       | **Icon for method**                                       | **Visibility**  |\n| ------------- | -------------------------------------------------------- | --------------------------------------------------------- | --------------- |\n| `-`           | ![img](https://s.plantuml.com/private-field.png)         | ![img](https://s.plantuml.com/private-method.png)         | private         |\n| `#`           | ![img](https://s.plantuml.com/protected-field.png)       | ![img](https://s.plantuml.com/protected-method.png)       | protected       |\n| `~`           | ![img](https://s.plantuml.com/package-private-field.png) | ![img](https://s.plantuml.com/package-private-method.png) | package private |\n| `+`           | ![img](https://s.plantuml.com/public-field.png)          | ![img](https://s.plantuml.com/public-method.png)          | public          |\n\n\n\n#### 1.2.2类之间关系：\n* 依赖(Dependency)\n<font color=\"#e96900\">\n只要类中用到了另一个类，这两个类就是依赖关系(直接朋友+陌生朋友)\n</font>\n\n![Dependency](/images/common/依赖.png)\n\n* 关联(Association)\n<font color=\"#e96900\">\n关联关系指的是类与类之间的联接，即我们平常说的一对一，一对多，多对多。\n关联具有导航性，即双向关系或单向关系。\n</font>\n\n![Association](/images/common/关联1.png)\n![Association](/images/common/关联2.png)\n\n* 继承(Generalization)\n![Generalization](/images/common/继承.png)\n\n* 实现(Realization)\n![Realization](/images/common/实现.png)\n\n* 聚合(Aggregation)\n<font color=\"#e96900\">\n<b>整体和部分可以分开</b>，例如：电脑和键盘，鼠标。电脑没用了鼠标和键盘但是也可以用。这里整体指的是电脑，部分指的是鼠标、键盘。\n</font>\n\n![Aggregation](/images/common/聚合.png)\n\n* 组合/复合(Composite)\n<font color=\"#e96900\">\n<b>整体和部分不可以分开</b>，例如：人和头。人不可以没有头。这里整体指的是人，部分指的是头。\n</font>\n\n![Composite](/images/common/组合.png)\n\n### 1.3工具\n插件工具[PlantUML](https://plantuml.com/zh/)\n\n## 2.七大设计原则\n\n### 2.1单一职责原则(Single Responsibility Principle)\n一个类职责不能太多太大，应降低类的复杂度，一个类只负责一项职责。\n<font color=\"#e96900\">就像我们的电子产品分类太大了，需要继续细分。</font>\n单一职责，并不只是对于类而言。对于类、接口、方法都应该尽量保证单一职责。为什么说尽量？因为职责是很难去划分清楚的，这里面最难的地方就在于如何划分清职责。\n\n单一职责的核心思想是：不要存在多于一个原因导致类的变更。\n> There should never be more than one reason for a class to change.\n\n**bad**\n```C#\npublic class Person {\n\n    void single();\n\n    void jump();\n\n    void rap();\n\n    void playBasketball();\n}\n```\n**good**\n```C#\nclass Student {\n\n    void single();\n\n    void jump();\n}\n\nclass Teacher {\n\n    void playBasketball();\n\n}\n```\n说明：bad示例中，我们把单一职责看作一个人想学太多了(教练：你什么都想学)，什么都想学，只会什么都学不好。\n\n\n### 2.2接口隔离原则(Interface Segregation Principle)\n一个接口功能不能太强太多。\n<font color=\"#e96900\">\n这个跟单一职责有些像，只不过一个是类，一个是接口的方法不能太多。\n对于接口来说，如果功能过强，当实现接口的时候，不必要的接口也必须实现，这其实太强制了。\n</font>\n接口隔离原则的核心思想是：客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口。\n**bad**\n```C#\npublic interface Person {\n\n    void single();\n\n    void jump();\n\n    void rap();\n\n    void playBasketball();\n}\n\n```\n**good**\n```C#\ninterface Student {\n\n    void single();\n\n    void jump();\n}\n\ninterface Teacher {\n\n    void playBasketball();\n\n}\n```\n说明：bad示例中，划分不明细，一个接口太强了，并不是人人都喜欢唱跳rap、篮球🏀。\n\n### 2.3依赖倒置原则(Dependence Inversion Principle)\n面向接口编程，利用多态的特性。\n<font color=\"#e96900\">\n这是告诉我们，在变量类型声明、方法传递参数类型中应尽量使用接口或抽象类，而不是具体的类。\n</font>\n依赖传递的三种方式：构造方法、setter()方法、声明依赖对象(成员变量)\n**bad**\n```C#\nclass Student{\n\n    public void single(){\n    }\n}\n\nclass Teacher{\n\n    public void single(){\n    }\n}\n\nclass Demo{\n    void single1(Student arg){\n        arg.single();\n    }\n    void single2(Teacher arg){\n        arg.single();\n    }\n}\n```\n**good**\n```C#\ninterface Person {\n\n    void single();\n}\n\nclass Student implements Person{\n\n    public void single(){\n    }\n}\n\nclass Teacher implements Person{\n\n    public void single(){\n    }\n}\n\nclass Demo{\n    void single(Person arg){\n        arg.single();\n    }\n}\n```\n说明：bad示例中，在Demo类中每让一个人single()，就要增加新single方法。方法传递的参数是具体的类，很不方便。在good中我们改进了一下，接口的形式作为形参，这样每次Demo类就不用改了。**(在变量类型声明、方法传递参数类型中应尽量使用接口或抽象类)**\n\n### 2.4里氏替换原则(Liskov Substitution Principle)\n如果子类不能完整的实现父类的方法，应断开父子继承的关系，通过聚合、组合、依赖来解决。\n<font color=\"#e96900\">\n继承的缺点：\n1. 侵入性\n2. 降低代码灵活性\n3. 增强耦合性\n</font>\n\n里氏替换原则的核心思想是：所有引用父类对象的地方，就能够使用其子类的对象。\n\n**bad**\n```C#\nclass Father {\n\n    long money(){\n        return 10000000000L;\n    }\n}\n\nclass Son extends Father{\n\n    @Override\n    long money(){\n        return 0L;\n    }\n}\n```\n**good**\n```C#\nclass Father {\n\n    long money(){\n        return 10000000000L;\n    }\n}\n\nclass Son extends Father{\n\n    long sonMoney(){\n        return 1L + money();\n    }\n}\n```\n说明：bad示例中，父亲本来有很多钱，孩子继承后父亲的东西后，没有要父亲的钱。good中我们进行了改进，孩子利用继承父亲的钱，赚到了更多的钱。\n\n### 2.5开闭原则(Open Close Principle)\n> 编程中遵守其它原则，以及使用设计模式的目的就是遵守**开闭原则**。\n\n模块和函数应对扩展开放(**提供者**)，对修改关闭(**使用者**)。\n`用抽象构建框架，用实现扩展细节。抽象约束`\n**bad**\n```C#\nclass Provider{\n\n    void show(String grade) {\n        if (\"1\".equals(grade)) {\n            print(\"A\");\n        }else if (\"2\".equals(grade)) {\n            print(\"B\");\n        } else if (\"3\".equals(grade)) {\n            print(\"C\");\n        } else{\n            print(\"D\");\n        }\n    }\n\n    void print(String s) {\n        System.out.println(s);\n    }\n}\n\nclass User{\n    public static void main(String args[]) {\n        Provider demo = new Provider();\n        demo.show(\"1\");\n        demo.show(\"2\");\n    }\n}\n```\n**good**\n```C#\ninterface Provider{\n    void print();\n}\n\nclass A implements Provider{\n    public void print(){\n        System.out.println(\"A\");\n    }\n}\n\nclass B implements Provider{\n    public void print(){\n        System.out.println(\"B\");\n    }\n}\n\nclass C implements Provider{\n    public void print(){\n        System.out.println(\"C\");\n    }\n}\n\nclass D implements Provider{\n    public void print(){\n        System.out.println(\"D\");\n    }\n}\n\nclass User{\n    public static void main(String args[]){\n        User demo = new User();\n        demo.show(new A());\n        demo.show(new B());\n    }\n\n    void show(Provider grade){\n        grade.print();\n    }\n}\n```\n说明：bad示例中，我们要打印不同内容，是通过if-else去判断，这样每增加内容就要写一次if-else。**如果有一天grade不用1234去判断了，改用abcd去判断了，那么我们就要改很多代码，同时User使用方也需要进行修改。**\n开闭原则，主张的是提供方改动而不需要使用方改动。在good里，我们进行了改进，使用接口作为形参，这样需要调什么内容就传具体的类过来。新增内容，就新增一个实现类，使用方如果想要就用，不想用也不会有影响。\n\n### 2.6迪米特法则(Demeter Principle)(最少知道原则)\n> 一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，<font color=\"#e96900\">都应该将逻辑封装在方法的内部，通过public方法提供给外部</font>。这样当被依赖的类变化时，才能最小的影响该类。\n\n最少知道原则表达的是：只与直接朋友通信。\n直接朋友：有耦合关系的类则称为朋友关系。耦合分为依赖、关联、聚合、组合等。例如一个类中**成员变量、方法参数、或者方法返回值中**用到了另一个类，则称这个两个类为直接朋友关系。\n陌生朋友：不是直接朋友，也就是陌生朋友。例如一个类中的**局部变量、临时变量**用到了另一个类。\n<font color=\"#e96900\">\n迪米特法则希望我们能够尽量不要在类中的局部变量和临时变量用到另一个陌生的类，即只与直接朋友通信。这样可以降低类与类直接的**耦合性**。\n</font>\n\n**bad**\n```C#\nclass A{\n    public void print(){\n        System.out.println(\"A\");\n    }\n}\n\nclass B{\n\n    void print1(){\n        // 局部变量中用到了类A\n        A a = new A();\n        a.print();\n    }\n    \n}\n```\n\n**good**\n```C#\nclass A{\n    public void print(){\n        System.out.println(\"A\");\n    }\n}\n\nclass B{\n\n    // 直接朋友，成员变量用到了类A\n    private A a;\n    // 直接朋友，方法参数用到了类A\n    void print1(A a){\n        a.print();\n    }\n    // 直接朋友，返回值用到了类A\n    A print2(){\n        return new A();\n    }\n}\n```\n说明：bad示例中，在局部变量中用到了A类，这样耦合性太强了。\n\n### 2.7合成复用原则(Composite/Aggregate Reuse Principle)\n`尽量首先使用组合/聚合的方式，而不是使用继承。`\n\n**bad**\n```C#\nclass A{\n    public void print(){\n        System.out.println(\"A\");\n    }\n\n    public void work(){\n        System.out.println(\"work\");\n    }\n}\n\nclass B extends A{\n    \n}\n```\n\n**good**\n```C#\nclass A{\n    public void print(){\n        System.out.println(\"A\");\n    }\n\n    public void work(){\n        System.out.println(\"work\");\n    }\n}\n\nclass B{\n\n    // 成员变量用到了类A\n    private A a;\n    public B(A a){\n        this.a = a;\n    }\n\n    // or\n    private A a1 = new A();\n\n    // 方法参数用到了类A\n    void print1(A a){\n        a.print();\n    }\n    // 返回值用到了类A\n    A print2(){\n        return new A();\n    }\n}\n```\n说明：bad示例中，类B直接继承了类A，但是类B并不需要类A中的work()方法，这样耦合性太强了。good中改成了聚合、组合的方法，更灵活。\n\n### 2.8总结\n* 单一职责原则和接口隔离原则相似，讲究对类或接口进行细化。\n* 里氏替换原则、迪米特法则、合成复用原则相似，讲究应尽量使用组合、聚合的方式，而不是继承的方式。\n* 依赖倒置原则，讲究的面向接口和抽象编程。在变量类型声明、方法传递参数类型中应尽量使用接口或抽象类，而不是具体的类。\n* 开闭原则，是七大原则的核心。讲究对扩展开放(**提供者**)，对修改关闭(**使用者**)。\n","categories":["从零开始","从零开始设计模式"]},{"title":"从零开始设计模式第0章-认识设计模式","url":"/2020/01/01/从零开始设计模式第0章/","content":"## 1.有趣的故事\n不知道大家有没有这么一个习惯，平时的话可能不会定期去整理东西，但是一旦觉得很乱的时候😩，就会忍不住去整理。这个时候问题来了，东西该从哪里开始整理呢？🤔*this's a question.*\n\n这个时候，你可能会先大概看一下有这些东西🤨，然后进行分类，把对应的东西放到对应的分类里，不知道怎么分的东西就放到一个单独的分类里。最后你花了很长的时间，终于把这些搞定了，你看着这整齐的一切，强迫症一脸满足😀😀😀。\n\n那么问题又来了，我们为什么不一开始就这样做呢。如果一开始我们就按照这样去分类，制定相应的规则，后面就不用又花时间去整理一遍了。\n\n我有一个朋友**小A**。他对自己的东西进行了分类。比如电子产品放这边，书籍放这边，生活用品放这边。OK，很长的一段时间，**小A**的东西都不需要继续整理了，而且每一样东西在哪里，他都可以按照分类轻松的去找到。可是突然有一天，他感觉电子产品这边东西放不下了，因为他买了太多电子产品了。那这个时候又要怎么办呢？\n\n**小A**细想了一下，于是想到了一个好办法😉，他决定把电子产品继续划分，比如电子产品又分为手机相关用品、电脑相关用品。很长一段时间，他都不需要继续整理，他看着这整齐的一切，强迫症一脸满足😀😀😀。\n\n## 2.认识设计模式\n上面是我们生活中的例子，而这个对于我们程序设计又有关系呢。我们在生活中会制定一些规则或规范，去解决(或避免)一些问题。同样，在我们程序设计中，也有自己的一套规范，当然这套规范并不是绝对的，只是经过了时间的整理，最后慢慢形成了这么一个大家较为认可的东西，这套规范就是**设计模式**。这个定义是我自己瞎说的，下面是正规的解释。\n\n> 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。\n\n### 2.1为什么学习设计模式？\n在之前我们知道如果等东西乱了再去整理其实很浪费时间的，所以一开始就做好，可以帮助我们很好的节约时间。学习设计模式，可以帮助我们避免或解决一些问题，让我们的程序更具有**鲁棒性**。\n\n后面我将会从零开始做游戏，自己设计一个好玩的游戏。那当一个游戏内容很多的时候，就会像上面整理东西一样头疼，所以我们先学习好设计模式，再来看看游戏如何设计。\n\n那么接下来，就和我一起来了解设计模式吧。\n\n### 2.2学习准备\n在学习之前，你需具备面向对象编程的思想，因为学习过程中会遇到很多专业名词。另外你还需了解UML。\n\n## 3.学习内容\n* 设计模式七大原则\n* 23种设计模式\n\n光听设计模式这个词，其实我们很难明白这个东西是什么，即使上面介绍了说这个一种规范，是前人的总结。但是这毕竟是概念的东西，很模糊，很朦胧，那么有没有具体的东西呢？这个设计模式又要如何使用才能去解决(或避免)一些问题呢？\n\n学习设计模式，主要分为两点，第一是了解其原则，遵守设计模式制定的一些规范；第二是学习一些`设计思想`，这些设计思想就是用于解决特定的问题。\n专业术语上我们把这两点称之为：设计模式七大原则、23种设计模式。下面的内容可以先简单了解。\n\n\n### 3.1设计模式七大原则\n\n1. 单一职责原则(Single Responsibility Principle)\n2. 接口隔离原则(Interface Segregation Principle)\n3. 依赖倒置原则(Dependence Inversion Principle)\n4. 里氏替换原则(Liskov Substitution Principle)\n5. 开闭原则(Open Close Principle)\n6. 迪米特法则(Demeter Principle)(最少知道原则)\n7. 合成复用原则(Composite/Aggregate Reuse Principle)\n\n### 3.2二十三种设计模式\n目前，学习设计模式大部分都是参考**Design Patterns - Elements of Reusable Object-Oriented Software**这本书中的提到的23种设计模式，该书籍是由GOF在 1994 年合著出版。\n\n**GOF**：Gang Of Four，江湖人称四人帮。指的是Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides四人。\n\n### 3.3设计模式分类\n设计模式一共有23种，分为三种类型\n1. 创建型模式(5种)：\n* 抽象工厂模式(Abstract Factory Pattern)\n* 单例模式(Singleton Pattern)\n* 原型模式(Prototype Pattern)\n* 建造者模式(Builder Pattern)\n* 工厂模式(Factory Pattern)\n\n2.结构型模式(7种)：\n* 适配器模式(Adapter Pattern)\n* 桥接模式(Bridge Pattern)\n* 装饰器模式(Decorator Pattern)\n* 组合模式(Composite Pattern)\n* 外观模式(Facade Pattern)\n* 享元模式(Flyweight Pattern)\n* 代理模式(Proxy Pattern)\n\n3.行为型模式(11种)：\n* 模板模式(Template Pattern)\n* 命令模式(Command Pattern)\n* 访问者模式(Visitor Pattern)\n* 迭代器模式(Iterator Pattern)\n* 观察者模式(Observer Pattern)\n* 中介者模式(Mediator Pattern)\n* 备忘录模式(Memento Pattern)\n* 解释器模式(Interpreter Pattern)\n* 状态模式(State Pattern)\n* 策略模式(Strategy Pattern)\n* 职责链模式(Chain of Responsibility Pattern)\n","categories":["从零开始","从零开始设计模式"]},{"title":"从零开始制作游戏-第零章","url":"/2019/12/27/从零开始制作游戏-第零章/","content":"<Excerpt in index | 首页摘要>\n\n从零开始制作游戏\n\n<!-- more -->\n<The rest of contents | 余下全文>","categories":["从零开始","从零开始制作游戏"]},{"title":"代码规范整理","url":"/2019/12/01/15/","content":"\n在这里只选取一些我觉得可能比较容易被我们忽略的规范。\n\n# 编程规约\n## 一、命名风格\n首先是命名，用英文这种就不用说了。然后我们一般是在哪里需要命名呢？\n一般来说，我们的命名会出现在包、类名、方法名、参数名、成员变量、局部变量、常量\n\n接下来我们需要注意的是命名的风格，其实命名里有些是有约定形式的。如：测试类以Test结束，工具类util(**单数**)服务Service，数据层Dao，model里的VO、DTO、BO等。\n\nService/DAO层方法命名规约 \n\n1） 获取单个对象的方法用 get做前缀。 \n\n2） **获取多个对象的方法用 list做前缀，复数形式结尾如：listObjects。** \n\n3） 获取统计值的方法用 count做前缀。 \n\n4） 插入的方法用 save/insert做前缀。 \n\n5） 删除的方法用 remove/delete做前缀。 \n\n6） 修改的方法用 update做前缀。 \n\n## 二、常量定义\n常量的分类：CacheConsts、ConfigConsts等\n\n常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。\n\n## 三、代码格式\n主要是换行的使用，{}的使用，什么时候应该用空格。\n\n主要注意的几点：\n\n1） 注释的双斜线与注释内容之间有且仅有一个空格。 \n\n2） 换行：**不要在逗号前换行，第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进**。 \n\n## 四、OOP规约\n1） equals，老生常谈的。**另外不同类型不要用**。Integer 的比较也值得注意，\n\n2）【强制】序列化类新增属性时，请不要修改 serialVersionUID字段，避免反序列失败；如果完 全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID值。 说明：注意 serialVersionUID不一致会抛出序列化运行时异常\n\n3） 空指针，索引越界。使用前多考虑一下要不要判断\n\n4） 类编写顺序，**公有方法或保护方法 > 私有方法 > getter/setter**，这个感觉因人而异，我个人看方法就喜欢拉到下面。这样比拉到特定位置方便。\n\n5） 循环体内，字符串的连接方式，使用 StringBuilder的 append方法进行扩展，老生常谈。 \n\n6） 如果不允许外部直接通过 new来创建对象，那么构造方法必须是 private\n\n## 五、集合处理\n1） 只要重写 equals，就必须重写 hashCode。 原因：**因为 Set存储的是不重复的对象，依据 hashCode和 equals进行判断**\n\n2） 集合转数组的方法，必须使用集合的 toArray(T[] array。**工具类 Arrays.asList()把数组转换成集合，不可使用集合add/remove/clear方法**。Arrays.asList体现的是 适配器模式，只是转换接口，后台的数据仍是数组\n\n3） 【强制】泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用 add方 法，而<? super T>不能使用 get方法，作为接口调用赋值时易出错。 \n\n说明：扩展说一下 PECS(Producer Extends Consumer Super)原则：\n\n第一、频繁往外读取内容 的，适合用<? extends T>。\n\n第二、经常往里插入的，适合用<? super T>。 \n\n4） 不要在 foreach循环里进行元素的 remove/add操作。remove元素请使用 Iterator 方式，**如果并发操作，需要对 Iterator对象加锁**\n\n5） 集合初始化时，指定集合初始值大小\n\n6） **高度注意 Map类集合 K/V能不能存储 null值的情况**\n\n## 六、并发处理\n\n1） **线程资源必须通过线程池提供，不允许在应用中自行显式创建线程**。减少在创建和销毁线程上所消耗的时间\n\n2） **线程池不允许使用 Executors去创建，而是通过 ThreadPoolExecutor的方式**\n\n3） **SimpleDateFormat 是线程不安全的类，一般不要定义为 static变量，如果定义为 static，必须加锁，或者使用 DateUtils工具类**\n\n如果是 JDK8的应用，可以使用 Instant代替 Date，LocalDateTime代替 Calendar， DateTimeFormatter代替 SimpleDateFormat\n\n4） 【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加 锁，要么在数据库层使用乐观锁，使用 version作为更新依据。 说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次 数不得小于 3次。\n\n## 七、控制语句\n1） 参数校验\n\n## 八、注释规范\n1） 类、类属性、类方法的注释必须使用 Javadoc规范，使用/**内容*/格式\n\n## 九、其他\n1） 【强制】事务内发MQ消息 说明：如果处理业务逻辑后，要发送MQ消息，那么发送MQ消息的代码要放到业务逻辑事 务底部，避免消息同步问题。\n2） 【强制】禁止for循环调用接口和查询数据库 说明：For循环内禁止RPC调用或数据库查询，此问题会导致功能性能低下。\n\n# 异常日志\n## 一、异常处理\n1） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。正 例：使用 JDK8的 Optional类来防止 NPE问题。 \n\n2） **业务异常**打印message和error code，不允许打异常栈 说明：避免无用的栈信息过多，占满磁盘空间\n\n## 二、日志规约\n1） 避免重复打印日志，浪费磁盘空间，务必在 log4j.xml中设置 additivity=false。正例： <logger name=\"com.taobao.dubbo.config\" additivity=\"false\">\n\n# 单元测试\n1）  【强制】好的单元测试必须遵守 AIR原则。 说明：单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上， 却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。\n \n  A：Automatic（自动化）\n \n  I：Independent（独立性） \n \n  R：Repeatable（可重复） \n\n2） 对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级 别，一般是方法级别。 \n\n3） 【推荐】编写单元测试代码遵守 BCDE原则，以保证被测试模块的交付质量。 \n\n B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。 \n\n C：Correct，正确的输入，并得到预期的结果。 \n\n D：Design，与设计文档相结合，来编写单元测试。 \n\n E：Error，强制错误信息输入（如：非法数据、异常流程、非业务允许输入等），并得到 预期的结果\n\n\n3） 【推荐】和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者 对单元测试产生的数据有明确的前后缀标识。 \n\n# 安全规约\n1） 【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。 \n\n2） **【强制】用户请求传入的任何参数必须做有效性验证** 。 \n\n3） 【强制】表单、AJAX提交必须执行 CSRF安全验证。 \n\n说明：CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在CSRF漏 洞的应用/网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户不知情 的情况下对数据库中用户参数进行相应修改。\n\n4） 【强制】order controller 层 调用service 必须传用户ID信息 （防止越权） \n\n# MySQL数据库\n1） MySQL在 Windows下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、 表名、字段名，都不允许出现任何大写字母，避免节外生枝。 \n\n2） 【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。\n\n说 明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index的简称。 \n\n3） 【强制】小数类型为 decimal，禁止使用 float和 double。 \n说明：float和 double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确 的结果。如果存储的数据范围超过 decimal的范围，建议将数据拆成整数和小数分开存储。\n\n4） 【推荐】单表行数超过 500万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 \n\n5） 一般使用UTF-8字符集，涉及到特殊字符时使用UTF8MB4字符集 \n\n           UTF8：国码，无需转码，无乱码风险，节省空间 \n           \n           UTF8MB4：能存储4字节的Unicode 字符 \n\n6） 默认配置字段定义为NOT NULL并且提供默认值，除非有特殊需求提出审批 \n\n\n7） 【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是 ref级别，如果可以是 consts 最好。 \n说明： \n\n1. consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 \n\n2. ref 指的是使用普通的索引（normal index）。 \n\n3. range 对索引进行范围检索。\n\n8） 【强制】不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)是 SQL92定义的标准统计 行数的语法，跟数据库无关，跟 NULL和非 NULL无关。 \n\n9） 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。 \n\n说明：以学生和成绩的关系为例，学生表中的 student_id是主键，那么成绩表中的 student_id 则为 外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更 新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存 在数据库更新风暴的风险；外键影响数据库的插入速度。 \n \n# 工程规约\n\n1）  【强制】定义 GAV遵从以下规则： \n\n1. GroupID格式：com.{公司/BU }.业务线 [.子业务线]，最多 4级。 \n说明：{公司/BU} 例如：alibaba/taobao/tmall/aliexpress等 BU一级；子业务线可选。正例： com.taobao.jstorm 或 com.alibaba.dubbo.register \n\n2. ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。正 例：dubbo-client / fastjson-api / jstorm-tool \n\n3. Version：详细规定参考下方。 \n\n2） 【强制】二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变， 必须明确评估和验证，建议进行 dependency:resolve前后信息比对，如果仲裁结果完全不一致， 那么通过 dependency:tree命令，找出差异点，进行<excludes>排除 jar包。 \n\n\n3） 【推荐】在线上生产环境，JVM的 Xms和 Xmx设置一样大小的内存容量，避免在 GC 后调整堆 大小带来的压力。\n\n4） 【推荐】给 JVM环境参数设置-XX:+HeapDumpOnOutOfMemoryError参数，让 JVM碰到 OOM场 景时输出 dump信息。 \n\n说明：OOM的发生是有概率的，甚至相隔数月才出现一例，出错时的堆内信息对解决问题非 常有帮助。\n\n ","categories":["未定义"]},{"title":"程序员劝退，你真的要做程序员吗？【闲聊 第一期】","url":"/2019/10/09/14/","content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=70609551&cid=122329586&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>","categories":["未定义"]},{"title":"Maven基础知识","url":"/2019/09/14/13/","content":"<Excerpt in index | 首页摘要>\n\nMaven的简单使用\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### Maven生命周期\n\n![maven生命周期](https://www.runoob.com/wp-content/uploads/2018/09/7642256-c967b2c1faeba9ce.png)\n\n| 阶段          | 处理     | 描述                                                     |\n| :------------ | :------- | :------------------------------------------------------- |\n| 验证 validate | 验证项目 | 验证项目是否正确且所有必须信息是可用的                   |\n| 编译 compile  | 执行编译 | 源代码编译在此阶段完成                                   |\n| 测试 Test     | 测试     | 使用适当的单元测试框架（例如JUnit）运行测试。            |\n| 包装 package  | 打包     | 创建JAR/WAR包如在 pom.xml 中定义提及的包                 |\n| 检查 verify   | 检查     | 对集成测试的结果进行检查，以保证质量达标                 |\n| 安装 install  | 安装     | 安装打包的项目到本地仓库，以供其他项目使用               |\n| 部署 deploy   | 部署     | 拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程 |\n\n\n\n\n\n### GAV\n\n初次看到这个简称的时候还以为我看错了，确定不是Gay？\n\n\n\n其实GAV指的是groupId、artifactId、version\n\ngroupId：公司或者组织的唯一标志\n\nartifactId：项目的唯一ID，项目的模块\n\nversion：版本号\n\n```xml\n<parent>\n    <artifactId>maven-parent</artifactId>\n    <groupId>com.archon.example</groupId>\n    <version>0.1</version>\n</parent>\n<artifactId>maven-plugin</artifactId>\n<packaging>jar</packaging>\n```\n\n\n\n> 一般`artifact`（依赖包）的版本信息全部在`maven-parent`中声明\n\n\n\n### 排除重复GAV\n查找冲突：\n\n一种是pom文件目录下运行mvn dependency:tree，查看依赖关系树形结构。\n\n\n\n另一种是使用maven插件Maven Enforcer Plugin，执行maven命令 “validate”会打出日志告诉我们哪些jar包冲突。\n\n解决冲突：\nexclusions\n```xml\n<exclusions>\n    <exclusion>\n        <artifactId>spring-boot-starter-logging</artifactId>\n        <groupId>org.springframework.boot</groupId>\n    </exclusion>\n</exclusions>\n```\n\n\n\n### 构建jar\n\nmvn package\n\n\n\n### 跳过单元测试\n\n-DskipTests，不执行测试用例，但编译测试用例类生成相应的class文件至target/test-classes下。\n\n**-Dmaven.test.skip=true，不但跳过单元测试的运行，也跳过测试代码的编译。。**\n\n```\nmvn clean install -Dmaven.test.skip=true\n```\n\n\n\n### 使用Nexus搭建maven私有仓库\n\n[搭建私有仓库](https://www.jianshu.com/p/9740778b154f)\n\n","categories":["未定义"]},{"title":"Linux下日志排查的常用命令","url":"/2019/09/14/12/","content":"<Excerpt in index | 首页摘要>\n\n以前学习Linux的时候都是在瞎玩，没有真正去研究一些命令和命令的参数。现在就以生产日志查询的角度去学习一些基本的命令，需要什么就学什么。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n一般来说我们的命令都是这样的形式：command [options] [arguments]\n\noptions选项，arguments参数\n\n\n\n一般来说，生产的服务器我们都是通过跳板机去连接，而不能直接连接。\n\n### Firtst Step\n\n第一步就是连接跳板机，可以用工具，也可以直接在web上去连接。\n\n### Start\n\n接着我们就是找到对应日志的位置。*如果你不知道日志存储的位置，在Java项目中，都会配置自己的日志存储路径，如果是用log4j2的话，你应该可以到对应的配置文件，找到日志存储的位置。*\n\n如果你不懂命令，或者想了解更多，可以来这里：[Linux命令手册](https://man.linuxde.net/)\n\n\n\n然后就是开始一顿操作了\n\n```\npwd: print working directory 首先我们可以查看自己所在的当前路径，当前目录\nwhereis: 当然你也可以通过这个命令查找文件所在位置\n\ncd: change directory 接着进入到对应的目录下，在这里可以使用绝对路径|相对路径\n\toptions:\n\t\t. 当前目录\n\t\t.. 上级目录\n\t\t~ 用户主目录\n\t\t- 返回此目录之前的所在的目录\n\t\t/ 根目录\n\t\t\nls: list directory content 如果我们不知道当前目录下有什么，我们就可以用这个命令列出\n\toptions:\n\t\t-a 隐藏的文件也会列出来\n\t\t-l 所有输出信息用单列的格式输出，而不是多列，一般我们用这个就看看文件的修改时间、大小\n\t\t-t 最近修改的文件显示在最上面，这个还是很有用的，但文件比较多的时候好用。\n\t\t--color=auto 列出文件并标记颜色分类\n\t\t\n```\n\n### Importance\n\n当我们定位到日志目录时，这才是真正开始查询日志。vi这个是比较特殊的，所以先讲。虽然我们查询日志的时候几乎用不到这个命令，这个命令是用于编辑文件的。在linux中用的是vim，我也是用这个。\n\n要想使用vi，首先就需要了解其工作模式：命令模式、编辑模式、末行模式\n\n![vim](https://www.runoob.com/wp-content/uploads/2014/07/vim-vi-workmodel.png)\n\n\n\n基本上了解上面的一些就ok，另外就是如何编辑和退出。当一开始进入的时候是**命令模式**，接着我们可以按下键盘上的**iao**任意一个，就会进入到编辑模式了。编辑完后，我们可以看**ESC**回到命令模式，最后输入**：**进入到末行模式，也就是上图的底线命令模式，最后输入*!wq!**保存退出即可。\n\n```\n:! 强制\n:w 保存\n:q 退出\n:q!强制退出\n:wq!\n```\n\n\n\n---\n\n上面的简单了解先即可，接下来才是我们查询日志。在linux系统终端模式下，我们是没有图形界面去给你直接点开文件，一个个去浏览的。因此我们第一个问题就是：如果查看文件内容。上诉所讲的vi也是可以的，但是对我们来说使用太不友好了。下面就是我们用到的一些用于查看的命令。在学习之前我们可以先想一下我们有什么需求：首先我们希望可以去搜索关键字，其次最好颜色也像上面一样可以标记颜色，最后可以看看查询内容的上下文。Ok，下面你的问题都将会得到解答。\n\n#### grep\n\n**G**lobal search **R**egular **E**xpression(RE) and **P**rint out the line(全面搜索正则表达式并把行打印出来)\n\n\n\n```\ngrep/zgrep: \ngrep \"match_pattern\" file_name 在文件中搜索一个单词\n\toptions:\n        --color=auto 标记匹配颜色(这个很舒服啊，这样我们就能快速找到我们要查询的内容了)\n        -E 使用正则表达式(这个应该和上面的搜索单词区分)\n        -c 统计单词出现的次数\n        -n 输出匹配字符的行数(终于等到你，这个应该会很有用吧)\n        -i 忽略大小写\n        -A 除了显示符合范本样式的那一行之外，并显示该行之后的内容。\n        -B 除了显示符合范本样式的那一行之外，并显示该行之前的内容\n        -C 除了显示符合范本样式的那一行之外，并显示该行前后后的内容\n\n```\n\n这个ABC可谓是神器，因为有时候我们不仅是想看到符合的内容，**还想看到其上下文，这时候就得借助ABC选项了。**\n`例如：grep \"aes-256-gcm\" shadowsocks.log -A 2`\n\n#### tail\n\n​    tail file (**显示文件file的最后10行**)\n​    tail +20 file (显示文件file的内容，**从第20行至文件末尾**)\n​    tail -c 10 file （显示文件file的最后10个字符）\n\n```\ntail:\n\toptions:\n\t\t-f 显示文件最新追加的内容\n```\n\n**显示文件最新追加的内容**，这个选项在外面启动项目的时候很方便，因为我们启动的项目的时候日志是一点点打印的，这个时候我们就看到日志一点点输出，不用每次tail查看后面的10行。\n\n```\ntail:\n\toptions:\n\t\t-n 输出文件的尾部N（N位数字）行内容\n```\n\n有时候我们并不想从第几行开始到尾部，也不下追加内容显示，我们只想显示后面的多少行内容。那么这个选项就很好的满足了你的需求。\n\n#### head\n\n```\nhead:\n\toptions:\n\t\t-n 输出文件的头部N（N位数字）行内容\n```\n\n其实-n的这个选项，基本上就是用来代码`行`的，在tail和head命令中我们发现他们是一样的效果。\n\n#### cat/zcat\n\n为了控制滚屏，可以按Ctrl+S键，停止滚屏；按Ctrl+Q键可以恢复滚屏。按Ctrl+C（中断）键可以终止该命令的执行，并且返回Shell提示符状态。\n\n管道： | \n\n#### more\n\n>  **more命令**是一个基于[vi](http://man.linuxde.net/vi)编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持vi中的关键字定位操作。more名单中内置了若干快捷键，常用的有H（获得帮助信息），**Enter（向下翻滚一行），空格（向下滚动一屏）**，Q（退出命令）。\n\n\n\n基本上上面所列出的命令已经足够我们查看日志了。\n\n---\n\n当然除了查看文件，我们可能还需要看一些进程\n\n#### top\n\n实时查看系统运行状态\n\n```\n-b：以批处理模式操作\n-c：显示完整的治命令\n-d：屏幕刷新间隔时间\n-I：忽略失效过程\n-s：保密模式\n-S：累积模式\n-i<时间>：设置间隔时间\n-u<用户名>：指定用户名\n-p<进程号>：指定进程(必备)\n-n<次数>：循环显示的次数\n```\n\n在top命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了-s选项， 其中一些命令可能会被屏蔽。\n\n输入top，然后按对应的键即可。**Ctrl+C停止太low了，试试按q直接退出。**\n\n```\nh：显示帮助画面，给出一些简短的命令总结说明\nk：终止一个进程\ni：忽略闲置和僵死进程，这是一个开关式命令\nq：退出程序\nr：重新安排一个进程的优先级别\nS：切换到累计模式\ns：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s\nf或者F：从当前显示中添加或者删除项目\no或者O：改变显示项目的顺序\nl：切换显示平均负载和启动时间信息\nm：切换显示内存信息\nt：切换显示进程和CPU状态信息\nc：切换显示命令名称和完整命令行\nM：根据驻留内存大小进行排序\nP：根据CPU使用百分比大小进行排序\nT：根据时间/累计时间进行排序\nw：将当前设置写入~/.toprc文件中\n```\n\n#### ps\n\n```\nps -aux是以BSD方式列出当前全部运行的进程\n\nps -ef是以system v方式列出当前全部运行的进程\n\n```\n\n上面两个命令虽然显示的都是当前全部运行进程，但是ps -aux列出的条目更多\n\n```\n\n\nps -axj 列出守护进程\n\nps -ef | grep init 查找当前运行进程中的的init进程\n\nps -l 列出ps中的进程操作命令及编号，例如kill等\n```\n\n**ps -ef | grep init 查找当前运行进程中的的init进程**\n\n\n\n#### kill\n\n用来删除执行中的程序或工作，生产上要是删除了，怕是要跑路了？\n\n```\n-a：当处理当前进程时，不限制命令名和进程号的对应关系；\n-l <信息编号>：若不加<信息编号>选项，则-l参数会列出全部的信息名称；\n-p：指定kill 命令只打印相关进程的进程号，而不发送任何信号；\n-s <信息名称或编号>：指定要送出的信息；\n-u：指定用户。\n```\n\n#### 上传下载文件\n\n有时候你也可能需要下载文件，可以用下面两个命令。\n\n```\nrz 上传文件命令\nsz 下载文件到本地\n```\n\n\n\n### 总结\n\n上面的命令只是帮助我们查询，一般来说，我们去查询的时候，先定位一下是哪一个服务器上出了问题，连接上对应服务器，找到对应的日志存储位置。\n\n\n\n**接着通过唯一的id去查找，找到对应的id相关信息之后，通过该id所在的线程id去查找。**\n\n\n\n日志的打印格式(**Pattern**)可以在log4j2.xml配置文件下找\n\n```\n2019-08-31 00:00:00.414 ERROR [SimpleAsyncTaskExecutor-1] 1e1111c8-1bf4-4e2c-af43-db0bda2ba85c 后面的没有列出来\n\n日期——线程名——线程ID\n```\n\n**在这里要看是异步线程，还是同步线程，还是多线程，不然你可能通过该线程id找不到对应的日志错误信息。如果没有线程id，那就只能通过线程名称了**\n\n其次，如果是mq的消息，你可以先找到mq消费的**messageId**，接着通过该messageId找到更多的信息。\n\n\n\nlog4j2.xml日志文件大小达到一定的数量，你就只能到压缩文件查看了，用`zgrep`命令。不然你可能一直很奇怪为什么查不到信息。\n\n\n\n**坑：当遇到一个错误信息的时候，你可以看看代码，然后通过版本控制器看看是不是最近有人改了代码，然后找出来暴打问一顿。（笑）**","categories":["未定义"]},{"title":"IntelliJ IDEA的常用设置","url":"/2019/09/14/11/","content":"<Excerpt in index | 首页摘要>\n\n这一篇里主要是总结一下我在IDEA中的一些基本使用。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n在使用之前，我都会习惯性的设置一下编码为UTF-8，并且设置一下字体。\n\n编码设置：Setttings——Editor——Encodings(注意下面有个properties文件的默认编码设置，这里也需要设置一下)\n\n字体设置：Setttings——Editor——Fonts(我习惯用的是Source Code Pro和Consolas)\n\n背景设置(可选)：Setttings——Appearance —— Background Image(IDEA比Eclipse友好的地方之一，IDEA可以轻松的设置背景图片，这样我们写代码也有动力，并且透明的背景对我来说比较舒服。)\n\n---\n\n\n\n### 其他设置\n\nSetttings——Editor——General下有几个不错的设置\n\n* Setttings——Editor——General——Change font size(Zoom)  with Ctrl+Mouse Wheel (通过Ctrl+鼠标控制字体大小，这样当我们通过IDEA给别人演示的时候，就可以很方便调整字体大小\n* Setttings——Editor——General——Appearance——Show method separator一个让我觉得很舒服的设置，这个设置是给方法进行添加一条分割线，不占用行数。\n* Setttings——Editor——General——Auto Import——然后勾选Add unambiguous imports on the fly以及Optimize imports on the fly(快速导入和删除无用的包)\n\n\n\n### 快捷键\n\n一些简单的复制粘贴就不介绍了，下面是一些我用的比较多，也比较好用的快捷键。快捷键无非就是按键的组合，一般是CTRL、Alt、SHIFT和其他按键的组合。\n\nCtrl + B\t进入光标所在的方法\n\nCtrl + Alt + B\t在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口\n\nCtrl + D\t复制光标所在行 或 复制选择内容\n\nCtrl + E\t显示最近打开的文件记录列表 \n\nCtrl + F\t在当前文件进行文本查找\n\nCtrl + Shift + F\t根据输入内容查找整个项目 或 指定目录内文件\n\nCtrl + G\t在当前文件跳转到指定行处\n\nCtrl + H\t调用层次\n\nCtrl + I\t选择可继承的方法\n\nCtrl + O\t选择可重写的方法\n\nCtrl + R\t在当前文件进行文本替换\n\nCtrl + Shift + R\t根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件\n\nCtrl + Y\t删除光标所在行 或 删除选中的行，这是和Eclipse不太一样的\n\nCtrl + +\t展开代码\n\nCtrl + -\t折叠代码\n\nCtrl + /\t注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 \n\nCtrl + Shift + /\t代码块注释 \n\nAlt + Enter\tIntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同\n\nAlt + Insert\t代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等\n\nShift + 左键单击\t在打开的文件名上按此快捷键，可以关闭当前打开文件 \n\nCtrl + Shift + Alt + C 复制参考信息，IDEA中复制整个类的路径\n\nCtrl + Shift + Alt + V\t无格式黏贴 \n\nCtrl + 左方向键\t光标跳转到当前单词 / 中文句的左侧开头位置\n\nCtrl + 右方向键\t光标跳转到当前单词 / 中文句的右侧开头位置\n\nCtrl + 前方向键\t等效于鼠标滚轮向前效果\n\nCtrl + 后方向键\t等效于鼠标滚轮向后效果 \n\nAlt + 左方向键\t用此快捷键就可以在子视图中切换\n\nAlt + 右方向键\t用此快捷键就可以在子视图中切换\n\nCtrl + Alt + 左方向键\t退回到上一个操作的地方\n\nCtrl + Alt + 右方向键\t前进到上一个操作的地方\n\nCtrl + Shift + 左方向键\t标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句\n\nCtrl + Shift + 右方向键\t光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 \n\nShift + 滚轮前后滚动\t当前文件的横向滚动轴滚动(用鼠标的时候也可以很骚)\n\n#### Debug\n\nF7\t在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中\n\nF8\t在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内\n\nF9\t在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上\n\n(Tip：在debug模式下Debugger栏目下有个像计算器的图标，那就是`Evaluate Expression`，一个可以动态执行代码的工具，我基本上用来查看变量)\n\n另外在debug模式下，还可以动态改值。\n\n推荐文章[IntelliJ IDEA Windows And Linux Keymap简体中文](https://blog.csdn.net/qwfys200/article/details/81835845 )\n\n### IDEA Plugins\n\nAlibaba Java Coding Guidelines 代码规范\n\nGrep Console 控制台多彩\n\nLombok\n\nMyBatisCodeHelperPro\n\nRestfulToolkit 可以根据URL跳转到对应的方法(全局快捷搜索：*Ctrl  \\\\* )\n\nSonarLint \n\n\n","categories":["未定义"]},{"title":"收藏爱好者-Don't repeat yourself","url":"/2019/09/14/10/","content":"<Excerpt in index | 首页摘要>\n\n整理不错的书籍、教程、软件和插件\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n## 书籍\n* [Java编程书籍收集分享](https://github.com/RongleXie/java-books-collections#java)\n* [经典技术书籍推荐](https://github.com/royeo/awesome-programming-books)\n* [计算机-科技-数学](https://github.com/qqqil/books)\n* [《On Java 8》中文版，又名《Java编程思想》 第5版](https://github.com/LingCoder/OnJava8)\n* [ruanyf-互联网上的免费书籍](https://github.com/ruanyf/free-books)\n\n## 资源整理\n* [C 语言资源大全中文版](https://github.com/jobbole/awesome-c-cn)\n* [C++ 资源大全中文版](https://github.com/jobbole/awesome-cpp-cn)\n* [Java资源大全中文版](https://github.com/jobbole/awesome-java-cn)\n* [成为专业程序员路上用到的各种优秀资料、神器及框架](https://github.com/stanzhai/be-a-professional-programmer)\n\n## Java教程\n* [Java 虚拟机底层原理知识总结](https://github.com/doocs/jvm)\n* [设计模式Java版](https://github.com/quanke/design-pattern-java-source-code)\n* [Java学习+面试指南](https://github.com/Snailclimb/JavaGuide)\n* [互联网 Java 工程师进阶知识](https://github.com/doocs/advanced-java)\n* [纯洁的微笑-spring-boot-examples](https://github.com/ityouknow/spring-boot-examples)\n* [JeffLi1993-spring boot 实践学习案例](https://github.com/JeffLi1993/springboot-learning-example)\n* [rhwayfun-Spring Boot工程实践](https://github.com/rhwayfun/spring-boot-learning-examples)\n* [Foreveriss-springboot用法和与各种框架、组件等结合使用](https://github.com/Foreveriss/SpringBoot)\n* [程序猿DD-Spring Boot基础教程](https://github.com/dyc87112/SpringBoot-Learning)\n* [史上最简单的Spring Cloud教程源码](https://github.com/forezp/SpringCloudLearning)\n* [程序猿DD-Spring Cloud基础教程](https://github.com/dyc87112/SpringCloud-Learning)\n\n## Python教程\n* [Python - 100天从新手到大师](https://github.com/jackfrued/Python-100-Days)\n\n## 轮子\n* [16 个有用的的 Java 工具类](https://juejin.im/post/5d4a25b351882505c105cc6e)\n* [Java工具包](https://gitee.com/loolly/hutool)\n* [Spring Cloud 微服务开发核心包](https://gitee.com/596392912/mica)\n\n## 面试\n* [程序汪-面试题](https://mp.weixin.qq.com/s/1D8RY_j4zbvo7iKot5GoTQ)\n- [2019年9月百度面试题分享（第一部分](https://mp.weixin.qq.com/s/S1fH7AGstrCoOeRXekYQOw)\n- [2019年9月百度面试题分享（第二部分](https://mp.weixin.qq.com/s/hdTkM1UkOoRXpZsMtUdTug)\n- [2019年9月京东面试题分享(实习生秋招级别)](https://mp.weixin.qq.com/s/RgvVPNzqFY7q07mmEe9T5A)\n\n\n## 其他\n- [idea插件](https://juejin.im/entry/5c4f9f9d6fb9a049a5714c8c)\n\n- [源码分析](https://github.com/stalary/Source-code-analysis)\n\n- [源码核心分析](https://github.com/JeffLi1993/jvm-core-learning-example)\n\n- [性能测试用例](https://www.cnblogs.com/xiufengchen/p/10835040.html)\n\n- [源码分析](https://github.com/seaswalker)\n\n- [jdk 8 lambda](https://juejin.im/post/5beb8e3ff265da61273cf141?utm_source=gold_browser_extension)\n\n- [springcloud demo](https://github.com/forezp/SpringCloudLearning?utm_source=gold_browser_extension)\n\n- [Spring Cloud 中文索引](http://springcloud.fun/)、[Springcloud中文网](https://www.springcloud.cc/)\n\n- [Java集合](https://mp.weixin.qq.com/s/TMTmpL6iA6Ol0T57yW5QJA)\n\n- [那些年，我们见过的 Java 服务端乱象](https://mp.weixin.qq.com/s/I_pfVRYLv5hlBA2JgAQxEQ)\n----\n\n\n**温馨提示**：名称以字母的顺序排列。\n\n## 软件\n\n* [Bandizip](https://www.bandisoft.com/bandizip/) 轻量级、快速且整合程度较高的解压缩软件\n* [Chrome](https://www.google.cn/chrome/index.html) 快速、轻松且安全地使用网络的浏览器\n* [Cmder](https://cmder.net/) 美观、强大的终端工具\n* [Git](https://git-scm.com/downloads) 分布式版本控制器客户端\n* [IntelliJ IDEA](https://www.jetbrains.com/idea/download/#section=windows) 智能、强大的Java IDE\n* [Navicat](https://navicat.com.cn/products) 强大的跨平台数据库管理和设计工具\n* [Postman](https://www.getpostman.com/downloads/) 强大好用的API开发工具\n* [Potplayer](http://potplayer.daum.net/?lang=zh_CN) 播放器\n* [Pycharm](https://www.jetbrains.com/pycharm/download/#section=windows) 智能、强大的Python IDE，甚至可以教你学Python\n* [RedisDesktopManager](https://redisdesktop.com/pricing) Redis可视化工具\n* [Robo 3T](https://robomongo.org/download) MongoDB可视化工具\n* [Snipaste](https://zh.snipaste.com/) 截图+贴图的好工具\n* [Teamviewer](https://www.teamviewer.cn/cn/) 远程控制软件\n* [TortoiseSVN](https://tortoisesvn.net/downloads.html) Subversion版本控制系统客户端\n* [Typora](https://typora.io/#windows) Markdown编辑，复制表格内容甚至可以帮你自动生成md语法\n* [Visual Studio Code](https://code.visualstudio.com/Download) 不仅仅是编辑器\n* [WinRAR](http://www.winrar.com.cn/download.htm) 一直还生存的老牌压缩软件\n* [Xmind](https://www.xmind.cn/) 思维导图\n* [Xshell](https://www.netsarang.com/en/xshell-download/) 强大的安全终端模拟软件\n* [Xftp](https://www.netsarang.com/en/xftp-download/) sftp和ftp文件传输客户端\n* [向日葵](https://sunlogin.oray.com/personal/download/) 远程控制软件\n\n\n## 插件\n* [Octotree](http://www.cnplugins.com/devtool/octotree/download.html) 浏览器阅读Github的好帮手\n* [掘金](https://juejin.im/extension/) 每天推荐一点，每天学一点。\n\n----\n\n## 开发知识\n\n* **Java基础：Java类初始化顺序，集合区别和原理，反射机制，线程安全，异常处理**\n\n* **Spring：starter使用，Configuration使用，Spring异常处理，Aop原理，缓存的刷新原理，事务，SpringBoot自动装配**\n\n* **RabbitMQ：熟悉消息的发送、接收、死信队列、消息持久化、管理后台补推消息、发送确认机制**\n\n* **Feign：异常处理(远程调用异常怎么办？)熟悉FB4的异常处理机制**\n\n* **Consul：熟悉服务的注册与发现**\n\n* **数据同步框架：数据同步的配置、重试机制**\n\n* **HTTP协议、Restful**\n\n* **并发控制 ，数据库锁，java锁，乐观锁，悲观锁，等等锁**\n\n* **幂等，操作互斥，多线程**\n\n### 开发规范\n\n* 单元测试：Mock\n\n* **开发规范：熟悉开发规范、设计模式、《阿里巴巴Java开发规范手册》**\n\n### 数据库\n\n* MyBatis：熟悉分页插件PageHelper，会使用分页。(tkMyBatis)\n\n* MySQL：联表、explain、索引、CRUD\n\n* Redis：key命名规范，基本数据类型、基本命令的使用，对String类型CRUD，**分布式锁的使用**\n\n* Mongo：知道简单的查询命令","categories":["未定义"]},{"title":"毕业后工作的日子","url":"/2019/08/17/9/","content":"<Excerpt in index | 首页摘要>\n\n毕业后，我开始了新的生活和工作，一切都走上了另一个方向。我有时候会怀念那些陪伴我的朋友，也会怀念和我女朋友在校园时的自在与闲情(在这里我就称她为Audrey吧，这是她的ID)。毕业后，少了少年遐想的时光，少了恬静淡雅的日子，每天只是在工作工作，不过幸运的是Audrey一直陪在我身边。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n毕业后，先说说工作吧。工作后压力还是挺大的，因为要开始挣钱养家了，还有就是技术上的压力。工作困扰的地方是要了解公司的业务逻辑，公司的业务逻辑非常的复杂，模块也非常的多，有时候一个任务下来我看了和问了很久才知道做什么。工作了一段时间后，也渐渐了解了公司的一些技术，这段时间应该是我技术的一个转折吧，我了解和学习到了很多新的技术，但同时也让我感到了危机。在公司里基本上用的都是别人已经搭建好的框架和技术，而我们只是在别人封装的基础上使用。最近的一段时间里，让我感受到了，我做了那么多任务其实技术上并没有提升，我只不过是在写一些简单的CRUD罢了。\n\n工作后一天的时间过的很快，每天一睁开眼就是上班了，中午吃个饭就是睡觉了，晚上回来的时候已经很晚了，做个饭吃完休息一下又差不多睡觉了。我没有了像以前在学校的日子，可以有很多时间做自己喜欢的事，可以有很多时间专心做一件事情。我觉得毕业后最大的改变就是不能专心做一件事情吧，无论是看书还是写代码，我没有像以前一样的有很长的一段时间专心去做，我所拥有的是零碎的时间。不过还好，我尽力在零碎的时间让自己专心和投入，这样的学习模式对我才是效率最大的。\n\n### 人最大的幸运就是有能力解决遇到的问题\n\n*每个人都应该找到一件，每天能坚持并且对生活或工作有溢的事情。人应该每天提高自己，而不是说我这段时间要很努力，在一段时间内努力很累，而每天努力一点点不会那么累。人最大的幸运就是有能力解决遇到的问题。——AkaneMurakawa*\n\n工作后看到了很多牛逼的人，也认识了一些技术大佬。我的导师就是一位很强很厉害的人，我非常的佩服他。一开始很迷茫，不知道学什么技术，因为我们使用的都是别人封装好的技术。后来看了网上的一些文章，我也渐渐明白了应该多去看看底层的东西，这些东西并不是我看一遍两遍就能够领悟的。我明白了要去做什么，内心也没有了一开始的迷茫。一个人有方向才会有动力，我会每天坚持去学习这些知识。\n\n目标：学习和了解Java编程思想、JVM、数据结构、设计模式、算法导论、计算机组成原理、网络技术、SpringBoot、SpringCloud。\n\n工作后基本的情况就是这样，有一开始迷茫不适应，也有后来慢慢找到了一些方向，也许这个方向不一定是对的，但是努力每天提高自己，当自己遇到问题的时候，有能力解决就是一件开心的事情，你也会感谢那个每天坚持和努力一点点的自己。\n\n我的亲人都觉得我很自觉，听话懂事。我不过是想改变，但是我的改变是付出行动，而不是嘴上的抱怨，我也会抱怨可是我还是依然努力的去寻找和付出。我的自律并不是我无趣，我只是努力去付出来获得我更多的自由，我努力的去寻找快乐而对自己有溢处的事情。\n\n我大学的同学说过我，我要是有你这自学能力，我就不用交钱去培训机构了。\n\n我的舍友有一天喝醉了打电话给我，说：景哥，我真的好想你，想不到大家四年就这么分别了。我在大学里最佩服的就是你，你的学习能力很强，你很自觉，有责任感。\n\n我听到这句话内心很感动，在回忆中也释怀了。我自学能力也不强，在学习的过程中我也觉得枯燥无聊，不同的是我在寻找乐趣，我努力去了解编程语法后面的编程故事和历史，而这些也由于我的性格使然让我产生了兴趣。一开始的时候，我也学不懂，很多知识看了一遍并没有记住，有些东西看了很多遍也没记住。我也怀疑自己，不自信，也努力到找不到方向。后来在2017年的时候，我开始写博客，我把自己学习和生活的东西都整理和记录下来。我给自己定个目标，静下心来，留住那些一闪而过的想法。\n\n*有一些东西，你只有去留住它，它才不会消失。*\n\n---\n\n### 和Audrey的日子\n\n工作的吐槽就大概是这样了，接下来说说毕业后工作的生活。\n\n我的生活基本上是由Audrey组成的，我们一开始住在公司提供的免费房子里。这里环境非常的差，每天很多油烟，缺少阳光，空气不足，基本上我们回来都要靠开空调去除里面的热气。但是一开始我们并没有那么多的钱，我们也想攒钱，所以虽然我们内心很抱怨可是还是接受继续住在这里。\n\n虽然这里环境很差，可是我们能每天在一起就是很幸福的一件事情。\n\n*幸福就是喜欢的人在身边。*\n\n我们有时会做一顿好吃的菜犒劳自己，我也在Audrey的指导下开始有点会做菜，她总是会好多我意想不到的菜，还会告诉我为什么这样做，这对于我这种喜欢钻牛角尖、刨根问底的人真的是一件享受的事情。\n\n我们会一起跟朋友去外面走走，看看外面的世界。\n\n我们会一起待在房子里，选一部好看的电影。\n\n我们会一起去逛超市，一起想等下要吃的菜。\n\n我们会一起聊聊工作的事情，谈谈各自的困扰。\n\n终于在八月份的时候，我们搬了新家，买了冰箱，买了很多好吃的东西把冰箱塞的满满的。生活慢慢变成了我们向往的日子。\n\n可是搬家的时候，我们却还争吵了一次。因为搬家的时候，我们没有考虑到Audrey已经很累了，然后Audrey在旁边休息了却不帮我，也不叫我休息，而我内心更多的是想早点搬完再休息。于是我就生气了，说了气人的话，因为我希望她也能多站在我角度上关心我。而Audrey也由于我的胡乱发脾气也生气了，她本身没有错而我责怪了她，最后就是我们大吵了一架。\n\n吵架的过程，其实本身是因为一些小事，可是我每次都在一直争执，因为我内心觉得这些事情都是类似的，我并不希望它一直发生，我希望避免它。所以我每次都希望我们之间能够很好的沟通和达成一个共识。但最后的结果都是，大家因为对方的生气而生气，觉得对方怎么样不对，开始细数对方，但是有时候对方所做的只是生气后的一个失态。\n\n我希望我们都能够把这些说清楚，因为我不想我们以后生气会是因为以前对方怎么样而生气。可能本身这次的事情并没有理由生气，可是想到以前就会生气，这样实在不好。\n\n在今天8月17号的时候，本来该是开心的一天，可是我们却又大吵了一架。起因是Audrey约好了和朋友去逛街，而我当一个领包使者。在昨晚的时候，我问Audrey我们什么时候去，还有那个地方在哪里。可是她却告诉了我一个不确定的消息，说中午去，地方还不知道，明白再查。\n\n我本身并不想干涉她，所以也想由她自己决定。可是当今天要去的时候，她查了一下地方非常的远。其实远的话我并不是很在意，因为我们好不容易才去一次，但是我不开心的是她并没有提前去了解，还有一个误会的地方是我以为她没有和朋友商量大概几点去，我是一个做事想有把握的人，所以我就很生气她这样的行为。于是我向她抱怨了，而她也由于我生气而生气了，她觉得为什么我那么在意却不自己去安排，她觉得缺少了我的关心，而我却反过来责怪她。\n\n这次吵架也变得严重，就像我说的:*我希望我们都能够把这些说清楚，因为我不想我们以后生气会是因为以前对方怎么样而生气。可能本身这次的事情并没有理由生气，可是想到以前就会生气，这样实在不好。*\n\n我的内心也很委屈，可是我却不想道歉，最后看到她有些不开心了，我就主动哄了她。说实话，说是哄其实我嘴上和内心的态度其实并不好，我其实依然在生气，哄的结果是她依然继续生气，依然觉得我是错的。\n\n我开始回想以前的事情，开始觉得每一次都是自己最后主动哄她。可是我并不知道哪一次哄她才能够让她不生气，我也很怕有一天哄不回来她了，我也很害怕我哪一天失去了耐心，放弃了她，失去了她。事情在我的回想下变得糟糕了起来，我开始觉得自己委屈，觉得为什么每一次都是自己主动，为什么每一次都是自己妥协。我失去了耐心，不想再哄她，内心也真正的发起了脾气，而我并没有在思考她在想什么。\n\n我离开了我们住的地方，就这样漫无目的走着，我回想着以前的事情。我不知道我们在一起的意义是什么，我不知道为什么每一次错的都是我，为什么每一次吵架都是我在退步。吵架的缘由基本是我莫名的生气，可是我也需要包容。\n\n这一次吵架也升级到了顶点，我不再因为对方哪里做的不是我所期望的而生气。而是失去了耐心不想去做哪些未知的，不知道哄几次她才会开心的事情。就这样，我做了一次决定，我也希望她能哄我，哪怕是一点点的主动包容我都好。于是我提出了\"我们分了吧？\"。外面下着雨，我希望她来接我，看了一下消息她并没有回我，于是我害怕就打了电话，电话里的那头我听到了她很难过，于是冒着雨回去找了她，我又再一次的妥协了。可是我的内心还是在赌气，我还是希望她能够主动结束这次争吵。\n\n冷战，冷战，就这样一直冷战。我知道她也很委屈，可是我的内心告诉自己，如果这一次还是自己主动认错，那么就会永远这样下去。我也在思考我们在一起会不会是一个错误，我们的性格是不是本身就不合适，而她又喜欢我哪里呢。我所做的喜欢的很多她都不了解不喜欢没有兴趣，而在我心里这是一种孤独，在我心里也渴望她能够对我喜欢的东西产生兴趣，但这些都是不能勉强。我思考着为什么不能勉强我们却还坚持在一起呢。\n\n就这样，我选择了放弃，选择了等她挽留我，我已经没有了挽留她的动力。不是我不爱她，只是我不想爱的那么累了。\n\n最后，她挽留了我。而我，哭的一塌糊涂。\n\n这应该是我第一次提\"分手\"威胁她，最后我们并没有分手，气消了后，我也回想了自己的种种不对。首先是脾气不好，总是责怪她。其次是脾气很容易失控，本来很小的事情却争执很久，原因在前面说过了。还有就是总是觉得自己委屈，为什么每一次都是自己道歉。\n\n---\n\n*宝贝，我们会永远在一起的*\n\n在她主动挽留我的那一刻，我对以前的事情也释怀了。其实她也很爱我，也会为了我委屈自己。\n\n为了避免以后的再次争吵，每一次我也努力去思考和反省。\n\n首先，是有时候我有疑问，我提出的时候态度并不好，对Audrey生气了，而她觉得我责怪了她，导致了我们每一次的争吵。\n关于这一点，我会努力去控制自己的脾气，每一次说话的时候想想自己是不是说的太过分了，换一种幽默的方式。在内心形成一种约束，就像是我们做某些事情自己总会因为想到某些约束而冷静下来。比如：迟到。我们一想到迟到要被老师惩罚，可能还要被批评叫家长，我们就不敢迟到了。并且在这里声明迟到并不是一件好事，也不潇洒哦。\n\n其次，她有时候的行为和思考，令我这种性格的人并不喜欢，我喜欢有把握有安排，于是我就生气了。\n关于这一点，我会努力去了解她，并尝试帮她安排一些事情，让开心。但与此同时，我也希望她能够多了解我的性格，让我们的性格能够达成一种兼容的状态。\n\n再有，我们都觉得自己委屈，都死要面子。让我想起一句话\"不争馒头争口气\"，说实话今天吵架的时候饿了好久才吃东西，最后Audrey做了我爱吃的鸡蛋。\"不争馒头争口气\"其实有时候并不正确，在我看来人应该在提高自己的地方执着，而不是死要面子活受罪。在我看来，任何我们所坚持的东西并没有说绝对的正确，两个人在一起，就是要学会妥协、取舍，这才是我所认为正确的东西。可能你说坚持的并没有错，可是在两个人的时候就会有问题，所以需要调整。在爱的人面前，这些都可以不要。\n关于这点，在经过这一次Audrey主动结束这次争吵，她安慰我而我还一直责怪她，她并没有放弃的时候，我内心也更坚定她其实是超级超级爱我的。我会努力放下面子，大气一点，多理解和迁就她，两个人最重要的就是开心，我会放下以前所有对她的责怪和气话。我不能以男生的思维去要求她，本身女生就应该得到更多的疼爱，我也没有很委屈，男生就应该大气一点，这些都是小事情。\n\n---\n\n### TODO\n* 找到更多和Audrey一起做的事情\n* 更多的包容和关心Audrey\n* 未来，和Audrey结婚\n* 提高编程的基础知识，提高技术\n* 阅读书籍，提高自己的思维和修养\n* 努力成为自由职业者，有更简单自由的生活\n\n*宝贝，我爱你！*\n\n\n\n\n\n\n\n\n","categories":["未定义"]},{"title":"从编程思想中学Python","url":"/2019/07/21/8/","content":"<Excerpt in index | 首页摘要>\n\n人生苦短，我用Python。 \n编程的思想非常的伟大和奇妙，我把我所认为的编程思想写在了这里。这是我第一次教别人编程，笔记和思想上可能会有一些不足和错误之处，还望指正。老实说，如果真的想了解编程，我并不建议从Python开始学，并没有鄙视之意，而是因为这样你往往会忽略掉很多东西。我们学的不是语言，而是思想。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# Python3\npython是一门**动态**的**强类型解释性**编程语言\n\n\n### 关于编程需要知道的几个东西\n1. 编译器，解释器\n2. 编程语言都有自己的特性和语法，那这样的话编程语言就有分类。\n一种按强类型和弱类型，一种静态语言和动态语言，一种是编译型语言和解释型语言。\n3. 二进制，内存，引用(指针)(地址)\n\n### Python的解释器\n```shell\nPython 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\n```\n\n### Terminal / 终端 / shell\n用于执行命令 \n\n命令的格式：\n```\n命令 [参数可选] 目标(或者要执行的文件或目录)\n```\n**一些常用的命令**\n\n```\ncd: change directory\ncd ..\ncd .\ncd /\npwd: print working directory\ncls\nls [-a]\n\npython xxx.py\n\nmkdir\nrm -rf /* 删除根目录下的所有文件\ncat\nzcat\ngrep\ntouch\nvim\n```\n\nQ：文件和目录，文件夹的区别？\n\nQ：绝对路径和相对路径？\nA：绝对路径就是完整的路径，以根目录开始，而相对路径是相对于一个目录的路径。\n```\n绝对路径: /usr/bin/python3\n相对路径: ./path\n```\n\n---\n\n### 环境搭建\n1. python3下载(开发环境)\n2. 环境变量的配置\n\nQ: 为什么要配置环境变量\n\n\n### Pycharm的基本使用\n\n1. 设置编码和字体， Source Code Pro / Consola\n2. 其他可选设置：background，template，method separation\n3. 快捷键：CTRL+ZXCVAS/D/FR/G\n4. CTRL + SHIFT + ALT + C\n```\nD: duplicate\nF: found\nR: replace\nG: go to line\n```\n\n### Python入门第一个程序\n```python\n#!/usr/bin/python3\n \nprint(\"Hello, Python!\")\n```\n1. **设置编码**\n2. 编写程序\n\n**编写程序需要注意的东西**\n1. 命名规范，不可以使用**关键字**，不能以数字开头。注意：命名的规范不只是说变量的命名合法就可以了，可是有一定的规则，比如驼峰法。\n\n- [ ] setAge()\n- [x] set_age()\n- [ ] SetAge()\n\n2. 严格的缩进\n3. 注释，多行和单行注释\n```python\n'''\n注释的内容\n'''\n# 注释的内容\n```\n\n**代码规范**\n1. 比如变量的命名规则？函数的命名规则？文件的命名？\n看看别人大神是怎么写的，比如可以到github去查找python项目\n2. 模块的分布，比如说你不可能所有代码都写在一个文件，那你就需要按照一种规则是分布\n3. 符号和字母之间，后面要加空格，前面不用。\n```\n1. 类名风格是class ServerHealthCheck():\n2. 函数名风格是 def obtain_ip(self):\n3. 变量名风格是 self, base_url, port, tcp\n4. 文件名风格是 site_health.py\n```\n---\n\n### 变量和数据类型\n变量：用来存储和复用 ，有存储的空间(内容和地址)，还有类型。\n\n**Python常用的数据类型**\n```\nNumber\n    bool: True、False\n    int\n    float\n    complex\nStr\nList\nTuple\nSet\nDict\n```\n* 不可变数据（3 个）：Number、String、Tuple\n* 可变数据（3 个）：List、Dictionary、Set\nQ: 什么是可变，什么是不可变，使用的时候需要注意什么地方？比如函数传递参数的时候，是值传递，还是引用传递(地址传递，指针传递)？\n\nCRUD:增删改查(Create、Retrieve/Read、Update、Delete)\n\n首先要学会的是遍历，然后是查询\n### list []\n1. insert和append的区别\n2. del list[0] 和 list.remove() 和list.pop()区别？\n3. list.clear()\n\n### tuple ()\n和list的区别？不可以改变\n1.只可以访问\n\n### dict \\{key: value\\}\n1. 不允许有多相同的key，如果有则取最后一个\n2. key不能被修改，换句话说：**key只能是Number、String、Tuple**\n3. dict.keys()和dict.values()，使用的时候转换为list。\n```\nlist(dict.keys())\n```\n\n### set\n集合，说到集合其实我有想到了数学里面的集合，我们一般就是用来算并集，差集，交集之类的运算，在这里也是如此。\n1. **集合是无序不重复的， 所以每次输出结果都可能不同**\n2. set.add()和set.update())\n3. set.remove()和set.discard()的区别？注意：**set.remove()如果删除的内容不存在则会报错，而set.discard()不会**\n4. set.pop() 随机移除\n5. set.union() 并集\n6. set.intersection() 交集\n7. set.difference() 差集\n8. set.copy() 浅拷贝？Q: 什么是浅拷贝？什么是深拷贝?\n\n\n**内建函数(built-in)**\nQ: 那什么是内建函数？\nQ: 函数是怎么调用？两种方式？\n```\nprint('Hello World')\n\nstr_food = 'egg'\nstr_food.isdigit()\n```\n\n---\n\n### 运算符\n1. 算术运算符 +-*/% ** //...\n2. 比较运算符 == != >= <>...\nQ: == 和 = 的区别？\n3. 赋值运算符 = += -= %= ...\n4. 位运算符 & | ^ ~ << >>\n注: 位运算符是把数字看作**二进制计算**\n```\n1 & 1 = 1\n1 & 0 = 0\n\n0 | 1 = 0 如果前面是False，则后面不用判断了\n1 | 0 = 0\n```\n5. 逻辑运算符 and or not (&& | !)\n逻辑: bool，值是True和False\n6. 成员运算符 in 、not in\n7. 身份运算符 is 、is not\n\n**注意优先级，一般我们不去记，而是用()去使表达更清晰**\n\n---\n\n### 一些函数\n```\nprint()\ninput() 注: 如果想转为int，要用函数去转换， int(input(''))\ntype()\nlen()\nmax()\nmin()\n\n数学函数\n随机函数\nrange()\n```\n\n### 转义和格式化输出\nQ: 为什么要转义？\nA: 因为有时候我们不喜欢直接输出，而是按照某种格式输出\n```\n\\n\n\\t\n\\r\n...\n```\n**格式化输出**\n形式/语法:\n```\n('%?' % (告诉我?里的内容))\n\n%d\n%f\n%c\n%s\n\n%x\n%p\n%o\n0xffff \n```\n补充：这是旧式的字符串格式化，我们可以用另一个格式化，那就是我们新的`format()`函数\n```\n'{}, {}'.formate(x, y)\n```\nQ: 十六进制的作用?\nA: 简化二进制\n\n跨行编写\n```python\n方法1:\npara_str = \"\"\"这是一个多行字符串的实例\n多行字符串可以使用制表符\nTAB ( \\t )。\n也可以使用换行符 [ \\n ]。\n\"\"\"\n\n方法2:\npara_str = '测试1' + /\n           '测试2' + /\n           '测试3'\n```\n\n---\n\n### 条件控制和循环\nQ: 为什么需要这个？\nA: 有时候我们做一些事情需要判断才去做，所以要条件控制。而有时候可能会重复做一些事情，那么就需要循环。我们变量也是一个道理，有时候我们需要重复去使用，就会需要变量。\n```\ns = 3.14 * r * r\n我们不可能每次都去写3.14 * r * r\n```\n\n#### if\n语法:\n```\nif 条件表达式:\n    内容\n\nif-elif-else\n注意: 条件表达式不能是=，这是赋值，不是条件表达式。还要冒号(:)不能省略\n```\n注意: **if可以没有else，但是有else一定要有if。if里面可以嵌套**\n\nQ: 什么是嵌套？\nQ: if-else和if-elif的区别?\n\n#### 循环\n语法:\n```\n方法1\nwhile 条件表达式:\n    内容\nelse:(可选)\n\n\n方法2\nfor <variable> in <sequence>:\n    内容\nelse:(可选)\n```\n\n**有趣的设计**\n我们可以用一个flag去控制while，当满足条件的时候做什么或者不做什么\n\n**循环里几个有趣的关键字**\nbreak、continue、pass\n\n---\n### 迭代器和生成器\nQ: 什么是迭代器？\nQ: 为什么有迭代器？和for in 的区别是什么\niter():得到一个迭代器\nnext(迭代器):\n\n---\n### 函数\n函数其实跟我们变量或者循环一样，目的是减少重复性。\n\n语法:\n```\ndef 函数名(参数):\n    内容\n    return 可选返回值，默认是None\n```\n**注意return不一定是写在最后一行，随便你写在函数体什么位置。return的意义是结束函数并选择返回值**\n\nQ: 结束整个循环有哪些方式？\n```\n1. 设置flag，或者条件\n2. break\n3. 在函数里可以用return\n4. exit()\n5. ...\n```\n\n**函数参数**\n1. 必须值\n2. 关键字参数，其实就是说我们调用函数的时候指定参数名。\n```python\ndef printinfo( name, age ):\n   print (\"名字: \", name)\n   print (\"年龄: \", age)\n   return\n \nprintinfo(age=50, name='A')\n```\n3. 默认参数，因为有时候我们需要默认一些东西，比如一开始用户注册，有些东西是必填的，但是一开始用户可以选择填写，那我们就需要给一个默认值。\n4. 可变参数\n```python\ndef functionname([formal_args,] *var_args_tuple ):\n注: var_args_tuple是tuple\n\ndef functionname([formal_args,] **var_args_dict ):\n注: var_args_dict是dict\n\n*args, **kwargs\n\n```\n\n**匿名函数**\nlambda表达式\n```\nsum = lambda a, b: a + b\n# 这个sum就是一个函数类型\n# 接下来是函数调用的方式\nsum(a, b)\n```\n\n**变量作用域**\n1. 全局变量 Global\n2. 局部变量 Local\n3. 内置作用域 Built-in(内置函数所在模块的范围)\n4. 闭包函数外的函数中 Enclosing\n\n**一些关键字**\nglobal\nnonlocal(嵌套里面使用)\n这两个都是使变量是全局\n\n---\n### 数据结构\nQ: 什么是数据结构？\nQ: 为什么需要数据结构？\nA: 因为基本的数据类型，或者字符串，列表，元组，字典，集合不能够完全的表示一种数据，我们需要更复杂的数据类型，这就是我们所说的数据结构。我们应该去思考一下，我们在生活中遇到的一些问题或者数据又应该在编程中如何表示呢？存储和取出的时候又是如何可以按照我们所要求的规则呢？可以好好思考一下。\n\n堆栈(Stack)\n特点：FILO\n\n队列(Queue)\n特点：FIFO\n\n用python实现堆栈、队列：\n```\nlist.append() 入栈\nlist.pop() 出栈\n\nlist.appendleft() 入队\nlist.pop() 出队\n```\nQ:树和图，这两种数据结构怎么表示\n\n---\n### 模块和包\n**模块**：其实就可以理解为我们写的python文件，然后可以思考一下每个文件里面有什么内容组成？当我们引入过来的时候，有点像是把里面的内容复制过来。\n**包**：其实是我们的文件夹，因为我们有时候需要相同的命名，那如果同一个模块的名字一样，那就不知道是谁了，**而且同一个目录下也不允许两个文件命名和扩展名一样**。这时候我们就需要包了。就像我们有时候整理电脑一样，可能会命名同样的文件或者文件夹，但是放在不同的目录下。但是要注意的是，每一个包下都需要一个`__init__.py`文件\n\n**Q: 如何取找到文件的呢？**\nA: 绝对路径，当前路径。类似于我们的环境变量\n```\n两种导入的方式：\n1. import 文件名(.py) 全部内容一起导入\n2. from 文件名(.py) import 要导入的模块或者函数  导入指定的\n注：这样的话就可以快一点\n\nimport test\nfrom test import fib\n```\n\n### sys\n```python\n# for i in sys.argv:\n#     print(i)\n#\n# print(sys.api_version)\n# print(sys.copyright)\n# print(sys.path)\n# print(sys.exit())\n```\n\nQ: 模块导入的问题？就是引入其他模块的时候，默认是会执行的，但是这并不是我们所想要的。\n示例：\n```python\nmodule1.py\na = 5\nprint(\"one\")\n\nmodule2.py\nfrom module_one import *\nprint(\"two\")\n\n结果：\none\ntwo\n```\n解决的方法：\n在每一个模块里，其实Python解释器给我们提供了一个叫做`__name__`的变量，类型是：`<class 'str'>`。当其值是`__main__`时，表明在该模块自身运行。而如果是模块名字，那就是在引用程序执行。\n```python\n# main 主要的，也是我们编程界里所说的入口\nif __name__ == '__main__':\n    # 如果运行的入口是在这里，或者说运行这个文件，就会执行这个\n    print('one run? yes')\nelse: # 这种情况其实就是文件名\n    # 如果是被导入，就会执行这个\n    print('one run? no')\n```\n---\n\n### 文件\n权限，只有三种: r、w、x 读写(修改)执行\nexecute\n\n```\nd rwx r-x r-x\n目录 当前用户，所在组，其他组\n\n角色，组\ndirectory, read, write, execute\n```\n\nQ: 什么打开模式是在内容后添加，什么是删除全部内容重新添加？\nA: 即原有内容会被删除: `w、wb、wb+、w+`\n不会被删除的，而是在文件的结尾添加的：`a、ab、ab+、a+`(add)\n\nQ: a和a+的区别？\n![](https://www.runoob.com/wp-content/uploads/2013/11/2112205-861c05b2bdbc9c28.png)\n\n\n\n|    模式    |  r   |  r+  |  w   |  w+  |  a   |  a+  |\n| :--------: | :--: | :--: | :--: | :--: | :--: | :--: |\n|     读     |  +   |  +   |      |  +   |      |  +   |\n|     写     |      |  +   |  +   |  +   |  +   |  +   |\n|    创建    |      |      |  +   |  +   |  +   |  +   |\n|    覆盖    |      |      |  +   |  +   |      |      |\n| 指针在开始 |  +   |  +   |  +   |  +   |      |      |\n| 指针在结尾 |      |      |      |      |  +   |  +   |\n\n**os（operating system）**\n\n**Q**: 最后要关闭文件, file.close()， file是命名的文件对象\n\n\n\n### 异常(Exception)\n\nQ: 为什么会有异常？\n\nA: 其实就是一些不合语法的操作或处理造成的。比如不能除以一个为0的数，这样是得不到结果的，就会抛出异常了。**但是，其实我们并不希望遇到什么异常都直接结束**\n\n所以我们需要对异常进行处理\n\n**关键字：**try、except\n\n```python\ntry :\n    \nexcept:\n    \nfinally:\n    // 无论在任何情况下都会执行\n    // 一般用来关闭文件啊\n    // f.close()\n        \n```\n\n注意的东西：\n\n1. try-except有点像我们的if-else，先去尝试运行try里面的内容，如果有异常就会执行except的内容。**并且try后面的部分内容不会被执行**\n2. 一个 try 语句可能包含多个except子句\n\n**抛出异常**：raise\n\n\n\n预定义清理行为，其实就是Python一些简便的写法，可以帮我们进行关闭。\n\n```python\nwith open(\"myfile.txt\") as f:\n    for line in f:\n        print(line, end=\"\")\n```\n\n---\n\n### 面向对象\n\n\n\n**关键字**：class\n\n```python\n示例：\nclass 类名:\n\t属性(成员变量)\n\t成员方法(成员函数)\n\t构造方法 __init__(self)\n```\n\n* 构造方法是什么：该方法在**实例化**的时候会**自动调用**。\n\n目的：就是用于初始化一些参数或者方法\n\n* 类和对象的区别：\n\n类就像是我们的一个模板，而对象是我们具体的，**实例化也就是我们所说的初始化。**\n\n* 如何创建对象：直接类名(参数)，这里的参数就是我们构造方法的参数。\n\n如果没有，就调用默认的，也就是无参。\n\n  \n\n  **Q: self是什么，有什么作用 ?**\n\n  A: 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的**第一个参数名称**, 按照惯例它的名称是 self。\n\n  **Q: self表示的是什么呢？**\n\n  A: self代表类的实例，而不是类。类的实例其实就是我们的对象，代表当前对象的地址。\n\n\n\n**方法重写(覆盖)- override**\n\n就是父类的方法我们可以进行重写，函数名字和参数一样，只是内容我们可以去改变。\n\n​\t\n\n<font color='red'>私有属性和方法</font>\n\nQ：什么是私有变量，有什么用？\n\nA：声明为私有，**只能在类的内部调用 ，不能在类的外部调用。**目的：增加了使用的权限，为了安全性，和很棒的设计思想。\n\n```\n__name\n__password\n声明为私有只需要在前面加__\n```\n\n**如果我声明了私有之后，就只能在类的内部访问，但是如果我们还想让使用者可以查看或者修改，我们就可以写一个set或者get方法，然后给使用者调用**\n\n注意：在python里面喜欢用`__init__`表示，就是在后面也加__，**但是我们不可以这样去做。**\n\n```\n__name__\n__password__\n这样是错的，这的话还是公有的，只有在前面加__而后面不加才是私有的\n```\n\n\n\n<font color='red'>运算符的重载(overload)</font>\n\n首先，在我们的基本数据类型中，比如Number类型，或者str类型啊，都可以进行`+ - * / `之类的操作，这些`+ - * /`就是我们的运算符。那么我们的类也是一样的，可以进行加减乘除之类的运算符操作，**只不过的是我们需要重写这些运算符操作的方法**\n\n\n\nQ: 面向对象的特点？\n\nA: 一种是面向对象编程，一种是面向过程编程。比如说C语言就是面向过程的一门语言，而Python和Java就是面向对象的编程语言。**面向对象的四大基本特征：封装、抽象、继承、多态**。也正是由于这几个特征，让我使用起来觉得特别舒服。那么下面来具体介绍一下。\n\n封装：<strong>就是将对象封装成一个高度自治和相对封闭的个体。</strong>说的比较抽象，我来举个例子，比如一个学生，那这个学生的一些属性只能由自己提供的set和get的方法来操作。那这样就保证了安全性。\n\n抽象：就是找出事物的一些共同特征，封装成一个类。像人就是抽象的。\n\n继承：把已有的东西或者说类作为自己的内容，就相当于我们继承了父亲的财产。\n\n多态：是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时不确定，<strong>只有在程序运行期间才确定。</strong>也就是父类或接口定义的引用变量指向了子类或具体的实现类的实例对象。<strong>关键点在于程序的调用方法是运行期动态绑定的。这个你可以研究一下重写和重载的区别，他们两个就发生在不同的时期</strong>至于这个编译器和运行期，在重写和重载的问题时我会再详细说一下，这个跟内存的分配，堆，栈结合起来会比较合适。\n\n \n\n#### 继承\n\n```\n示例：\nclass 子类(父类):\n```\n\n注：子类一般也有人叫它派生类，而父类也有人叫它基类。\n\n**注意的东西：**\n\n1. 继承的时候，只需要在子类的后面加上括号，里面写父类的名称即可。可以多继承，只要在后加逗号(，)即可\n\n2. 继承需要覆盖父类的`__init__`方法，那这个时候我们要先调用父类的`__init__`构造方法，示例如下：\n\n   ```python\n       def __init__(self, name, age, sex):\n           # 先调用父类构造方法\n           Person.__init__(self, name, age)\n           self.sex = sex\n   ```\n\n3. 在子类中如何调用父类的东西？答：只要通过父类名然后点(.)去调用即可，但是要注意的是，每一个调用都需要带上一个**self参数**\n\n```python\n    def to_string(self):\n    # 注意，这里的to_string是父类的方法，我们调用要加上self参数\n    return Person.to_string(self) + ', sex:{}'.format(self.sex)\n```\n\n4. 我们需要改写的方法，那我们就重写(覆盖)父类的方法，我们也可以增加属于自己的方法。\n\n5. 定义为私有，子类无法访问\n\n\n练习：[菜鸟教程练习题](https://www.runoob.com/python3/python3-examples.html)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["未定义"]},{"title":"一闪而过的想法","url":"/2019/07/12/7/","content":"<Excerpt in index | 首页摘要>\n\n在这里只是记录一下一些我曾经一闪而过的想法，有工作上要注意的地方和细节，也有自我鼓励的鸡汤，或是后悔的过去。总之我记录在这里，希望当我感到迷茫或者疲倦的时候，能够看到这里，不忘初心。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 第一章  >>Hello World\n\n我第一次接触编程语言是在大一下的时候，那时候有一门课程叫《C语言程序设计》。那是我第一次有编程语言的概念，初中或者高中的时候老师可能提到过一点知识，不过那时的我一走神这些知识还没理解就过去了。\n\n当我第一次听到编程语言的时候是非常兴奋的，这个故事还得从我接触计算机开始说起。我第一次接触计算机是在小学的时候，那时有人带着我去网吧，但结果我什么也玩然后就睡着了。初中的时候他们又带着我去网吧玩游戏，但是我那时其实对游戏根本没兴趣，也不知道玩什么，结果就在那里东点点西看看。后来去网吧就为了聊天、下载音乐或者视频。在那个时候，其实我对计算机还是没有兴趣。渐渐的，到了高中的时候，那时身边好多人都在玩游戏，我也因此有机会接触了各种游戏，还接触到了一些论坛，贴吧。每天看大佬们在吹水就能学到很多，一下子仿佛打开了我的新世界大门，我感觉我对计算机的了解又多了一点。那时候我感受到了电脑做很多事情，从上面看到了很多不知道的东西，非常的强大。\n\n但是在那个年代，手机流量贵，上网贵，家里没电脑，所以其实去网吧更多的时间是去打游戏。后来由于学业需要，我在高中毕业那一年暑假，终于迎来了我人生中第一台笔记本电脑，我很开心也很兴奋，我终于可以拥有自己的笔记本电脑了，终于可以做自己想做的事了。\n\n可是事情并没有那么简单，我对计算机的了解可以说还是一点也不了解，没有一个结构概念，可是又不知道如何去搜索。所以当我对计算机感兴趣的时候，这是第一次打开我的新世界大门，当有编程语言的概念，这是第二次打开了我的新世界大门。\n\n后来就是一路摸索过来，学了一些编程语言。但是为了就业，最后还是选择了JavaWeb的方向。群里的各位，都是dalao，只有我是个垃圾。所以就不要问我技术栈，我就是个垃圾。\n\n### 第二章 我的心酸历程——一些建议\n\n时间过的很快，一路摸索过来，东西没学到多少大学就结束了。虽然有些后悔但是这也是一种收获，在这里我主要把一些我认为重要的点说一下。人在消极和劳累的时候就容易忘记自己最初的想法，所以我写在这里多回来看看，希望不忘初心。\n\n\n#### 生活鸡汤篇\n\n**// 制定目标和计划**\n\n**void setGoalsAndPlans(Goals goals, Plans plans){**\n\n有时候我们感觉生活，很烦躁，每天不知所措，没有生活和工作的目标，导致了生活不顺心，工作也不快乐。这个时候就应该设定自己的一个目标，因为现状是可以和目标进行对比的，是可以检测我们是否进步了，并且如果你进步了或者实现了自己的目标，你就会得到快乐，而快乐你做事才会更有动力。\n\n一个人的生活应该是快乐，积极向上的。有了目标，我们就应该把目标分细，这就是我们的计划，当我们不知道做什么的时候，就看看自己的计划。一个是大方向，一个是一步一步走。\n\n而计划的具体内容完全是看你个人，像如果作为程序员的话，除了工作外，其他的生活和业余时间，肯定是要经常关注一些技术新闻的，每天了解技术的一些动态或者发生了什么大新闻啊。像如果是一个运动爱好者，你就可以自己设定计划锻炼了，而不是说我这个工作太忙了根本没时间锻炼啊。这种业余的爱好我觉得慢慢来，慢慢去做，就是有些人可能觉得现在制定计划或者设立目标是不是太迟了，其实我觉得如果你真的很想做一件事没有什么迟不迟，想做就去做，去做了你就能得到快乐。\n\n这些计划制定下来，并且去执行了，坚持下去你就会发现其实自己收获了很多。不仅是知识，也为你以后的学习打下了基础，你学习会越来越轻松，越来越快。所以当你不知道做什么的时候，请花点时间想想，给自己制定一个目标和计划，然后去慢慢的坚持和完成它。\n\n**}**\n\n**// 热情和想法**\n\n**void setPassionAndThoughts(Passion passion, Thoughts thoughts){**\n\n熟话说：“兴趣是最好的老师。”当我们做一件事情感受到快乐的时候，我们是不是觉得时间过的很快，并且感受不到累。工作也是一样的，无聊的工作肯定是存在的，有时候我们感觉很累，就会很丧。这个时候我觉得并没有什么外观的因素可以改变你，唯一能够改变的是你自己的想法。\n\n其实确实是这样，我们常常会问别人遇到什么样的问题有什么好的方法啊，或者有什么诀窍啊。其实这个时候人家能够对你说的就只能是稍微安慰一下你，然后让你自己调整自己的心情。我觉得也是这样，有时候环境不是我们能改变了，不好的环境可能会存在你的身边，**这个时候我们的焦虑和烦恼其实是我们内心制造出来了，因为你这样想了所以很烦躁，所以改变自己内心的想法，想着美好或者隔离不喜欢的东西是最好的**。\n\n比如，每天早起上班要走路到地铁，并且还要早起。有的人可能就想：每天这样好累啊。渐渐就对工作失去了热情，然后感觉到累的时候越是这样想就越会消极。但是如果你想，其实每天早起并且走路，你可以当作锻炼身体，平时没什么时间锻炼身体，大部分时间是在工作，那么这段时间作为你的锻炼也是不错的事情。只有做开心的事情才不会觉得累，所以请尽量去相信美好，选择想着美好。\n\n**}**\n\n**// 如何面对困难**\n\n**void hardHandle(Handle handle, Responsibility  responsibility){**\n\n当面对一个困难的时候，我们常常会紧张，害怕，不知所措。这个时候就很容易选择放弃，那么你该选择怎么办。\n\n我觉得首先最重要的一点就是不要逃避，困难来了你就必须去承担和面对，而不是去害怕和逃避。总要有人去承担，事情总会有后果，所以你可以给自己打打鸡血，把自己想象成一个英雄，然后去面对困难。做一个负责任的人，面对困难，不要逃避。我觉得很多时候我们并不是不能解决困难，而是害怕，害怕失败，害怕丢脸，害怕最后一无所有。\n\n可是你应该明白，害怕是无济于事的，我觉得面对困难就应该是尽力做好，只要你尽力了就算再怎么样的结果我觉得你的心里总会有一丝安慰和开心，这个还是说要改变自己的心境。\n\n**所以当你面对困难的时候，要负责，这是你的问题，应该由你解决，然后要尽力**。\n\n**}**\n\n\n\n**// 少犯错误**\n\n**void makeFewerMistakes(Criterion criterion, Note note, Thoughts thoughts){**\n\n在工作中难免会犯错误，有些错误是可以被允许，而有些错误可能就导致你被开除了，所以工作中我们要尽量少犯。\n\n如何做到少犯错？首先我觉得第一点应该是学会总结，把学过的知识或者容易犯错的地方多多复习，增强自己的记忆。\n\n第二点是你应该去学习一些规范，在开发中应该尽量避免个人的一种风格，而应该和标准达成一致。比如代码风格，或者使用一些编码模板。这个必须自己去学，有些人可能在平常生活中就比较随意，然后不注重自己的形象，可能就造成很多人的困扰。有时候你也不想这样，可能就是习惯了，或者觉得无所谓，但也有可能是你不知道别人会在意这个。如果很多人都对这个很讨厌，可能这个就是人们隐形的一种“标准”，而你因为不知道冒犯了别人。理论上来说不知者无畏，但是这种我可能就觉得是常识问题，所以如果你平时没有注意，这个时候就应该去学习，研究一下。\n\n多总结和回顾学过的东西，有助于帮助我们完成自己的知识体系。知识就像是一个巨大的库，知识点之间相互联系，当知识越来越多的时候，会变得越来越复杂，人一旦面对复杂的东西时候就会变得烦恼，心情不好就会自暴自弃，所以要经常总结。当我们复习和思考学过的东西时候，**应该把知识点联系起来，弄清点与点之间的关联，然后当面对类似的东西时候能够拿出来类比和参考。**\n\n​\t瞬间的灵感是非常难得的，所以当你有不错的想法时候，或者总结东西有新的认识的时候，就可以记录下来。我个人建议是用Markdown做笔记，而不是用笔记录。至于里面的便利性有非常多，比如支持图文结合，文字强调和颜色改变，存在服务器方便携带，书写高效并且内容完整等。我觉得在github上存储也是蛮不错的，可以用博客，这个随便你了。\n\n**}**\n\n\n\n#### 技术忽悠篇\n\n**// 未知函数名**\n\n**void Unknown(void){**\n\n**​// 编程语言与编程思想**\n\n每次听到有人问，初学者学什么编程语言合适？或者学什么好找工作。\n\n我的回答肯定是C，然后才是Java，C++，Python之类的推荐。那你又问我为什么，那我就不知道了。因为我一开始学的是C，虽然我的C语言很垃圾，但这是我编程思想的基础。\n\n**就我个人来理解，编程语言虽然很多，但是编程思想是不会变化的**。比如都有函数，变量，类型这些东西，只是在功能上使用有些不同，比如面向对象和面向过程的区别，内存自我管理和回收机制管理的区别等，这些只是别人已经实现和封装好罢了。\n\n**你要明白一个东西，一个是编程语言底层，也就是提供的基础功能，另一个是编程语言库，是别人通过这门语言实现的好用的东西。如果你有足够的兴趣，这门编程语言没有提供的库其他的语言有，你也可以自己去写一个(造轮子)**。\n\n那又如何去知道这些不同呢，**我建议是学懂了C++再去学其他就无敌了**。概念搞懂了，再学什么都会一通百通，我觉得你现在明白你的问题了，你并不是想问学什么编程语言好，而是想知道哪些编程语言是做什么比较方便的，或者主要用来做什么方向的。\n\n**​// 我所推荐的几个技术栈**\n\n随着框架的学习越来越多，我也渐渐迷失了自己。如果不了解框架的底层，是不可能把框架用好的，如果你有足够的兴趣和动力，你还可以自己写一个框架。我是做JavaWeb方向的，所以这里也主要是以Java来说，但是思想是差不多的。\n\n第一个就是去了解一些数据结构、算法，然后去了解编程语言的思想，了解这门语言设计的语法思想，知道了才能用的得心应手，这个可以去看《Thinking  in Java》和《深入理解Java虚拟机:JVM高级特性与最佳实践》。\n\n第二个就是去看《代码简洁之道》《阿里巴巴Java开发手册》等编程规范，这里一个是**命名和代码上的规范**，另一个是**代码结构设计上的规范**，这里其实是第三点。记住命名要规范，至于如何才是规范看手册，(还有一点，如果是需要中文注释的开发，属性和方法建议还是注释上中文。可能是我个人原因，虽然英文看得懂，但是看英文还没达到一目十行的能力，看中文会比较快。)\n\n第三个就是去看设计模式(Design Patterns)、重构、软件工程，小的项目可能并不需要什么结构设计，但是项目大了之后往往是需要多人协作的。这个时候对于项目的结构分层就很重要了，接口和类要怎么设计，如何增强扩展性和可维护性，如何能够使得模块清晰、分工明确。又如何能够优化系统、微服务，这些都是需要去思考和学习的。如果只是一个简单的HelloWorld，就一句话的事情并不能看出和别人的有什么不同，但是一旦工程大的时候就是真正体现了**代码设计的艺术和思想了**。\n\n\n**}**\n\n\n### 第三章 搬砖的日子\n\n押尾桑的卡农回响在耳边，我习惯性的确认一样现在的时间\n\n......\n......\n","categories":["未定义"]},{"title":"最近在做些什么","url":"/2019/07/09/6/","content":"<Excerpt in index | 首页摘要>\n\n离上一次写文章，已经过去了快十天了。时间过的真的很快，每天早起搬砖，回来的时候已经是快晚上九点了。我拖着疲惫的身体，什么也不想做。感觉自己的时间是以一周为计算，时间过了一周了但是给我的感觉却像是只过了一天，我不知道何时才能结束工作，有自己的时间看看文章，学学技术。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n上一周的某一天，宝贝突然跟我说想学Python，叫我教她。以前我总希望她能够学的什么，但每次想教的时候她总会没什么兴趣，我很想告诉她计算机里的巧妙设计，前人的设计思想是如此的伟大。而这一次她竟然主动要求想学，看着她那认真的神情，我决定了要认真的教她。\n\n其实不管学的怎么样，当坚持一段时间下来，就会对编程语言有一定的了解。于是我也开始看起了Python，我教的时候尽量不只是告诉她Python的东西，而是去了解计算机的一些原理。语言只是一门工具，有高级的工具也有底层的工具，每一样都有自己的特点和适合的地方。\n\n因为她没有编程的基础，虽然学过R语言，但是对于计算机的了解还是比较少，所以我决定从头开始讲。我给她讲了变量，告诉她要去存储东西，那么我们就需要用变量去存储，然后存的东西要分类，那么就有了数据类型，然后有简单的数据类型也有复杂的数据类型。存东西要有空间，那么就需要内存，还讲了二进制。我和她讲了编译器和解释器，但是并没有和她说编译器和运行期，因为她这时候就开始晕了。\n\n后来我告诉了她我们要进行判断，那就要用到条件语句。要重复做一样类似的时间，就要用到循环，讲了break，continue，pass。我给她出了斐波那契计算，还有1+2+3+...+n的计算，还有一个猜数字小游戏，她做的不亦乐乎。我也仿佛看到了当年那个刚入门学习编程的我，因为了解了一些思想而开心的不得了，有一种：哇，用计算机去解决问题，这样设计真的很棒的感觉。\n\n后来我还和她讲了布尔的伟大，我已经不记得多少布尔的事迹，但是他的这种思想却是将事物很好的划分了。\n\n接下来不知道会讲些什么，我会结合我所学过的语言，一点点告诉她这个东西是怎么从实现到运用的。很遗憾的是我并没有学过编译原理，只看过一点点的词法分析和解释。\n\n我有时候也在想，如果当年我坚持学的不是JavaWeb而是其他，可能就不需要写那么多业务逻辑，而是可以研究一些底层和性能的东西。可是一切都已经过去，新的生活和方向又在哪里呢？\n\n我喜欢计算机的东西，但并不是一个极客，我只想用业余的时间一点点的去了解，我喜欢看动漫，也喜欢打游戏，看直播，但是现在我很久没去做那些事情了。\n\n也许多年以后，我还是一个学的杂七杂八的垃圾程序员。但其实我并不想给自己贴一个程序员的标签，我并不喜欢天天敲代码或者查看生成日志，我只是想去了解和设计一些东西，我只是一个默默无名对计算机有兴趣的爱好者。\n\n只是为了好玩，仅此而已。","categories":["未定义"]},{"title":"新的开始","url":"/2019/06/30/5/","content":"<Excerpt in index | 首页摘要>\n\n已经许久没有更新博客，来来回回删了好多东西。曾经一度想造轮子，可是每次都造的很烂，最后以失败而告终。\n\n本来还想写一些技术文章，可是后来想想我写来也不是给别人看的，只是我怕自己忘记所以记在这里，有时候可以直接在这里看看罢了。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n网上有很多写的很不错的技术文章，其实有时候你也会发现这些文章大部分内容是一样的，重复的，甚至就是直接搬运、转载的。\n\n在这个信息时代，重复也许并不是一件好事，你可能想找一个问题却发现每一个回答都是一样的，这对人来说是一件恶心的事情。\n\n所以当我可以直接就搜到答案的问题，我是不会再记录在自己的博客里。\n\n一切回归日常。\n\n但我并不是不写，而是不会再发到这里，我打算存在本地，因为这写大部分是我的笔记，也就只有我能看懂吧。(笑)\n\n这里就作为我日常的吐槽吧，讲讲我的或者我听说过的故事。\n\n工作之后，总感觉时间非常不够，很难一直专心去做一件喜欢的事情。每天的时间的过的很快，没有了以前那么多时间去总结和思考，所以导致了很多东西其实就只存在脑海中一会儿。也许天才是个例外，但我并不是，每一点东西我都需要反复的去思考才能记忆深刻。\n\n这也是我重新开始的原因，我想把思考的东西写在这里，生怕自己忘记了一些想法。\n\n我始终热爱着计算机\n\n始终想了解事物的本质\n\n始终想在空闲的时间能够看看番\n\n始终想玩玩游戏","categories":["未定义"]},{"title":"Markdown语法测试","url":"/2019/06/30/4/","content":"<Excerpt in index | 首页摘要>\n\nMarkdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md”\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 欢迎使用 Markdown在线编辑器 MdEditor\n\n**Markdown是一种轻量级的「标记语言」**\n\n![markdown](https://www.mdeditor.com/images/logos/markdown.png \"markdown\")\n\n## MdEditor是一个在线编辑Markdown文档的编辑器\n\n*MdEditor扩展了Markdown的功能（如表格、脚注、内嵌HTML等等），以使让Markdown转换成更多的格式，和更丰富的展示效果，这些功能原初的Markdown尚不具备。*\n\n> Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如~~Pandoc~~，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。\n\nMdEditor源于Pandao的JavaScript开源项目，开源地址[Editor.md](https://github.com/pandao/editor.md \"Editor.md\")，并在MIT开源协议的许可范围内进行了优化，以适应广大用户群体的需求。向优秀的markdown开源编辑器原作者Pandao致敬。\n\n\n![Pandao editor.md](https://pandao.github.io/editor.md/images/logos/editormd-logo-180x180.png \"Pandao editor.md\")\n\n\n\n## MdEditor的功能列表演示\n\n# 标题H1\n\n## 标题H2\n\n### 标题H3\n\n#### 标题H4\n\n##### 标题H5\n\n###### 标题H5\n\n### 字符效果和横线等\n----\n\n~~删除线~~ <s>删除线（开启识别HTML标签时）</s>\n\n*斜体字*      _斜体字_\n\n**粗体**  __粗体__\n\n***粗斜体*** ___粗斜体___\n\n上标：X<sub>2</sub>，下标：O<sup>2</sup>\n\n**缩写(同HTML的abbr标签)**\n> 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启\n\nThe <abbr title=\"Hyper Text Markup Language\">HTML</abbr> specification is maintained by the <abbr title=\"World Wide Web Consortium\">W3C</abbr>.\n### 引用 Blockquotes\n\n> 引用文本 Blockquotes\n\n引用的行内混合 Blockquotes\n\n> 引用：如果想要插入空白换行`即<br />标签`，在插入处先键入两个以上的空格然后回车即可，[普通链接](https://www.mdeditor.com/)。\n\n### 锚点与链接 Links\n[普通链接](https://www.mdeditor.com/)\n[普通链接带标题](https://www.mdeditor.com/ \"普通链接带标题\")\n直接链接：<https://www.mdeditor.com>\n[锚点链接][anchor-id]\n[anchor-id]: https://www.mdeditor.com/\n[mailto:test.test@gmail.com](mailto:test.test@gmail.com)\nGFM a-tail link @pandao\n邮箱地址自动链接 test.test@gmail.com  www@vip.qq.com\n> @pandao\n\n### 多语言代码高亮 Codes\n\n#### 行内代码 Inline code\n\n\n执行命令：`npm install marked`\n\n#### 缩进风格\n\n即缩进四个空格，也做为实现类似 `<pre>` 预格式化文本 ( Preformatted Text ) 的功能。\n\n    <?php\n        echo \"Hello world!\";\n    ?>\n预格式化文本：\n\n    | First Header  | Second Header |\n    | ------------- | ------------- |\n    | Content Cell  | Content Cell  |\n    | Content Cell  | Content Cell  |\n\n#### JS代码\n```javascript\nfunction test() {\n\tconsole.log(\"Hello world!\");\n}\n```\n\n#### HTML 代码 HTML codes\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <mate charest=\"utf-8\" />\n        <meta name=\"keywords\" content=\"Editor.md, Markdown, Editor\" />\n        <title>Hello world!</title>\n        <style type=\"text/css\">\n            body{font-size:14px;color:#444;font-family: \"Microsoft Yahei\", Tahoma, \"Hiragino Sans GB\", Arial;background:#fff;}\n            ul{list-style: none;}\n            img{border:none;vertical-align: middle;}\n        </style>\n    </head>\n    <body>\n        <h1 class=\"text-xxl\">Hello world!</h1>\n        <p class=\"text-green\">Plain text</p>\n    </body>\n</html>\n```\n### 图片 Images\n\n图片加链接 (Image + Link)：\n\n\n[![](https://www.mdeditor.com/images/logos/markdown.png)](https://www.mdeditor.com/images/logos/markdown.png \"markdown\")\n\n> Follow your heart.\n\n----\n### 列表 Lists\n\n#### 无序列表（减号）Unordered Lists (-)\n\n- 列表一\n- 列表二\n- 列表三\n\n#### 无序列表（星号）Unordered Lists (*)\n\n* 列表一\n* 列表二\n* 列表三\n\n#### 无序列表（加号和嵌套）Unordered Lists (+)\n+ 列表一\n+ 列表二\n    + 列表二-1\n    + 列表二-2\n    + 列表二-3\n+ 列表三\n    * 列表一\n    * 列表二\n    * 列表三\n\n#### 有序列表 Ordered Lists (-)\n\n1. 第一行\n2. 第二行\n3. 第三行\n\n#### GFM task list\n\n- [x] GFM task list 1\n- [x] GFM task list 2\n- [ ] GFM task list 3\n    - [ ] GFM task list 3-1\n    - [ ] GFM task list 3-2\n    - [ ] GFM task list 3-3\n- [ ] GFM task list 4\n    - [ ] GFM task list 4-1\n    - [ ] GFM task list 4-2\n\n----\n\n### 绘制表格 Tables\n\n| 项目        | 价格   |  数量  |\n| --------   | -----:  | :----:  |\n| 计算机      | $1600   |   5     |\n| 手机        |   $12   |   12   |\n| 管线        |    $1    |  234  |\n\nFirst Header  | Second Header\n------------- | -------------\nContent Cell  | Content Cell\nContent Cell  | Content Cell\n\n| First Header  | Second Header |\n| ------------- | ------------- |\n| Content Cell  | Content Cell  |\n| Content Cell  | Content Cell  |\n\n| Function name | Description                    |\n| ------------- | ------------------------------ |\n| `help()`      | Display the help window.       |\n| `destroy()`   | **Destroy your computer!**     |\n\n| Left-Aligned  | Center Aligned  | Right Aligned |\n| :------------ |:---------------:| -----:|\n| col 3 is      | some wordy text | $1600 |\n| col 2 is      | centered        |   $12 |\n| zebra stripes | are neat        |    $1 |\n\n| Item      | Value |\n| --------- | -----:|\n| Computer  | $1600 |\n| Phone     |   $12 |\n| Pipe      |    $1 |\n\n----\n\n#### 特殊符号 HTML Entities Codes\n\n&copy; &  &uml; &trade; &iexcl; &pound;\n&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot;\n\nX&sup2; Y&sup3; &frac34; &frac14;  &times;  &divide;   &raquo;\n\n18&ordm;C  &quot;  &apos;\n\n[========]\n\n### Emoji表情 :smiley:\n\n> Blockquotes :star:\n\n#### GFM task lists & Emoji & fontAwesome icon emoji & editormd logo emoji :editormd-logo-5x:\n\n- [x] :smiley: @mentions, :smiley: #refs, [links](), **formatting**, and <del>tags</del> supported :editormd-logo:;\n- [x] list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;\n- [x] [ ] :smiley: this is a complete item :smiley:;\n- [ ] []this is an incomplete item [test link](#) :fa-star: @pandao;\n- [ ] [ ]this is an incomplete item :fa-star: :fa-gear:;\n    - [ ] :smiley: this is an incomplete item [test link](#) :fa-star: :fa-gear:;\n    - [ ] :smiley: this is  :fa-star: :fa-gear: an incomplete item [test link](#);\n\n#### 反斜杠 Escape\n\n\\*literal asterisks\\*\n\n[========]\n### 科学公式 TeX(KaTeX)\n\n$$E=mc^2$$\n\n行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。\n\n$$x > y$$\n\n$$\\(\\sqrt{3x-1}+(1+x)^2\\)$$\n\n$$\\sin(\\alpha)^{\\theta}=\\sum_{i=0}^{n}(x^i + \\cos(f))$$\n\n多行公式：\n\n```math\n\\displaystyle\n\\left( \\sum\\_{k=1}^n a\\_k b\\_k \\right)^2\n\\leq\n\\left( \\sum\\_{k=1}^n a\\_k^2 \\right)\n\\left( \\sum\\_{k=1}^n b\\_k^2 \\right)\n```\n```katex\n\\displaystyle\n    \\frac{1}{\n        \\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\n        \\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {\n        1+\\frac{e^{-6\\pi}}\n        {1+\\frac{e^{-8\\pi}}\n         {1+\\cdots} }\n        }\n    }\n```\n```latex\nf(x) = \\int_{-\\infty}^\\infty\n    \\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\n    \\,d\\xi\n```\n### 分页符 Page break\n\n> Print Test: Ctrl + P\n\n[========]\n\n### 绘制流程图 Flowchart\n\n```flow\nst=>start: 用户登陆\nop=>operation: 登陆操作\ncond=>condition: 登陆成功 Yes or No?\ne=>end: 进入后台\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n[========]\n\n### 绘制序列图 Sequence Diagram\n\n```seq\nAndrew->China: Says Hello\nNote right of China: China thinks\\nabout it\nChina-->Andrew: How are you?\nAndrew->>China: I am good thanks!\n```\n### End\n\n","categories":["未定义"]},{"title":"三月，我遇到了一个女孩","url":"/2019/03/05/3/","content":"<Excerpt in index | 首页摘要>\n\n三月，我遇到了一个女孩。\n\n在某一天我遇到了一个我想守护一辈子的女孩，她非常可爱，我喜欢上了她。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n她会愿意听我唠叨，会给我做好多好吃的菜，会向我撒娇，也会向我说好多生活中有趣的事，会教我们很多生活的技巧。\n\n我难过的时候会抱着我给我温暖，我迷茫的时候会给我意见，也会听我给她分享计算机中的故事。\n\n她有时很勇敢很坚强，但有时也很脆弱的让人心疼，她是我的宝贝，也是我的小公主。\n\n我们之间也会有矛盾，但是我们都会好好解决。我们都想守护这份来之不易的爱情，其实双方都知道是为了对方好，希望得到对方更多的爱。\n\n我们有矛盾也有成长，我也从中慢慢的懂得了很多道理。\n\n当发生矛盾的时候，不要纠结是谁错了，或者一定要争论对错。在我看来，真的没有对错之分，每个人都有自己的选择和观点，我们也不应该强制要求别人怎么样，不要觉得谁应该怎么样，自己这样做就很对的样子。在我心里，你想别人那样做只是一种期望，别人可以不做。\n\n可能是随着年龄的增长，我越来越希望自己能够控制自己的脾气。坏的脾气只会让对方也觉得委屈，就会因为你的生气而生气。可能事情的原因并不是这个，但是却因为你的生气和不好的回应，造成了问题继续坏下去。我觉得我们每一个人都应该控制好自己的脾气，生气只会让人失去理智，忘记了很多在乎和考虑的东西，于事无补。\n\n在认识她以前，我的生活很枯燥无聊，我活在自己的世界里，我不想和别人说也没人愿意听我说。现在我想多出去走走，多培养一些兴趣和话题。\n\n我想到八十岁的时候，我们还是像现在一样浪漫，生活需要仪式需要惊喜需要浪漫，我想保持这份浪漫一直下去。\n\n我们拥有两个” 儿子 “，一个是在商场逛街的时候，我给她夹到了人生中第一个小乌龟娃娃，当看到她笑的那一刻，我人生中第一次因为看到别人非常开心而特别开心。\n\n另一个是Sony RX100M3，我们买了一个黑卡3数码相机，当以后去各种地方玩的时候，我们就可以记录下来我们去过的地方，等老了的时候一起慢慢回忆。\n\n","categories":["未定义"]},{"title":"我的大学生活","url":"/2018/10/10/2/","content":"<Excerpt in index | 首页摘要>\n\n我的大学在某普通的二本学校，我的大学生活真的挺失败的。没参加过多少比赛，也没得过什么牛逼的奖。别人女朋友都换了好几个，而我大学都没谈过恋爱，也没有女生喜欢，朋友也没认识几个，就连旅游也没去过几个地方，虽然在大学的城市生活了三年多了，但是一点也不熟悉。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n本专业的东西没学懂多少，数学烂的不行，算法一点都不懂。唯一欣慰的是没有挂过科，英语四级和计算机二级这些还没有来得及担心就已经过了。\n\n大学的圈子过的很小，参加过一个日语协会，那是我在这个学校认识的为数不多的几个人，副部和部长，柠檬学姐还有振振，我还没有和她们好好说再见她们就已经毕业了。不过开心的是偶尔还能听到她们的消息，而我的小学和初中像是未存在过早已没了联系，高中宿舍倒是认识了一帮不错的人每次回去都会聚一下玩的很开心。\n\n我的大学就这样快要结束了，没有什么起眼的地方。\n\n<h3>认真做自己</h3>\n\n在大学以前我身边的大部分人每天就是玩，也没有学习目的，而我也如此毫无目的每天不是玩就是听课，也不知道学的是什么，老师教的这些用来干什么，就只会老师考什么就投机取巧去学什么背什么。可是我家里并没有矿这样下去我就会变成人渣，我也很想到处去玩买各种喜欢的设备可是我必须要有一份工作支撑我的家庭。于是我开始想我以后要做什么，我喜欢的是什么，我要有一个目标而不是每天毫无目的的生活，我要每天做自己喜欢的事。我花了好几天都在想我喜欢的是什么，游戏吗？画画吗？音乐吗？还是做动画？还是摄影？还是教师？还是...我想了很久，最后得到的答案是：我想玩。哈哈，这看起来真是个废话，一点也不好笑。\n\n不过并没有错，我每天想做的就是玩，我是一个不喜欢工作的人。我在高中的时候挺幸运的，有了手机，通过手机了解到原来还有这么好玩的东西。\n\n我第一次听说乐器的东西，了解到了吉他。\n\n我第一次听过一副上百的耳塞，发现原来听歌还可以这么舒服，我以前的耳机都是什么垃圾啊。\n\n我第一次喜欢上了玩游戏。我错过了玩红警和魔兽还有dota的时代，但是却遇上了英雄联盟，讨鬼传，战神，怪物猎人，我发现游戏真的很好玩。\n\n我第一次读到一本好书，发现看书也是不错的事情。\n\n我第一次有机会在网上选自己想看的日本动画，知道了日本动画做的非常不错，那个年代有了手机和网吧后看动画挺方便的。\n...\n...\n\n可是，这些并不能成为我的工作。直到某一天，在2016/4/27这一天，我遇到了一个人，他给了我一样东西，我终于明白我想做的是什么。\n这个人便是我的C语言老师，那一天我开始接触了编程。\n\n那时候玩游戏经常出问题，或者别人给的教程看不懂，于是我就想自己搞清这些联系，而编程就是这个大门的入口。我明白了原来现在我用的这些关于软件的所有东西都是别人用编程做起来，但是有些东西并没有我想要的，我很不满意，于是我想自己做出一些东西来。而且，我发现这东西也能作为我的工作。\n\n<h3>我的编程之路</h3>\n\n想法是简单的，但是要做出来却特别难。我发现我这人说起大话来一点都不含糊，学C语言一段时间后我就觉得难了，开始搞不懂，每天看了好多教程就是不太理解。而我的C语言老师也没有讲多少内容，刚讲到一点指针的东西就结课了。后来又学了数据结构，可是由于C语言的基础没学好很多数据结构用到的C语言东西都没有学，这门课也学的很烂。那时候我的心情很糟糕，我有很多问题但是无从知晓答案，我每天都在想学习C语言问题。\n\n后来，勉强算是学完了C语言基础，可是接下来我就不知道要学什么了。后来听说去学Python，就学了Python可是也没懂多少。再后来知道了Java有一套做Web的教程，这个时候我已经快大三了，为了混口饭吃找份工作，我学了这一套教程。\n\n学习的过程挺困难的，一个人看着视频和书自学，身边的人每天都在玩，没人会喜欢我喜欢这些，我也无法和别人交流学习的想法。如果你遇到了愿意和交流的人，请好好珍惜她。\n\n我在网上曾经遇到过一个女孩，我教她装了Ubuntu系统，并收取了她一定的费用。那时候感觉她和自己挺投缘的，我厚着脸皮硬是问了别人很多问题，那是我很久以来从没有过的开心，我很想见她了解她。那是第一次有女生愿意和我聊编程，吉他的东西，她也给我分享了她看的照片。虽然联系的时间并不长久，很快就没了联系，但是和她在一起聊天的日子让我真的发自内心的开心。\n\n国庆前的一段时间，也去面试了好几家公司，那段时间每天就是听宣讲，笔试然后面试等通知。offer到手后另一个考虑到的问题就是工资和前景，我一同学面试了很多公司拿了好几个offer，他对工资普遍不满意，他想要有8k的工资。而当我选择深圳7k工资的时候，他对我说：\" 不行啊，你太急了，以你的能力可以拿到更多，你不想拿了?我还想去试试。\"\n\n说实话，我面试了好几家公司，其实每家的要求和工资都差不多，我觉得这样的工资对我来说还不错了。工资高的自己也达不到要求，我觉得时间应该放在更多有意义的事情上，我对底层很多东西都不懂，于是又重新学了C语言和数据结构，现在正在重新学习C++。\n\n<h3>做个乐观的悲观主义者</h3>\n\n我是一个悲观主义者，负能量爆棚的人。人们说喜欢踢足球的人很自负，而喜欢编程的人却自卑到了骨子里。我两样都喜欢，却是一个悲观的人，我的同学也觉得我很自卑。我不是一个自负的人，因为我根本没有炫耀的资本了。但我也是乐观的悲观主义者，就像我写这篇文章的时候觉得根本不会有人想看，但是我还是会厚着脸皮发到朋友圈里。\n\n我觉得我是一个乐观的悲观主义者。在看东西的时候我是悲观的，但是做事的时候我却是乐观的。有些人总会说：\"我不行，我做不到，别人有钱我们哪里有那种条件。\"我这个时候就会先看不起这个人，然后再看看他的做法。虽然我也会经常觉得自己怎么样比不上别人，但是我还是会往高质量的生活去努力，认真工作赚钱去买这些。\n\n(最近的b站有个【我的装备清单】活动，评论最多的就是up主家里有矿。现在家里没矿都不好意思称自己为肥宅了，对不起我给肥宅丢脸了。我倒是挺喜欢看这些，看到别人装备这么好的时候，我也会努力工作让生活变得更好。)\n\n有些人觉得自己穷，或者别人买了什么就觉得别人有钱在那酸。一个人要有自己的正确消费观，有些人总觉得有些东西不是自己能消费的起的，这就是一种悲观的做法。我觉得买一样东西，你要去了解它，低价位是怎么样的高价位又是怎么样，自己的需求是什么，使用时间有多长，要先攒一下还是用花呗等等，不要什么都往便宜的买或者觉得不是自己可以用的。\n\n比如在我们的村里，有钱大家就会酸你嘲讽你，没钱人家就会看不起你。这种让我非常讨厌，总是以最坏的恶意看别人。在我们村里，家长大部分都忙于工作，以为让孩子好好读书吃饱饭就很好了，却大大限制了孩子的自由和思想，他们会觉得买电脑不好，孩子会沉迷游戏并且浪费钱浪费电。他们不懂却用自己的思维去限制别人。\n\n<strong>所以如果你想选择或者批判，你就要去了解它，用知识去做选择。</strong>\n\n<h3>接下来的打算</h3>\n\n我的大学生活所剩无几，也就两个月左右了。接下来的时间我打算重新学习C++，然后研究算法，大数据。还有不久我也要实习了，我也会去研究一下怎么做菜，怎么搭配营养，这些都是非常不错的事情。有些人觉得这样的生活太拘束很累，我觉得你只有懂得了才能更好的选择，而这就是我的选择，我觉得这样的生活很棒。\n\n我会去了解很多的东西，接触到什么我就去了解什么。如果有空我又会继续研究吉他音乐，或者学其他乐器。我也会去了解有什么好玩的科技产品让生活变得更方便更酷。如果有人碰巧喜欢上了我，我会带她一起去喜欢的地方。现实是悲观，但是生活可以变得美好。\n\n不要因为工作而忘记了喜欢的东西，我是一个喜欢玩的人，我一直在做自己。","categories":["未定义"]},{"title":"2017年的回忆与总结","url":"/2018/03/14/1/","content":"<Excerpt in index | 首页摘要>\n\n2017年3月3日的那一天，有些无聊，生活的枯燥和迷茫让我的内心很压抑，心里总想有个诉说的地方，于是便萌生了弄个人网站的想法。在没有任何网站搭建知识基础的我，找了很多教程，最后发现了Hexo非常适合我。原因很简单：简单、免费。如今想不到已经过去了一年的时间了。这一年的时间里并没有写太多的东西，因为我实在想不到写些什么。这些东西写来只有我一个人看，这样的话我可以随便写什么，也不担心有人看。不过万一有人看到了误导了也不好，索性就空着等想写的时候认真写点什么。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n在大三上的学期里，报名了学车，想着这个学期拿到驾照，毕竟驾照已经成为了一种必备的技能，你老是让老司机带你怎么行。平时练习的时候没有什么太大问题，半坡虽然有点想要熄火的样子但没有熄火，想着考试应该过了吧，结果两次都在半坡下课了。原因很简单，我对半坡的理解有误，说出来可能会有些人笑话了，我以为半坡起步刹车放完之后，就慢慢放离合上去了。其实并不是，最好是稳住离合然后慢慢上去，上去之后就可以随便放了。后面考完的时候我才发现这个问题，然后快要补考之前练习了几圈就一次过了。其实我们的教练说的很清楚，只是我自己理解错误了。他是一个好教练，很多时候你遇到的问题他都会告诉你为什么，但是也有这种我自己的问题，而教练不知道什么的问题。\n\n上学期的时间断断续续学了一些JavaWeb的内容，可是一个学期结束后并没有记得多少，只是渐渐对这个体系有了了解。在学习的过程中，我遇到的问题基本上都是我一个去解决的。在这个过程中，其实是很痛苦很打击人的，因为并不是所有问题我都能自己去解决，我至今还是存在很多问题并且还在思考中。所以如果可以，建议还是找一个老师，当然这个老师并不是单指那些授课的教师或者培训机构的老师，这也可以是拉上自己的一个小伙伴或者网上的热心网友一起学习。有讨论的问题才容易得到解决，不然你就得像我一样，一个人讨论，想破头皮，然后头皮发麻。可能你会觉得为什么我说的要和别人交流讨论，自己却不去做反倒一个人思考，根本不知道在表达什么。\n\n\n### 老师，这道题怎么解？\n老师说你自己看书吧，在初中生物课本七年级下的第9页。我们继续接着上面，我换一种表达方式。有人指导你方向会更好，因为我们问的很多问题，**其实当你有个体系和了解一些原理后就可以自己解决**，所以我遇到的问题不是什么都拿去问别人，如果问题过于低级也是浪费大家的时间。这些技术性的问题，如果是一开始学习，其实好好理解学习的内容的原理就可以了，但是有些就不可以了，比如一些超出你知识体系范围太多的东西，例如你想了解Linux的一些高级应用，这个时候你就必须从头开始学习，这个**需要一个基础的东西**。如果有老师的话就能告诉你一个学习的方向是最好的，比如说苍老师就是一位好老师。你如果问我苍老师是谁，我其实也不知道，只是谈起的人多了，就渐渐知道了这个名字。就像我没学过拍黄片，但是也听过很多人说过。当我去搜索的时候，就会告诉我，苍老师是日本的一名AV女优，拍黄片是一种很多人都不太愿意做的工作，跟鉴黄师一样需要整天对着电脑进行修改和处理。所以也不要随便问别人一些在你体系范围内的知识，我的一些朋友也会问我一些关于电脑遇到的问题。可能你会感觉愚蠢和简单的问题，但是我都是跟她说帮她解决，因为我知道她只是想解决这个问题，并且如果她想自己解决她需要学习这个方面体系的东西。乐于助人是中华的传统美德，况且是我们的女生，我当然是很开心了。\n\n\n### 没有一个好的学习环境，我该如何去学习？\n接下来也说一下很多人在学习困扰的地方吧，就是一个学习环境。好的学习环境能给人带来很多的益处，但是这个学习环境不是我们想就能够营造出来。大多数时候，宿舍通常是一堆人天天玩着游戏，毕竟大家没女朋友嘛，基本就是没课都在宿舍了。这个时候其实想好是需要一定的定力的。我学习的地方大多时候是在宿舍，偶尔带着笔记本去过几次图书馆，但是反倒没有在宿舍好。怎么说呢，首先，在图书馆没有适当的地方进行充电并且没有网络(不过现在已经开通了校园无线网络覆盖)，在学习的过程中难免会遇到问题，这个不查不行，况且我的流量那时候不多，后面改成了校园无限流量的套餐。其次，如果在图书馆自习室敲代码，里面的人大多数考研或者考前来得到心灵的安慰，你吵到别人也不合适。最后，是我这个人的一个坏毛病，有时敲代码就会连续不断的敲，累了就想直接上床躺会儿，然后下来继续敲，如果是在图书馆我就不能想休息就休息。\n\n后来由于要找工作的压力，就开始静下来戴上耳机就能学习，这个时候你会发现找工作压力已经让你能够忽视外界的环境干扰。宿舍并不是不能学习，这个问题我也没有明确的答案，我的认为是需要自己慢慢调节找到适合自己的学习节奏吧。也是由于要学习的原因，我开始了继续维护写博客，我把我学的东西和内容就写在这里，大多数是我的笔记，估计也没人看的懂。当我想要复习或者找一些东西的时候在这里找就非常的方便。\n\n### 过年遇到的问题\n2018年回家的是时候，感觉算好了很多吧，心态也变平淡了很多。大多数的时间里更愿意陪着家人了与此同时在家的时候学习的时间由我安排，不会像在宿舍如果有人喊的非常厉害就很难受，过年的时间亲戚也开始谈起了结婚、车、房子，不再问你在学校得不得奖，考的怎么样，我很无奈地笑了笑并不想理会。长辈关心你的成绩，却从不关心你其他方面的知识发展，这种是很不好的，他们会向别人炫耀你在学校成绩有多优秀，可他们并不知道你对其他知识的渴望。后来年纪大了一些，也渐渐明白了这点，在我父母的一辈大多数是很早就出来工作了，毕竟那时候信息并不像如此发达，我时常希望父母能够多去了解一些东西，看看书，可是他们的目标就很简单的希望我好，然后家庭幸福安康。我很感动却也很难过，我多么希望他们也能够去追求喜欢的东西。我问过妈妈:\"其实你也可以去学习英语，看看书，或者学习乐器唱歌，学摄影，画画艺术这些。做一些你年轻时候想做就没有做的事情。为什么不去呢？\"人如果没有对自己的追求，我想会是一件难过的事情。于是我也开始重新拿起了吉他。也希望在未来的日子里，能够学学唱歌，摄影，画画，学一门喜欢的运动，不要等到热情和喜欢退却了。\n\n### 说说恋爱吧\n既然说到了过年，也说说恋爱的观点吧，就说一部分。随着年龄的增大，我也渐渐对女孩子爱理不理俗称着你不找我我也不找你，并不是说我多高冷之类。只是接触的女生也不少，慢慢懂的了一个女生是否愿意和你聊天，这个当然和你性格爱好聊天的话题有很大的联系。如果是帅哥女生说不定会主动给你们的聊天中制造话题。我就不行通常都是我主动提起所有话题，最后的结果是我看到了女生实在不想和我聊天。所以女生不愿意和你聊天，你再怎么努力追都没有用，趁早放弃吧。\n\n### 学无止境\n学习真的是一件使你快乐的事情。2018年，然后驾照也差不多到手了，可以安心的学习不用每天去练车了。这一年，好好学习，找一份工作。\n\n\n\n\n\n\n\n\n\n","categories":["未定义"]}]