<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="https://www.2048.org/favicon.ico" />
    <title>2048</title>

    <style>
        body {
            background-color: #faf8ef;
            text-align: center;
            color: #555;
            display: flex;
            justify-content: center;
            padding-top: 3%;

            /* container bg */
            --background-color: #b9ada0;
            --container-width: 475px;
            --container-height: 485px;
            --nav-height: 100px;
            /* 4 * 100 + 5(é—´éš™) * 15 */
            --stage-width: 475px;
            --stage-height: 475px;
        }

        .text-center {
            text-align: center;
        }

        #app {
            display: flex;
            justify-content: center;
        }

        .container {
            width: var(--container-width);
            height: var(--container-height);
        }

        .nav {
            display: flex;
            flex-flow: row wrap;
            justify-content: space-between;
            height: var(--nav-height);
            /* è®¾ç½®å­—ä½“é«˜åº¦ */
            line-height: 20px;
            text-align: center;
        }

        .nav>.title {
            color: #776e65;
            font-weight: bold;
            font-size: 50px;
            padding-top: 10px;
        }

        .nav-item {
            width: 100px;
            height: 55px;
            margin: 0 10px;
            display: inline-block;
            background-color: var(--background-color);
            border-radius: 3px;
            color: #fff;
        }

        .nav-item>h4 {
            margin: 5px auto;
        }

        .game-container {
            background-color: var(--background-color);
            border-radius: 3px;
            width: var(--stage-width);
            height: var(--stage-height);
            position: relative;
            padding-right: 15px;
            padding-bottom: 15px;
        }

        .stage {
            display: flex;
            flex-flow: row wrap;
        }

        #block>div,
        #grip>div {
            display: inline-block;
            /* å·¦ä¸Šï¼Œä¾¿äºåé¢åç§»é‡è®¡ç®— */
            margin-left: 15px;
            margin-top: 15px;

            border-radius: 3px;
            width: 100px;
            height: 100px;
        }

        #grip>div {
            background-color: #cbc1b4;
        }

        #block>div {
            /* ç»™å…ƒç´ å¼€å¯ç»å¯¹å®šä½ */
            position: absolute;
            background-color: #ede4da;
        }

        #block {
            color: #766e65;
            font-size: 40px;
            line-height: 100px;
            text-align: center;
            font-weight: bold;
        }

        .rank-container {
            border-radius: 1%;
            width: 340px;
            text-align: left;
            padding: 0 20px;
        }

        .rank-item {
            display: flex;
            flex-flow: row wrap;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 20px;
            font-weight: 500;
            color: #2c2a2a;
        }

        .explain {
            font-size: 18px;
            font-weight: normal;
            color: #555;
        }
    </style>
</head>

<body>
    <div id="app">
        <div class="container">
            <div class="nav">
                <div class="title">2048</div>
                <div class="nav-item">
                    <h4>SCORE</h4>
                    <h4 id="score"></h4>
                </div>
                <div class="nav-item">
                    <h4>TIME</h4>
                    <h4 id="time"></h4>
                </div>
            </div>
            <div class="game-container">
                <div class="stage">
                    <div id="grip">
                        <div></div>
                        <div></div>
                        <div></div>
                        <div></div>
                    </div>
                    <div id="grip">
                        <div></div>
                        <div></div>
                        <div></div>
                        <div></div>
                    </div>
                    <div id="grip">
                        <div></div>
                        <div></div>
                        <div></div>
                        <div></div>
                    </div>
                    <div id="grip">
                        <div></div>
                        <div></div>
                        <div></div>
                        <div></div>
                    </div>
                </div>
                <div id="block">
                    <div>2</div>
                </div>
            </div>
        </div>
        <div class="rank-container">
            <h1 class="text-center">æ’è¡Œæ¦œ</h1>
            <div id="rank">
            </div>
            <div class="explain">
                <p>
                    æŒ‰ç©ºæ ¼é”®å¼€å§‹ æˆ– æš‚åœ<br />
                    æŒ‰ â†‘ â†“ â† â†’ è¿›è¡Œç§»åŠ¨
                </p>
            </div>
        </div>

        <script>
            class Block {
                // åç§»é‡
                static OFFSET_RANGE = [0, 120, 240, 360];
                // æ ¼å­
                static BLOCK_RANGE = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
                static BLOCK_RANGE_MATRIX = [
                    [1, 2, 3, 4],
                    [5, 6, 7, 8],
                    [9, 10, 11, 12],
                    [13, 14, 15, 16],
                ]
                // æ•°å­—å†…å®¹
                static NUM_RANGE = [2, 4, 8, 16];
                // èƒŒæ™¯é¢œè‰²
                static BG_COLOR = {
                    2: '#ede4da',
                    4: '#ebe0c8',
                    8: '#ecb078',
                    16: '#ed9461',
                    32: '#ec7b5c',
                }

                constructor(p) {
                    this.element = document.getElementById('block');
                    this.head = document.querySelector('#block > div');
                    this.body = this.element.getElementsByTagName('div');
                    this.setPostion(this.randomPos(Block.BLOCK_RANGE));
                }

                setPostion(p) {
                    this.head.style.left = p.x;
                    this.head.style.top = p.y;
                }

                get X() {
                    return this.head.offsetLeft;
                }

                get Y() {
                    return this.head.offsetTop;
                }

                /**
                 * éšæœºç”Ÿæˆå—ä½ç½®
                 * 1. blockRangeæ˜¯å¯ç”¨å—ä½ç½®ï¼Œ1-16
                 * 2. éšæœºç”Ÿæˆæ•°å­—åï¼Œè§£ææ•°å­—ä¸ºå®é™…çš„åæ ‡(x, y)
                 * 3. æ ‡è®°ä¸ºå·²å ç”¨
                 */
                randomPos(blockRange) {
                    // blockRangeæ˜¯å¯ç”¨å—ä½ç½®ï¼Œ1-16ï¼Œæ³¨æ„åæ ‡åªéšæœºä¸€æ¬¡
                    let blockIndex = this.random(blockRange);

                    // -1æ˜¯ç´¢å¼•ä»0å¼€å§‹ï¼Œ ceilå‘ä¸Šå–æ•´ï¼Œä¸èƒ½ç­‰äº0
                    let xi = Math.ceil(blockIndex / Block.OFFSET_RANGE.length) - 1;
                    let x = Block.OFFSET_RANGE[xi] + 'px';

                    let yi = blockIndex % Block.OFFSET_RANGE.length - 1;
                    // ç¬¬ä¸€è¡Œæ—¶ä¸º0ï¼Œç‰¹æ®Šå¤„ç†
                    yi = yi < 0 ? Block.OFFSET_RANGE.length - 1 : yi;
                    let y = Block.OFFSET_RANGE[yi] + 'px';

                    return { x, y };
                }

                random(blockRange) {
                    return blockRange[Math.round(Math.random() * (blockRange.length - 1))];
                }

                addBody() {
                    if (this.body.length >= 16) {
                        throw new Error('');
                        return;
                    }
                    let num = this.random(Block.NUM_RANGE);
                    let bgColor = Block.BG_COLOR[num];
                    let color = this.getColor(num);
                    let blockRange = this.getBlockRange();
                    let pos = this.randomPos(blockRange);
                    this.element.insertAdjacentHTML('beforeend',
                        `
                        <div style='background-color:${bgColor}; color:${color}; left:${pos.x}; top:${pos.y};'
                        >${num}</div>
                        `
                    );
                }

                getColor(num) {
                    return num > 4 ? '#fff' : '#766e65';
                }

                getBlockRange() {
                    // å»é™¤å·²å ç”¨çš„ä½ç½®
                    let markBlockRange = [];
                    for (let i = 0; i < this.body.length; i++) {
                        // è¿™é‡Œ this.body[i].offsetLeft å’Œ this.body[i].style.left æœ‰åå·®
                        // this.body[i].style.leftæ˜¯å¯¹çš„ '0px'
                        let offsetLeft = Number(this.body[i].style.left.replace('px', ''));
                        let offsetTop = Number(this.body[i].style.top.replace('px', ''));
                        let xi = Block.OFFSET_RANGE.indexOf(offsetLeft);
                        let yi = Block.OFFSET_RANGE.indexOf(offsetTop);
                        markBlockRange.push(Block.BLOCK_RANGE_MATRIX[xi][yi]);
                    }

                    return Block.BLOCK_RANGE.filter(i => !markBlockRange.includes(i));
                }

                /**
                 * ç§»åŠ¨
                 * @param isRow æ˜¯å¦æ°´å¹³ç§»åŠ¨
                 * @param isNear æ˜¯å¦é è¿‘(0, 0)åæ ‡
                 */
                moveBody(isRow, isNear) {
                    // å·¦å³ç§»åŠ¨æ—¶ï¼Œtopä¸€æ ·çš„ä¸ºä¸€ç»„ï¼›ä¸Šä¸‹ç§»åŠ¨æ—¶ï¼Œleftä¸ºä¸€ç»„ã€‚
                    let groupFn = isRow ? item => item.offsetTop : item => item.offsetLeft;
                    let minPos = Block.OFFSET_RANGE[0];
                    let maxPos = Block.OFFSET_RANGE[Block.OFFSET_RANGE.length - 1];

                    let bodyGroup = this.groupBy([...this.body], groupFn);
                    // é‡ç½®
                    this.element.innerHTML = '';
                    for (let i = 0; i < bodyGroup.length; i++) {
                        let currentGoup = bodyGroup[i];
                        // åªæœ‰ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œç›´æ¥ç§»åŠ¨åæ ‡å³å¯
                        if (currentGoup.length === 1) {
                            let currentElement = currentGoup[0];
                            let move = (isNear ? minPos : maxPos) + 'px';
                            if (isRow) {
                                currentElement.style.left = move;
                            } else {
                                currentElement.style.top = move;
                            }
                            this.element.appendChild(currentElement);
                            continue;
                        }

                        // è·ç¦»å‡åºå¤„ç†ï¼Œä¾¿äº åˆ¤æ–­ç›¸é‚»å†…å®¹æ˜¯å¦å¯ä»¥åˆå¹¶ å’Œ é‡æ–°è®¾ç½®ä½ç½®
                        // æ³¨æ„å½“isRowçš„æ—¶å€™ï¼Œè¯´æ˜æ˜¯åŒä¸€è¡Œçš„æ•°æ®ï¼Œé‚£å°±æ˜¯Leftæ’åº
                        let sortFn = isRow ?
                            (div1, div2) => div1.offsetLeft - div2.offsetLeft :
                            (div1, div2) => div1.offsetTop - div2.offsetTop;
                        let sortMergeGroup = this.mergeGroup(currentGoup.sort(sortFn));

                        // é‡æ–°è®¾ç½®ä½ç½®
                        let groupLen = sortMergeGroup.length;
                        for (let g = 0; g < groupLen; g++) {
                            let currentElement = sortMergeGroup[g];
                            // 1 2 3 4
                            // 1 2 3
                            //   1 2 3
                            if (isRow) {
                                if (isNear) {
                                    // å·¦ ç›´æ¥å°±æ˜¯æŒ‰é¡ºåº
                                    currentElement.style.left = Block.OFFSET_RANGE[g] + 'px';
                                } else {
                                    // å³ åˆå§‹åç§» + g
                                    currentElement.style.left = Block.OFFSET_RANGE[Block.OFFSET_RANGE.length - groupLen + g] + 'px';
                                }
                            } else {
                                if (isNear) {
                                    // ä¸Š ç›´æ¥å°±æ˜¯æŒ‰é¡ºåº
                                    currentElement.style.top = Block.OFFSET_RANGE[g] + 'px';
                                } else {
                                    // ä¸‹ åˆå§‹åç§» + g
                                    currentElement.style.top = Block.OFFSET_RANGE[Block.OFFSET_RANGE.length - groupLen + g] + 'px';
                                }
                            }
                            this.element.appendChild(currentElement);
                        }
                    }
                }

                groupBy(arr, fn) {
                    const obj = {};
                    arr.forEach(item => {
                        const key = JSON.stringify(fn(item));
                        obj[key] = obj[key] || [];
                        obj[key].push(item)
                    });
                    return Object.keys(obj).map(k => {
                        return obj[k];
                    })
                }

                mergeGroup(currentGoup, length) {
                    let result;
                    for (let j = 0; j < currentGoup.length - 1; j++) {
                        let currentElement = currentGoup[j];
                        let nextElement = currentGoup[j + 1];
                        // æ•°å€¼ç›¸ç­‰æ—¶åˆå¹¶å†…å®¹
                        if (currentElement.innerHTML == nextElement.innerHTML) {
                            let num = Number(nextElement.innerHTML) * 2
                            nextElement.innerHTML = num;
                            nextElement.style['background-color'] = Block.BG_COLOR[num];
                            nextElement.style.color = this.getColor(num);
                            // æ ‡è®°ï¼Œåç»­æ¸…ç©º
                            currentGoup[j] = null;
                        }
                    }
                    // ç§»é™¤å·²åˆå¹¶çš„å…ƒç´ 
                    result = currentGoup.filter(item => item != null);

                    // å°è¯•ç¬¬äºŒæ¬¡åˆå¹¶
                    if (!length) {
                        result = this.mergeGroup(result, result.length);
                    } else {
                        // å°è¯•ç¬¬ä¸‰æ¬¡åˆå¹¶ï¼Œå¦‚æœè¿˜æœ‰å†…å®¹é‡å¤çš„é€’å½’å¤„ç†
                        let hasRepeat = result.length !== length;
                        if (hasRepeat) {
                            result = this.mergeGroup(result, result.length);
                        }
                    }
                    return result;
                }
            }

            class Panel {

                constructor() {
                    this.scoreElement = document.getElementById('score');
                    this.timeElement = document.getElementById('time');

                    this.score = 0;
                    this.scoreElement.innerHTML = this.padStart(this.score, 3);

                    this.time = 0;
                    this.timeElement.innerHTML = this.padStart(this.time, 3);

                    // è®¾ç½®èƒŒæ™¯éŸ³ä¹
                    this.bgAudio = new Audio("https://img.tukuppt.com/newpreview_music/08/98/97/5c88d1260f3ae75132.mp3");
                    this.dieAudio = new Audio("https://img.tukuppt.com/newpreview_music/09/00/35/5c891c25e1ae638376.mp3");
                    this.bgAudio.playbackRate = 1;
                    this.bgAudio.loop = true;

                    this.rank();
                    this.count();
                }

                padStart(num, maxLength) {
                    return num.toString().padStart(maxLength, '0');
                }

                rank() {
                    let data = JSON.parse(localStorage.getItem('2048-rank'));
                    if (data) {
                        let rankElement = document.getElementById('rank');
                        // é‡ç½®
                        rankElement.innerHTML = '';
                        let tops = ['ğŸ¥·', 'â­', 'â­', 'â­', 'â­', 'â­', 'ğŸ’', 'ğŸ’', 'ğŸ’'];
                        data.forEach((item, index) => {
                            let top = tops[index > tops.length - 1 ? tops.length - 1 : index];
                            let color = index < 3 ? "style='color:#b53e20;'" : null;
                            rankElement.insertAdjacentHTML('beforeend',
                                `
                                <div>
                                    <div class='rank-item' ${color}>
                                        <div>${top}Top${index + 1}</div>
                                        <div>${item.name}</div>
                                        <dvi>${item.score}</div>
                                        </div>
                                </div>
                                `
                            );
                        })
                    }
                }

                count() {
                    // è®¡æ—¶
                    this.interval = setInterval(() => {
                        this.time++;
                        this.timeElement.innerHTML = this.padStart(this.time, 3);
                    }, 1000);
                }

                addScore() {
                    this.score += 100;
                    this.scoreElement.innerHTML = this.padStart(this.score, 3);
                }
            }

            class Control {

                constructor() {
                    this.panel = new Panel();
                    this.block = new Block();
                    document.addEventListener('keydown', this.keyDownHandler.bind(this))
                    this.direction;
                    this.stop = true;
                }

                keyDownHandler(event) {
                    this.direction = event.key;
                }

                run() {
                    // ç§»åŠ¨
                    if (this.direction && this.move()) {
                        // ç®€å•ç‰ˆï¼Œç§»åŠ¨å°±å¢åŠ åˆ†æ•°
                        this.panel.addScore();
                        this.block.addBody();
                        this.direction = null;
                    }
                    try {

                    } catch (e) {
                        this.gameOver(e.message + ' æ¸¸æˆç»“æŸï¼');
                    }
                    setTimeout(this.run.bind(this), 300);
                }

                move() {
                    let isRow, isNear;
                    if (this.direction.indexOf('Up') !== -1) {
                        isRow = false;
                        isNear = true;
                    } else if (this.direction.indexOf('Down') !== -1) {
                        isRow = false;
                        isNear = false;
                    } else if (this.direction.indexOf('Left') !== -1) {
                        isRow = true;
                        isNear = true;
                    } else if (this.direction.indexOf('Right') !== -1) {
                        isRow = true;
                        isNear = false;
                    } else {
                        return false;
                    }

                    this.block.moveBody(isRow, isNear);
                    return true;
                }

                gameOver(msg) {
                    this.panel.bgAudio.pause();
                    this.panel.dieAudio.play();
                    alert(msg);
                    this.save();
                    // é‡ç½®æ¸¸æˆ
                    location.reload();
                }

                save() {
                    let name = prompt("è¯·ç•™ä¸‹ä½ çš„å¤§åï¼š");
                    if (!name || name.trim() === '') {
                        name = 'ä¸æ„¿é€éœ²å§“åçš„é«˜æ‰‹';
                    }
                    let newData = {
                        name,
                        score: this.panel.score,
                    }
                    let data = JSON.parse(localStorage.getItem('2048-rank')) || [];
                    data.push(newData);
                    // é™åº
                    data.sort((u1, u2) => u2.score - u1.score);
                    // ä¿ç•™å‰åé«˜æ‰‹
                    data = data.slice(0, 10);
                    localStorage.setItem('2048-rank', JSON.stringify(data));
                    // é‡æ–°åŠ è½½é¢æ¿
                    this.panel.rank();
                }
            }

            // æ¸¸æˆå¼€å§‹
            new Control().run();
        </script>
</body>

</html>